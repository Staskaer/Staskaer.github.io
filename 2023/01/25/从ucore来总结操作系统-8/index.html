<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/imgs/theme_pic/staskaer.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/imgs/theme_pic/staskaer.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/imgs/theme_pic/staskaer.png">
  <link rel="mask-icon" href="/imgs/theme_pic/staskaer.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="文件系统">
<meta property="og:type" content="article">
<meta property="og:title" content="从ucore来总结操作系统(8)----文件系统">
<meta property="og:url" content="http://example.com/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/index.html">
<meta property="og:site_name" content="Staskaer">
<meta property="og:description" content="文件系统">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/pic1.png">
<meta property="og:image" content="http://example.com/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/pic2.png">
<meta property="og:image" content="http://example.com/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/pic2.png">
<meta property="article:published_time" content="2023-01-25T03:25:32.000Z">
<meta property="article:modified_time" content="2025-06-17T15:50:22.387Z">
<meta property="article:author" content="Staskaer">
<meta property="article:tag" content="ucore操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/pic1.png">

<link rel="canonical" href="http://example.com/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>从ucore来总结操作系统(8)----文件系统 | Staskaer</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Staskaer</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Hi, this is Staskaer</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>links</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/imgs/theme_pic/head_img.png">
      <meta itemprop="name" content="Staskaer">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Staskaer">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          从ucore来总结操作系统(8)----文件系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-25 11:25:32" itemprop="dateCreated datePublished" datetime="2023-01-25T11:25:32+08:00">2023-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-17 23:50:22" itemprop="dateModified" datetime="2025-06-17T23:50:22+08:00">2025-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="文件系统">文件系统</h2>
<span id="more"></span>
<div class="note warning">
            <p>关于ucore的文件系统，可以参考<a target="_blank" rel="noopener" href="https://nankai.gitbook.io/ucore-os-on-risc-v64/lab8/wen-jian-xi-tong-jie-shao"><font color="#0x0000ff">ucore的risc-v的实验指导书</font></a>，写的很有逻辑且详细</p>
          </div>
<h3 id="x00-环境准备">0X00 环境准备</h3>
<p>本lab基于前所有lab，但是需要对其进行一些扩展：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct *<span class="title function_">alloc_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 初始化 PCB 下的 fs(进程相关的文件信息)</span></span><br><span class="line">    proc-&gt;filesp = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_fork</span><span class="params">(<span class="type">uint32_t</span> clone_flags, <span class="type">uintptr_t</span> <span class="built_in">stack</span>, <span class="keyword">struct</span> trapframe *tf)</span> </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 使用 copy_files()函数复制父进程的fs到子进程中</span></span><br><span class="line">    <span class="keyword">if</span> (copy_files(clone_flags, proc) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为proc_struct新增了一个文件相关的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">filesp</span>;</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 当前工作目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// inode of present working directory</span></span><br><span class="line">    <span class="comment">// 文件描述符(数组)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// opened files array</span></span><br><span class="line">    <span class="comment">// 打开的文件数目</span></span><br><span class="line">    <span class="type">int</span> files_count;        <span class="comment">// the number of opened files</span></span><br><span class="line">    <span class="comment">// 用于文件加锁的信号量</span></span><br><span class="line">    <span class="type">semaphore_t</span> files_sem;  <span class="comment">// lock protect sem</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于文件系统比较复杂，我们还是先来通过<strong>实验指导书</strong>来宏观对ucore的文件系统做初步了解。</p>
<h4 id="总体介绍">总体介绍</h4>
<p>ucore的文件系统架构主要由四部分组成：</p>
<ul>
<li><strong>通用文件系统访问接口层</strong>：该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。</li>
<li><strong>文件系统抽象层</strong>：向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。</li>
<li><strong>Simple FS文件系统层</strong>：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口</li>
<li><strong>外设接口层</strong>：向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。</li>
</ul>
<p>对照上面的层次我们再大致介绍一下文件系统的访问处理过程，加深对文件系统的总体理解。假如应用程序操作文件（打开/创建/删除/读写），<strong>首先需要通过文件系统的通用文件系统访问接口层</strong>给用户空间提供的访问接口进入文件系统内部，<strong>接着由文件系统抽象层把访问请求转发给某一具体文件系统</strong>（比如SFS文件系统），具体文件系统（<strong>Simple FS文件系统层</strong>）把应用程序的访问请求转化为对磁盘上的block的处理请求，<strong>并通过外设接口层交给磁盘驱动例程来完成具体的磁盘操作</strong>。结合用户态写文件函数write的整个执行过程，我们可以比较清楚地看出ucore文件系统架构的层次和依赖关系。</p>
<img src="/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/pic1.png" class="">
<p>从ucore操作系统不同的角度来看，ucore中的文件系统架构包含四类主要的数据结构, 它们分别是：</p>
<ul>
<li>超级块（SuperBlock）：它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li>
<li>索引节点（inode）它主要从文件系统的单个文件的角度它描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li>
<li>目录项（dentry）：它主要从文件系统的文件路径的角度描述了文件路径中的一个特定的目录项（注：一系列目录项形成目录/文件路径）。它的作用范围是整个OS空间。对于SFS而言，inode(具体为struct sfs_disk_inode)对应于物理磁盘上的具体对象，dentry（具体为struct sfs_disk_entry）是一个内存实体，其中的ino成员指向对应的inode number，另外一个成员是file name(文件名).</li>
<li>文件（file），它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li>
</ul>
<p>如果一个用户进程打开了一个文件，那么在ucore中涉及的相关数据结构和关系如下图所示：</p>
<img src="/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/pic2.png" class="">
<h4 id="层次结构">层次结构</h4>
<h5 id="通用文件系统访问接口层">通用文件系统访问接口层</h5>
<p>我们把上面刚出现的proc_struct和files_struct重新看一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">filesp</span>;</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 当前工作目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// inode of present working directory</span></span><br><span class="line">    <span class="comment">// 文件描述符(数组)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// opened files array</span></span><br><span class="line">    <span class="comment">// 打开的文件数目</span></span><br><span class="line">    <span class="type">int</span> files_count;        <span class="comment">// the number of opened files</span></span><br><span class="line">    <span class="comment">// 用于文件加锁的信号量</span></span><br><span class="line">    <span class="type">semaphore_t</span> files_sem;  <span class="comment">// lock protect sem</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>prco结构体</code>中的<code>files_struct结构体</code>指针指向当前程序打开的所有文件，因此files_struct结构体用于描述多个打开的文件。而在files_struct结构体内部，存在一个<code>file结构体</code>数组用于存放打开的所有文件，也存在一个<code>inode结构体</code>指针指向当前工作目录。</p>
<p>如果将proc结构体看作是一个一个线程、那么files_struct结构体就可以看成是<strong>通用文件系统访问接口层的抽象</strong>，基于此，用户(线程)可以使用open、close等通用系统调用接口来管理文件。</p>
<details>
<p><summary><code>通用文件系统访问接口层的抽象</code>(大致看一下就行)</summary></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uint32_t</span> open_flags)</span>;        <span class="comment">// Open or create a file. FLAGS/MODE per the syscall.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_close</span><span class="params">(<span class="type">int</span> fd)</span>;                                      <span class="comment">// Close a vnode opened  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *base, <span class="type">size_t</span> len)</span>;               <span class="comment">// Read file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *base, <span class="type">size_t</span> len)</span>;              <span class="comment">// Write file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_seek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> pos, <span class="type">int</span> whence)</span>;                <span class="comment">// Seek file  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *stat)</span>;                   <span class="comment">// Stat file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_fsync</span><span class="params">(<span class="type">int</span> fd)</span>;                                      <span class="comment">// Sync file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;                            <span class="comment">// change DIR  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;                            <span class="comment">// create DIR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path1, <span class="type">const</span> <span class="type">char</span> *path2)</span>;         <span class="comment">// set a path1's link as path2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path1, <span class="type">const</span> <span class="type">char</span> *path2)</span>;       <span class="comment">// rename file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;                           <span class="comment">// unlink a path</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span>;                      <span class="comment">// get current working directory</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_getdirentry</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> dirent *direntp)</span>;        <span class="comment">// get the file entry in DIR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_dup</span><span class="params">(<span class="type">int</span> fd1, <span class="type">int</span> fd2)</span>;                              <span class="comment">// duplicate file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_pipe</span><span class="params">(<span class="type">int</span> *fd_store)</span>;                                <span class="comment">// build PIPE</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> open_flags)</span>;      <span class="comment">// build named PIPE</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<p><summary><code>通用文件系统访问接口层的抽象(更底层API)</code>(大致看一下就行)</summary></p>
<p>在这些sysfile_xx函数中，调用的下一层函数分别是封装好的各个file_xx函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_open</span><span class="params">(<span class="type">char</span> *path, <span class="type">uint32_t</span> open_flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *base, <span class="type">size_t</span> len, <span class="type">size_t</span> *copied_store)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *base, <span class="type">size_t</span> len, <span class="type">size_t</span> *copied_store)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_seek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> pos, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *stat)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_getdirentry</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> dirent *dirent)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_dup</span><span class="params">(<span class="type">int</span> fd1, <span class="type">int</span> fd2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_pipe</span><span class="params">(<span class="type">int</span> fd[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> open_flags)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h5 id="文件系统抽象层">文件系统抽象层</h5>
<p>文件系统抽象层是把不同文件系统的对外共性接口提取出来，形成一个函数指针数组，这样，通用文件系统访问接口层只需访问文件系统抽象层，而不需关心具体文件系统的实现细节和接口。</p>
<p>系统接口再下一层就到了VFS虚拟文件系统。VFS函数涉及到了文件结构体file和inode结构体。</p>
<p>然后我们看一下file结构体和inode结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 状态值，描述文件打开、关闭、初始化等</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">    {</span></span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    } status;</span><br><span class="line">    <span class="comment">// 读写权限</span></span><br><span class="line">    <span class="type">bool</span> readable;</span><br><span class="line">    <span class="type">bool</span> writable;</span><br><span class="line">    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 下一次写入的起始位置</span></span><br><span class="line">    <span class="type">off_t</span> pos; </span><br><span class="line">    <span class="comment">// 文件的i结点数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="comment">// 打开此文件的次数</span></span><br><span class="line">    <span class="type">int</span> open_count;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 包含不同文件系统特定inode信息的union成员变量</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">    {</span>                     </span><br><span class="line">        <span class="comment">//设备文件系统内存inode信息            </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span>       </span><br><span class="line">        <span class="comment">//SFS文件系统内存inode信息   </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span>    </span><br><span class="line">    } in_info;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此inode所属文件系统类型</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">    {</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    } in_type;              </span><br><span class="line">    <span class="comment">// 此inode的引用计数            </span></span><br><span class="line">    <span class="type">atomic_t</span> ref_count;    </span><br><span class="line">    <span class="comment">// 打开此inode对应文件的个数             </span></span><br><span class="line">    <span class="type">atomic_t</span> open_count;              </span><br><span class="line">    <span class="comment">// 抽象的文件系统，包含访问文件系统的函数指针  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span>                   </span><br><span class="line">    <span class="comment">// 抽象的inode操作，包含访问inode的函数指针     </span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span>     </span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>file结构体指定了文件的相关类型，包括读写权限，文件描述符fd，当前读取到的位置pos，文件系统中与硬盘特定区域所对应的结点node，以及打开的引用次数open_count。index node是位于内存的索引节点，它是VFS结构中的重要数据结构，因为它实际负责把不同文件系统的特定索引节点信息（甚至不能算是一个索引节点）统一封装起来，避免了进程直接访问具体文件系统。</p>
<p>inode结构体中存放了info、类型type、引用次数ref_count、打开次数open_count、相关联的文件系统in_fs以及当前结构所对应的操作集合in_ops。<strong>该结构与硬盘上对应区域相关联，从而便于对硬盘进行操作。</strong></p>
<p>inode_ops成员是对常规文件、目录、设备文件所有操作的一个抽象函数表示。对于某一具体的文件系统中的文件或目录，只需实现相关的函数，就可以被用户进程访问具体的文件了，且用户进程无需了解具体文件系统的实现细节。</p>
<details>
<p><summary><code>file结构体对应的接口</code>(大致看一下就行)</summary></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Virtual File System layer functions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The VFS layer translates operations on abstract on-disk files or</span></span><br><span class="line"><span class="comment"> * pathnames to operations on specific files on specific filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vfs_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vfs_cleanup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vfs_devlist_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer low-level operations.</span></span><br><span class="line"><span class="comment"> * See inode.h for direct operations on inodes.</span></span><br><span class="line"><span class="comment"> * See fs.h for direct operations on filesystems/devices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_set_curdir   - change current directory of current thread by inode</span></span><br><span class="line"><span class="comment"> *    vfs_get_curdir   - retrieve inode of current directory of current thread</span></span><br><span class="line"><span class="comment"> *    vfs_get_root     - get root inode for the filesystem named DEVNAME</span></span><br><span class="line"><span class="comment"> *    vfs_get_devname  - get mounted device name for the filesystem passed in</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_set_curdir</span><span class="params">(<span class="keyword">struct</span> inode *dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_get_curdir</span><span class="params">(<span class="keyword">struct</span> inode **dir_store)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_get_root</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname, <span class="keyword">struct</span> inode **root_store)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">vfs_get_devname</span><span class="params">(<span class="keyword">struct</span> fs *fs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer high-level operations on pathnames</span></span><br><span class="line"><span class="comment"> * Because namei may destroy pathnames, these all may too.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_open         - Open or create a file. FLAGS/MODE per the syscall.</span></span><br><span class="line"><span class="comment"> *    vfs_close  - Close a inode opened with vfs_open. Does not fail.</span></span><br><span class="line"><span class="comment"> *                 (See vfspath.c for a discussion of why.)</span></span><br><span class="line"><span class="comment"> *    vfs_link         - Create a hard link to a file.</span></span><br><span class="line"><span class="comment"> *    vfs_symlink      - Create a symlink PATH containing contents CONTENTS.</span></span><br><span class="line"><span class="comment"> *    vfs_readlink     - Read contents of a symlink into a uio.</span></span><br><span class="line"><span class="comment"> *    vfs_mkdir        - Create a directory. MODE per the syscall.</span></span><br><span class="line"><span class="comment"> *    vfs_unlink       - Delete a file/directory.</span></span><br><span class="line"><span class="comment"> *    vfs_rename       - rename a file.</span></span><br><span class="line"><span class="comment"> *    vfs_chdir  - Change current directory of current thread by name.</span></span><br><span class="line"><span class="comment"> *    vfs_getcwd - Retrieve name of current directory of current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_open</span><span class="params">(<span class="type">char</span> *path, <span class="type">uint32_t</span> open_flags, <span class="keyword">struct</span> inode **inode_store)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_close</span><span class="params">(<span class="keyword">struct</span> inode *node)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_link</span><span class="params">(<span class="type">char</span> *old_path, <span class="type">char</span> *new_path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_symlink</span><span class="params">(<span class="type">char</span> *old_path, <span class="type">char</span> *new_path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_readlink</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> iobuf *iob)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_mkdir</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_unlink</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_rename</span><span class="params">(<span class="type">char</span> *old_path, <span class="type">char</span> *new_path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_chdir</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_getcwd</span><span class="params">(<span class="keyword">struct</span> iobuf *iob)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer mid-level operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_lookup     - Like VOP_LOOKUP, but takes a full device:path name,</span></span><br><span class="line"><span class="comment"> *                     or a name relative to the current directory, and</span></span><br><span class="line"><span class="comment"> *                     goes to the correct filesystem.</span></span><br><span class="line"><span class="comment"> *    vfs_lookparent - Likewise, for VOP_LOOKPARENT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Both of these may destroy the path passed in.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_lookup</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> inode **node_store)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_lookup_parent</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> inode **node_store, <span class="type">char</span> **endp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Misc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_set_bootfs - Set the filesystem that paths beginning with a</span></span><br><span class="line"><span class="comment"> *                    slash are sent to. If not set, these paths fail</span></span><br><span class="line"><span class="comment"> *                    with ENOENT. The argument should be the device</span></span><br><span class="line"><span class="comment"> *                    name or volume name for the filesystem (such as</span></span><br><span class="line"><span class="comment"> *                    "lhd0:") but need not have the trailing colon.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_get_bootfs - return the inode of the bootfs filesystem.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_add_fs     - Add a hardwired filesystem to the VFS named device</span></span><br><span class="line"><span class="comment"> *                    list. It will be accessible as "devname:". This is</span></span><br><span class="line"><span class="comment"> *                    intended for filesystem-devices like emufs, and</span></span><br><span class="line"><span class="comment"> *                    gizmos like Linux procfs or BSD kernfs, not for</span></span><br><span class="line"><span class="comment"> *                    mounting filesystems on disk devices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_add_dev    - Add a device to the VFS named device list. If</span></span><br><span class="line"><span class="comment"> *                    MOUNTABLE is zero, the device will be accessible</span></span><br><span class="line"><span class="comment"> *                    as "DEVNAME:". If the mountable flag is set, the</span></span><br><span class="line"><span class="comment"> *                    device will be accessible as "DEVNAMEraw:" and</span></span><br><span class="line"><span class="comment"> *                    mountable under the name "DEVNAME". Thus, the</span></span><br><span class="line"><span class="comment"> *                    console, added with MOUNTABLE not set, would be</span></span><br><span class="line"><span class="comment"> *                    accessed by pathname as "con:", and lhd0, added</span></span><br><span class="line"><span class="comment"> *                    with mountable set, would be accessed by</span></span><br><span class="line"><span class="comment"> *                    pathname as "lhd0raw:" and mounted by passing</span></span><br><span class="line"><span class="comment"> *                    "lhd0" to vfs_mount.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_mount      - Attempt to mount a filesystem on a device. The</span></span><br><span class="line"><span class="comment"> *                    device named by DEVNAME will be looked up and</span></span><br><span class="line"><span class="comment"> *                    passed, along with DATA, to the supplied function</span></span><br><span class="line"><span class="comment"> *                    MOUNTFUNC, which should create a struct fs and</span></span><br><span class="line"><span class="comment"> *                    return it in RESULT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_unmount    - Unmount the filesystem presently mounted on the</span></span><br><span class="line"><span class="comment"> *                    specified device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_unmountall - Unmount all mounted filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_set_bootfs</span><span class="params">(<span class="type">char</span> *fsname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_get_bootfs</span><span class="params">(<span class="keyword">struct</span> inode **node_store)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_add_fs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname, <span class="keyword">struct</span> fs *fs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_add_dev</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname, <span class="keyword">struct</span> inode *devnode, <span class="type">bool</span> mountable)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname, <span class="type">int</span> (*mountfunc)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> fs **fs_store))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_unmount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_unmount_all</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vfs中更为底层的函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> {</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vop_magic;</span><br><span class="line">    <span class="type">int</span> (*vop_open)(<span class="keyword">struct</span> inode *node, <span class="type">uint32_t</span> open_flags);</span><br><span class="line">    <span class="type">int</span> (*vop_close)(<span class="keyword">struct</span> inode *node);</span><br><span class="line">    <span class="type">int</span> (*vop_read)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_write)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_fstat)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> stat *stat);</span><br><span class="line">    <span class="type">int</span> (*vop_fsync)(<span class="keyword">struct</span> inode *node);</span><br><span class="line">    <span class="type">int</span> (*vop_namefile)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_getdirentry)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_reclaim)(<span class="keyword">struct</span> inode *node);</span><br><span class="line">    <span class="type">int</span> (*vop_gettype)(<span class="keyword">struct</span> inode *node, <span class="type">uint32_t</span> *type_store);</span><br><span class="line">    <span class="type">int</span> (*vop_tryseek)(<span class="keyword">struct</span> inode *node, <span class="type">off_t</span> pos);</span><br><span class="line">    <span class="type">int</span> (*vop_truncate)(<span class="keyword">struct</span> inode *node, <span class="type">off_t</span> len);</span><br><span class="line">    <span class="type">int</span> (*vop_create)(<span class="keyword">struct</span> inode *node, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">bool</span> excl, <span class="keyword">struct</span> inode **node_store);</span><br><span class="line">    <span class="type">int</span> (*vop_lookup)(<span class="keyword">struct</span> inode *node, <span class="type">char</span> *path, <span class="keyword">struct</span> inode **node_store);</span><br><span class="line">    <span class="type">int</span> (*vop_ioctl)(<span class="keyword">struct</span> inode *node, <span class="type">int</span> op, <span class="type">void</span> *data);</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<p>文件系统抽象层VFS提供了file接口、dir接口、inode接口、fs接口以及外设接口。而这些接口在sfs中被具体实现。</p>
<h5 id="simple-fs-文件系统层">Simple FS 文件系统层</h5>
<p>ucore内核把所有文件都看作是字节流，任何内部逻辑结构都是专用的，由应用程序负责解释。但是ucore区分文件的物理结构。ucore目前支持如下几种类型的文件：</p>
<ul>
<li><strong>常规文件</strong>：文件中包括的内容信息是由应用程序输入。SFS文件系统在普通文件上不强加任何内部结构，把其文件内容信息看作为字节。</li>
<li><strong>目录</strong>：包含一系列的entry，每个entry包含文件名和指向与之相关联的索引节点（index node）的指针。目录是按层次结构组织的。</li>
<li><strong>链接文件</strong>：实际上一个链接文件是一个已经存在的文件的另一个可选择的文件名。</li>
<li><strong>设备文件</strong>：不包含数据，但是提供了一个映射物理设备（如串口、键盘等）到一个文件名的机制。可通过设备文件访问外围设备。</li>
<li><strong>管道</strong>：管道是进程间通讯的一个基础设施。管道缓存了其输入端所接受的数据，以便在管道输出端读的进程能一个先进先出的方式来接受数据。</li>
</ul>
<p>SFS文件系统中目录和常规文件具有共同的属性，而这些属性保存在索引节点中。SFS通过索引节点来管理目录和常规文件，索引节点包含操作系统所需要的关于某个文件的关键信息，比如文件的属性、访问许可权以及其它控制信息都保存在索引节点中。可以有多个文件名可指向一个索引节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Abstract filesystem. (Or device accessible as a file.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Information:</span></span><br><span class="line"><span class="comment"> *      fs_info   : filesystem-specific data (sfs_fs)</span></span><br><span class="line"><span class="comment"> *      fs_type   : filesystem type</span></span><br><span class="line"><span class="comment"> * Operations:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      fs_sync       - Flush all dirty buffers to disk.</span></span><br><span class="line"><span class="comment"> *      fs_get_root   - Return root inode of filesystem.</span></span><br><span class="line"><span class="comment"> *      fs_unmount    - Attempt unmount of filesystem.</span></span><br><span class="line"><span class="comment"> *      fs_cleanup    - Cleanup of filesystem.???</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * fs_get_root should increment the refcount of the inode returned.</span></span><br><span class="line"><span class="comment"> * It should not ever return NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If fs_unmount returns an error, the filesystem stays mounted, and</span></span><br><span class="line"><span class="comment"> * consequently the struct fs instance should remain valid. On success,</span></span><br><span class="line"><span class="comment"> * however, the filesystem object and all storage associated with the</span></span><br><span class="line"><span class="comment"> * filesystem should have been discarded/released.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    {</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> __<span class="title">sfs_info</span>;</span></span><br><span class="line">    } fs_info; <span class="comment">// filesystem-specific data</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">    {</span></span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    } fs_type;                                   <span class="comment">// filesystem type</span></span><br><span class="line">    <span class="type">int</span> (*fs_sync)(<span class="keyword">struct</span> fs *fs);               <span class="comment">// Flush all dirty buffers to disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">fs_get_root</span>)(<span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>);</span> <span class="comment">// Return root inode of filesystem.</span></span><br><span class="line">    <span class="type">int</span> (*fs_unmount)(<span class="keyword">struct</span> fs *fs);            <span class="comment">// Attempt unmount of filesystem.</span></span><br><span class="line">    <span class="type">void</span> (*fs_cleanup)(<span class="keyword">struct</span> fs *fs);           <span class="comment">// Cleanup of filesystem.???</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* filesystem for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>  <span class="comment">/* on-disk superblock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>      <span class="comment">/* device mounted on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>  <span class="comment">/* blocks in use are mared 0 */</span></span><br><span class="line">    <span class="type">bool</span> super_dirty;        <span class="comment">/* true if super/freemap modified */</span></span><br><span class="line">    <span class="type">void</span> *sfs_buffer;        <span class="comment">/* buffer for non-block aligned io */</span></span><br><span class="line">    <span class="type">semaphore_t</span> fs_sem;      <span class="comment">/* semaphore for fs */</span></span><br><span class="line">    <span class="type">semaphore_t</span> io_sem;      <span class="comment">/* semaphore for io */</span></span><br><span class="line">    <span class="type">semaphore_t</span> mutex_sem;   <span class="comment">/* semaphore for link/unlink and rename */</span></span><br><span class="line">    <span class="type">list_entry_t</span> inode_list; <span class="comment">/* inode linked-list */</span></span><br><span class="line">    <span class="type">list_entry_t</span> *hash_list; <span class="comment">/* inode hash linked-list */</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sfs_fs结构中包含了底层设备的超级块superblock、所挂载的设备dev、以及底层设备中用于表示空间分配情况的freemap等。fs结构是我们在上层函数调用中所直接操作的抽象文件系统，而sfs_fs则是在下层函数中所使用的。在原先sfs_fs上抽象出一层fs结构有助于忽略不同文件系统的差异。</p>
<details>
<p><summary><code>对应的接口为</code>(大致看一下就行)</summary></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sfs_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_sfs_fs</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_sfs_io</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock_sfs_fs</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock_sfs_io</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_rblock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">void</span> *buf, <span class="type">uint32_t</span> blkno, <span class="type">uint32_t</span> nblks)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_wblock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">void</span> *buf, <span class="type">uint32_t</span> blkno, <span class="type">uint32_t</span> nblks)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_rbuf</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">uint32_t</span> blkno, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_wbuf</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">uint32_t</span> blkno, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_sync_super</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_sync_freemap</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_clear_block</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">uint32_t</span> blkno, <span class="type">uint32_t</span> nblks)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_load_inode</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="keyword">struct</span> inode **node_store, <span class="type">uint32_t</span> ino)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sfs_sync</span><span class="params">(<span class="keyword">struct</span> fs *fs)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode* <span class="title function_">sfs_get_root</span><span class="params">(<span class="keyword">struct</span> fs *fs)</span> ;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sfs_unmount</span><span class="params">(<span class="keyword">struct</span> fs *fs)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sfs_cleanup</span><span class="params">(<span class="keyword">struct</span> fs *fs)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fs_init_read</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">uint32_t</span> blkno, <span class="type">void</span> *blk_buffer)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fs_do_mount</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> fs **fs_store)</span>;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<p>文件系统通常保存在磁盘上。在本实验中，第三个磁盘（即disk0，前两个磁盘分别是 ucore.img 和 swap.img）用于存放一个SFS文件系统（Simple Filesystem）。通常文件系统中，磁盘的使用是以扇区（Sector）为单位的，但是为了实现简便，SFS 中以 block （4K，与内存 page 大小相等）为基本单位。布局如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+------------+----------+---------+-------------------------------------+</span><br><span class="line">| superblock | root-dir | freemap | Inode / File Data / Dir Data blocks |</span><br><span class="line">+------------+----------+---------+-------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>第0个块（4K）是超级块（superblock），它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存。其定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On-disk superblock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 超级块结构中包含成员变量魔数magic，内核通过它来检查磁盘镜像是否是合法的 SFS img</span></span><br><span class="line">    <span class="type">uint32_t</span> magic;                                 <span class="comment">/* magic number, should be SFS_MAGIC */</span></span><br><span class="line">    <span class="type">uint32_t</span> blocks;                                <span class="comment">/* # of blocks in fs */</span></span><br><span class="line">    <span class="type">uint32_t</span> unused_blocks;                         <span class="comment">/* # of unused blocks in fs */</span></span><br><span class="line">    <span class="type">char</span> info[SFS_MAX_INFO_LEN + <span class="number">1</span>];                <span class="comment">/* infomation for sfs  */</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>第1个块放了一个root-dir的inode，用来记录根目录的相关信息。root-dir是SFS文件系统的根结点，通过这个root-dir的inode信息就可以定位并查找到根目录下的所有文件信息。</li>
<li>从第2个块开始，根据SFS中所有块的数量，用1个bit来表示一个块的占用和未被占用的情况。这个区域称为SFS的freemap区域，这将占用若干个块空间。为了更好地记录和管理freemap区域</li>
<li>最后在剩余的磁盘空间中，存放了所有其他目录和文件的inode信息和内容数据信息。需要注意的是虽然inode的大小小于一个块的大小（4096B），但为了实现简单，每个 inode 都占用一个完整的 block。</li>
</ul>
<div class="note info">
            <p><strong>索引结点</strong></p><p><strong>在sfs层面上，inode结构既可表示文件file、目录dir，也可表示设备device</strong>。而区分inode结构的操作有两种，一种是其in_info成员变量，另一种是该结构的成员指针in_ops。当uCore创建一个用于<strong>存储文件/目录的inode结构</strong>（即该inode结构的in_info成员变量为sfs_inode类型）时，程序会执行函数sfs_create_inode。该函数会将inode结构中的sfs_inode成员与磁盘对应结点sfs_disk_inode相关联，从而使得只凭inode即可操作该结点。</p><p>而sfs_disk_inode结构记录了<strong>文件或目录的内容存储的索引信息</strong>，该数据结构在硬盘里储存，需要时读入内存。type成员表明该结构是目录类型还是文件类型，又或者是链接link类型。如果inode表示的是文件，则成员变量direct[]直接指向了保存文件内容数据的数据块索引值。indirect指向的是间接数据块，此数据块实际存放的全部是数据块索引，这些数据块索引指向的数据块才被用来存放文件内容数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* file types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SFS_TYPE_INVAL 0 <span class="comment">/* Should not appear on disk */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SFS_TYPE_FILE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SFS_TYPE_DIR 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SFS_TYPE_LINK 3</span></span><br><span class="line"><span class="comment">/* inode (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 如果inode表示常规文件，则size是文件大小</span></span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="comment">// inode的文件类型</span></span><br><span class="line">    <span class="type">uint16_t</span> type;</span><br><span class="line">    <span class="comment">// 此inode的硬链接数</span></span><br><span class="line">    <span class="type">uint16_t</span> nlinks;</span><br><span class="line">    <span class="comment">// 此inode的数据块数的个数</span></span><br><span class="line">    <span class="type">uint32_t</span> blocks;</span><br><span class="line">    <span class="comment">// 此inode的直接数据块索引值（有SFS_NDIRECT个）</span></span><br><span class="line">    <span class="type">uint32_t</span> direct[SFS_NDIRECT];</span><br><span class="line">    <span class="comment">// 此inode的一级间接数据块索引值</span></span><br><span class="line">    <span class="type">uint32_t</span> indirect;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于普通文件，索引值指向的 block 中保存的是文件中的数据。而对于目录，索引值指向的数据保存的是目录下所有的文件名以及对应的索引节点所在的索引块（磁盘块）所形成的数组。即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* file entry (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 索引节点所占数据块索引值</span></span><br><span class="line">    <span class="type">uint32_t</span> ino;</span><br><span class="line">    <span class="comment">// 文件名</span></span><br><span class="line">    <span class="type">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有<strong>内存索引点</strong>，保存在内存中的索引结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* inode for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">/* on-disk inode */</span></span><br><span class="line">    <span class="type">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="type">bool</span> dirty;                                     <span class="comment">/* true if inode modified */</span></span><br><span class="line">    <span class="type">int</span> reclaim_count;                              <span class="comment">/* kill inode if it hits zero */</span></span><br><span class="line">    <span class="type">semaphore_t</span> sem;                                <span class="comment">/* semaphore for din */</span></span><br><span class="line">    <span class="type">list_entry_t</span> inode_link;                        <span class="comment">/* entry for linked-list in sfs_fs */</span></span><br><span class="line">    <span class="type">list_entry_t</span> hash_link;                         <span class="comment">/* entry for hash linked-list in sfs_fs */</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SFS中的内存sfs_inode除了包含SFS的硬盘sfs_disk_inode信息，而且还增加了其他一些信息。这些信息用于判断相关硬盘位置是否改写、互斥操作、回收和快速地定位等作用。</p><p>需要注意的是，<strong>一个内存sfs_inode是在打开一个文件后才创建的</strong>，如果关机则相关信息都会消失。而<strong>硬盘sfs_disk_inode的内容是保存在硬盘中的</strong>，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</p><p>还有<strong>文件结点</strong>, 用于指向磁盘索引结点的结点，其结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* file entry (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="type">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">/* file name */</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件结点中的name表示当前文件的文件名，而其ino成员则指向了sfs_disk_inode磁盘索引结点。上一层的目录索引结点则会指向各个下层的文件结点。</p><p>同时，为了方便实现上面提到的多级数据的访问以及目录中 entry 的操作，对于inode，SFS实现了一些辅助的函数，它们分别是</p><ul><li>sfs_bmap_load_nolock : 将对应sfs_inode的第 index 个索引指向的 block 的索引值取出，并存到相应的指针指向的单元（ino_store）。如果index == din-&gt;blocks, 则将会为inode增长一个 block。并标记 inode 为 dirty</li><li>sfs_bmap_truncate_nolock : 将多级数据索引表的最后一个 entry 释放掉。该函数可以认为是sfs_bmap_load_nolock中，index == inode-&gt;blocks的逆操作。</li><li>sfs_dirent_read_nolock : 将目录的第 slot 个 entry 读取到指定的内存空间。</li><li>sfs_dirent_search_nolock : 该函数是常用的查找函数，函数会在目录下查找 name，并且返回相应的搜索结果（文件或文件夹）的 inode 的编号（也是磁盘编号），和相应的 entry 在该目录的 index 编号以及目录下的数据页是否有空闲的 entry。</li></ul><p><strong>需要注意的是，这些后缀为nolock的函数，只能在已经获得相应inode的semaphore才能调用。</strong></p>
          </div>
<h5 id="外设接口层io设备">外设接口层(I/O设备)</h5>
<p>在底层一点就是I/O设备的相关实现，这些部分直接基于驱动来实现。</p>
<h4 id="文件系统挂载流程">文件系统挂载流程</h4>
<p>一个文件系统在使用前，需要将其挂载至内核中。在uCore里，硬盘disk0的挂载流程如下：</p>
<ul>
<li>首先，在fs_init函数中执行init_device(disk0)，初始化对应device结构并将其连接至vdev_list链表中：</li>
<li>之后，在fs_init函数中执行sfs_init() -&gt; sfs_mount("disk0")</li>
<li>紧接着，sfs_mount会调用vfs_mount，在vfs的挂载接口中调用sfs自己的sfs_do_mount挂载函数。sfs_do_mount挂载函数会执行以下几个操作
<ul>
<li>从待挂载设备中读取超级块，并验证超级块中，魔数与总块数是否存在错误</li>
<li>初始化哈希链表</li>
<li>从待挂载设备中读入freemap并测试其正确性</li>
<li>设置fs结构的相关信息，并在函数最后将该信息设置为传入的device结构体中的fs成员变量</li>
</ul></li>
</ul>
<h3 id="x01-完成读文件操作的实现">0X01 完成读文件操作的实现</h3>
<p>我们还是先来看一下这张图：</p>
<img src="/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/pic2.png" class="">
<div class="note primary">
            <p><strong>打开文件流程</strong></p><p>首先假定用户进程需要打开的文件已经存在在硬盘上。当调用<code>open</code>函数打开一个文件时，首先进入通用<strong>文件访问接口层</strong>的处理流程，即进一步调用如下用户态函数： open-&gt;sys_open-&gt;syscall，从而引起系统调用进入到内核态。到了内核态后，<strong>通过中断处理例程</strong>，会调用到sys_open内核函数，并进一步调用sysfile_open内核函数。到了这里，需要把位于用户空间的字符串"sfs_filetest1"拷贝到内核空间中的字符串path中，<strong>并进入到文件系统抽象层</strong>的处理流程完成进一步的打开文件操作中。</p><p>在文件系统抽象层中，需要调用的是file_open函数，它要给这个即将打开的文件<strong>分配一个file数据结构</strong>的变量，这个变量其实是当前进程的打开文件数组current-&gt;fs_struct-&gt;filemap[]中的一个空闲元素（即还没用于一个打开的文件），而这个元素的索引值就是最终要返回到用户进程并赋值给变量fd1。到了这一步还仅仅是给当前用户进程分配了一个file数据结构的变量，还没有找到对应的文件索引节点。为此需要进一步调用vfs_open函数来找到path指出的<strong>文件所对应的基于inode数据结构的VFS索引节点node</strong>。vfs_open函数需要完成两件事情：通过vfs_lookup找到path对应文件的inode；调用vop_open函数打开文件：</p><ul><li>找到文件设备的根目录“/”的索引节点需要注意，这里的vfs_lookup函数是一个针对目录的操作函数，它会调用vop_lookup函数来找到SFS文件系统中的“/”目录下的“sfs_filetest1”文件。为此，vfs_lookup函数首先调用get_device函数，并进一步调用vfs_get_bootfs函数（其实调用了）来找到根目录“/”对应的inode。这个inode就是位于vfs.c中的inode变量bootfs_node。这个变量在init_main函数（位于kern/process/proc.c）执行时获得了赋值。</li><li>通过调用vop_lookup函数来查找到根目录“/”下对应文件sfs_filetest1的索引节点，，如果找到就返回此索引节点。</li><li>把file和node建立联系。完成第3步后，将返回到file_open函数中，通过执行语句“file-&gt;node=node;”，就把当前进程的current-&gt;fs_struct-&gt;filemap[fd]（即file所指变量）的成员变量node指针指向了代表sfs_filetest1文件的索引节点inode。这时返回fd。经过重重回退，通过系统调用返回，用户态的syscall-&gt;sys_open-&gt;open-&gt;safe_open等用户函数的层层函数返回，最终把把fd赋值给fd1。自此完成了打开文件操作。但这里我们还没有分析第2和第3步是如何进一步调用SFS文件系统提供的函数找位于SFS文件系统上的sfs_filetest1文件所对应的sfs磁盘inode的过程。</li></ul>
          </div>
<p>当线程打开文件后尝试读取文件，则<strong>先进入通用文件访问接口层的处理流程</strong>，即进一步调用如下用户态函数：read-&gt;sys_read-&gt;syscall，从而引起系统调用进入到内核态。到了内核态以后，通过中断处理例程，会调用到sys_read内核函数，并进一步调用sysfile_read内核函数，<strong>进入到文件系统抽象层处理流程</strong>完成进一步读文件的操作。</p>
<p>在文件系统抽象层中，会检查错误并调用kmalloc分配4096字节的buffer空间。当读取时，先检查剩余部分大小，保证除最后一次外其余都是按照4096字节读，这部分调用file_read来实现。由于在内核态读取，所以需要将其拷贝到用户内存空间中。</p>
<p>我们顺着file_read往下看，主要执行read的函数是vop_read(vop_read函数实际上是对sfs_read的包装)，sfs_read函数直接调用sfs_io函数，而该函数将进一步调用sfs_io_nolock。sfs_io_nolock正是我们需要实现的函数。</p>
<p>注释中已经提醒我们，sys_io_nolock是按块读取，但是一个文件开头部分未必是块对齐的，结尾部分也未必是块对齐的，所以我们要把这两部分单独处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_io_nolock - Rd/Wr a file contentfrom offset position to offset+ length  disk blocks&lt;--&gt;buffer (in memroy)</span></span><br><span class="line"><span class="comment"> * @sfs:      sfs file system</span></span><br><span class="line"><span class="comment"> * @sin:      sfs inode in memory</span></span><br><span class="line"><span class="comment"> * @buf:      the buffer Rd/Wr</span></span><br><span class="line"><span class="comment"> * @offset:   the offset of file</span></span><br><span class="line"><span class="comment"> * @alenp:    the length need to read (is a pointer). and will RETURN the really Rd/Wr lenght</span></span><br><span class="line"><span class="comment"> * @write:    BOOL, 0 read, 1 write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sfs_io_nolock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="keyword">struct</span> sfs_inode *<span class="built_in">sin</span>, <span class="type">void</span> *buf, <span class="type">off_t</span> offset, <span class="type">size_t</span> *alenp, <span class="type">bool</span> write)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(din-&gt;type != SFS_TYPE_DIR);</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> endpos = offset + *alenp, blkoff;</span><br><span class="line">    *alenp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// calculate the Rd/Wr end position</span></span><br><span class="line">    <span class="comment">// 计算缓冲区读取/写入的终止位置</span></span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果偏移与终止位置相同，即欲读取/写入0字节的数据则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (offset == endpos)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE)</span><br><span class="line">    {</span><br><span class="line">        endpos = SFS_MAX_FILE_SIZE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!write)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 如果是读取数据，且缓冲区中剩余的数据超出一个硬盘节点的数据大小就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= din-&gt;size)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (endpos &gt; din-&gt;size)</span><br><span class="line">        {</span><br><span class="line">            endpos = din-&gt;size;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*sfs_buf_op)(<span class="keyword">struct</span> sfs_fs * sfs, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">uint32_t</span> blkno, <span class="type">off_t</span> offset);</span><br><span class="line">    <span class="type">int</span> (*sfs_block_op)(<span class="keyword">struct</span> sfs_fs * sfs, <span class="type">void</span> *buf, <span class="type">uint32_t</span> blkno, <span class="type">uint32_t</span> nblks);</span><br><span class="line">    <span class="keyword">if</span> (write)</span><br><span class="line">    {</span><br><span class="line">        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> size, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> ino;</span><br><span class="line">    <span class="type">uint32_t</span> blkno = offset / SFS_BLKSIZE;         <span class="comment">// The NO. of Rd/Wr begin block</span></span><br><span class="line">    <span class="type">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno; <span class="comment">// The size of Rd/Wr blocks</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB8:EXERCISE1 YOUR CODE HINT: call sfs_bmap_load_nolock, sfs_rbuf, sfs_rblock,etc. read different kind of blocks in file</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * (1) If offset isn't aligned with the first block, Rd/Wr some content from offset to the end of the first block</span></span><br><span class="line"><span class="comment">     *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">     *               Rd/Wr size = (nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset)</span></span><br><span class="line"><span class="comment">     * (2) Rd/Wr aligned blocks</span></span><br><span class="line"><span class="comment">     *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_block_op</span></span><br><span class="line"><span class="comment">     * (3) If end position isn't aligned with the last block, Rd/Wr some content from begin to the (endpos % SFS_BLKSIZE) of the last block</span></span><br><span class="line"><span class="comment">     *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 对齐偏移。如果偏移没有对齐第一个基础块，则多读取/写入第一个基础块的末尾数据</span></span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="comment">// 获取第一个基础块所对应的block的编号ino</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过上一步取出的ino，读取/写入一部分第一个基础块的末尾数据</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        alen += size;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        buf += size, blkno++, nblks--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取/写入对齐好的数据</span></span><br><span class="line">    size = SFS_BLKSIZE;</span><br><span class="line">    <span class="keyword">while</span> (nblks != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 获取inode对应的基础块编号</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 单次读取/写入一基础块的数据</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        alen += size, buf += size, blkno++, nblks--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果末尾位置没有与最后一个基础块对齐，则多读取/写入一点末尾基础块的数据</span></span><br><span class="line">    <span class="keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        alen += size;</span><br><span class="line">    }</span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="x02-基于文件系统的执行程序机制的实现">0X02 基于文件系统的执行程序机制的实现</h3>
<p>我们先回忆一下之前是怎么加载程序的：</p>
<ul>
<li>首先把用户程序随内核编译，放在img的最后</li>
<li>内核启动后，会把用户程序加载到内存中</li>
<li>内核线程调用execve函数来加载<strong>位于内存中的用户线程</strong>，切换上下文然后执行。</li>
</ul>
<p>之前没有文件系统，故不能从磁盘上加载程序；而有了文件系统以后，可以使用文件系统来把程序加载到内存里，然后像之前一样执行即可。</p>
<p>但是由于多了文件系统，proc结构体啥的都发生了变化，我们需要做一些修正：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct * <span class="title function_">alloc_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Lab7内容</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// LAB8:EXERCISE2 YOUR CODE HINT:need add some code to init fs in proc_struct, ...</span></span><br><span class="line">        <span class="comment">//  LAB8 添加一个filesp指针的初始化</span></span><br><span class="line">        proc-&gt;filesp = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多了file_struct结构的复制操作与执行失败时的重置操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_fork</span><span class="params">(<span class="type">uint32_t</span> clone_flags, <span class="type">uintptr_t</span> <span class="built_in">stack</span>, <span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    }</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    }</span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    assert(current-&gt;wait_state == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// LAB8:EXERCISE2 YOUR CODE  HINT:how to copy the fs in parent's proc_struct?</span></span><br><span class="line">    <span class="comment">//  LAB8 将当前进程的fs复制到fork出的进程中</span></span><br><span class="line">    <span class="keyword">if</span> (copy_files(clone_flags, proc) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">    }</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    {</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        set_links(proc);</span><br><span class="line">    }</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line"></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">// LAB8 如果复制失败，则需要重置原先的操作</span></span><br><span class="line">bad_fork_cleanup_fs: <span class="comment">// for LAB8</span></span><br><span class="line">    put_files(proc);</span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们来正式实现execve和相关函数。通过前面lab我们知道load_icode函数完成了整个execve过程复杂的工作，所以我们在此也要继续修正该函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// load_icode -  called by sys_exec--&gt;do_execve</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> argc, <span class="type">char</span> **kargv)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* LAB8:EXERCISE2 YOUR CODE  HINT:how to load the file with handler fd  in to process's memory? how to setup argc/argv?</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *  mm_create        - create a mm</span></span><br><span class="line"><span class="comment">     *  setup_pgdir      - setup pgdir in mm</span></span><br><span class="line"><span class="comment">     *  load_icode_read  - read raw data content of program file</span></span><br><span class="line"><span class="comment">     *  mm_map           - build new vma</span></span><br><span class="line"><span class="comment">     *  pgdir_alloc_page - allocate new memory for  TEXT/DATA/BSS/stack parts</span></span><br><span class="line"><span class="comment">     *  lcr3             - update Page Directory Addr Register -- CR3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* (1) create a new mm for current process</span></span><br><span class="line"><span class="comment">     * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line"><span class="comment">     * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span></span><br><span class="line"><span class="comment">     *    (3.1) read raw data content in file and resolve elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.3) call mm_map to build vma related to TEXT/DATA</span></span><br><span class="line"><span class="comment">     *    (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span></span><br><span class="line"><span class="comment">     *          and copy them into the new allocated pages</span></span><br><span class="line"><span class="comment">     *    (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span></span><br><span class="line"><span class="comment">     * (4) call mm_map to setup user stack, and put parameters into user stack</span></span><br><span class="line"><span class="comment">     * (5) setup current process's mm, cr3, reset pgidr (using lcr3 MARCO)</span></span><br><span class="line"><span class="comment">     * (6) setup uargc and uargv in user stacks</span></span><br><span class="line"><span class="comment">     * (7) setup trapframe for user environment</span></span><br><span class="line"><span class="comment">     * (8) if up steps failed, you should cleanup the env.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    assert(argc &gt;= <span class="number">0</span> &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        panic(<span class="string">"load_icode: current-&gt;mm must be empty.\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">// 创建proc的内存管理结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">// LAB8 这里要从文件中读取ELF header，而不是Lab7中的内存了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> __<span class="title">elf</span>, *<span class="title">elf</span> =</span> &amp;__elf;</span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elfhdr), <span class="number">0</span>)) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断读取入的elf header是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">    {</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 根据每一段的大小和基地址来分配不同的内存空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> __<span class="title">ph</span>, *<span class="title">ph</span> =</span> &amp;__ph;</span><br><span class="line">    <span class="type">uint32_t</span> vm_flags, perm, phnum;</span><br><span class="line">    <span class="keyword">for</span> (phnum = <span class="number">0</span>; phnum &lt; elf-&gt;e_phnum; phnum++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// LAB8 从文件特定偏移处读取每个段的详细信息（包括大小、基地址等等）</span></span><br><span class="line">        <span class="type">off_t</span> phoff = elf-&gt;e_phoff + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> proghdr) * phnum;</span><br><span class="line">        <span class="keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> proghdr), phoff)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz)</span><br><span class="line">        {</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X)</span><br><span class="line">            vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W)</span><br><span class="line">            vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R)</span><br><span class="line">            vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE)</span><br><span class="line">            perm |= PTE_W;</span><br><span class="line">        <span class="comment">// 为当前段分配内存空间</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">off_t</span> offset = ph-&gt;p_offset;</span><br><span class="line">        <span class="type">size_t</span> off, size;</span><br><span class="line">        <span class="type">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 设置该内存所对应的页表项</span></span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            }</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la)</span><br><span class="line">            {</span><br><span class="line">                size -= la - end;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// LAB8 读取elf对应段内的数据并写入至该内存中</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            }</span><br><span class="line">            start += size, offset += size;</span><br><span class="line">        }</span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="comment">// 对于段中当前页中剩余的空间（复制elf数据后剩下的空间），将其置为0</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; la)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span></span><br><span class="line">            <span class="keyword">if</span> (start == end)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la)</span><br><span class="line">            {</span><br><span class="line">                size -= la - end;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 对于段中剩余页中的空间（复制elf数据后的多余页面），将其置为0</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            }</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la)</span><br><span class="line">            {</span><br><span class="line">                size -= la - end;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 关闭读取的ELF</span></span><br><span class="line">    sysfile_close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置栈内存</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    }</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP - PGSIZE, PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP - <span class="number">2</span> * PGSIZE, PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP - <span class="number">3</span> * PGSIZE, PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP - <span class="number">4</span> * PGSIZE, PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    <span class="comment">// 设置CR3页表相关寄存器</span></span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup argc, argv</span></span><br><span class="line">    <span class="comment">//  LAB8 设置execve所启动的程序参数</span></span><br><span class="line">    <span class="type">uint32_t</span> argv_size = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    {</span><br><span class="line">        argv_size += strnlen(kargv[i], EXEC_MAX_ARG_LEN + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">uintptr_t</span> stacktop = USTACKTOP - (argv_size / <span class="keyword">sizeof</span>(<span class="type">long</span>) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">    <span class="comment">// 直接将传入的参数压入至新栈的底部</span></span><br><span class="line">    <span class="type">char</span> **uargv = (<span class="type">char</span> **)(stacktop - argc * <span class="keyword">sizeof</span>(<span class="type">char</span> *));</span><br><span class="line"></span><br><span class="line">    argv_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    {</span><br><span class="line">        uargv[i] = <span class="built_in">strcpy</span>((<span class="type">char</span> *)(stacktop + argv_size), kargv[i]);</span><br><span class="line">        argv_size += strnlen(kargv[i], EXEC_MAX_ARG_LEN + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stacktop = (<span class="type">uintptr_t</span>)uargv - <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    *(<span class="type">int</span> *)stacktop = argc;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="x03-总结">0X03 总结</h3>
<p>说实话，文件系统本身就很复杂，这里还掺杂了虚拟文件系统的概念，难度挺大，主要就是认识一下。我自己是基于现有的驱动(其实是伪驱动，不基于ucore)，额外实现了一个不带虚拟文件系统的简易文件系统，这样的话理解似乎会更深一点。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ucore%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># ucore操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/01/24/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-7/" rel="prev" title="从ucore来总结操作系统(7)----互斥、同步和信号量">
      <i class="fa fa-chevron-left"></i> 从ucore来总结操作系统(7)----互斥、同步和信号量
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-9/" rel="next" title="从ucore来总结操作系统(9)----仿照ucore来实现一个自己的操作系统">
      从ucore来总结操作系统(9)----仿照ucore来实现一个自己的操作系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#x00-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="nav-number">1.1.</span> <span class="nav-text">0X00 环境准备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.1.</span> <span class="nav-text">总体介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.</span> <span class="nav-text">层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">通用文件系统访问接口层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%BD%E8%B1%A1%E5%B1%82"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">文件系统抽象层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#simple-fs-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">Simple FS 文件系统层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%96%E8%AE%BE%E6%8E%A5%E5%8F%A3%E5%B1%82io%E8%AE%BE%E5%A4%87"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">外设接口层(I&#x2F;O设备)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">文件系统挂载流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x01-%E5%AE%8C%E6%88%90%E8%AF%BB%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.</span> <span class="nav-text">0X01 完成读文件操作的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x02-%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.</span> <span class="nav-text">0X02 基于文件系统的执行程序机制的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x03-%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.</span> <span class="nav-text">0X03 总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Staskaer"
      src="/imgs/theme_pic/head_img.png">
  <p class="site-author-name" itemprop="name">Staskaer</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Staskaer" title="Github → https:&#x2F;&#x2F;github.com&#x2F;Staskaer" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:liujiaxin011121@gmail.com" title="E-Mail → mailto:liujiaxin011121@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/staskaer" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;staskaer" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Staskaer</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'xH8NDrh9u4SQrUpQOd0lICnX-MdYXbMMI',
      appKey     : 'jl3JjPS4jsosZG29Zv24Y7LE',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-Hans' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://xh8ndrh9.api.lncldglobal.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>

