<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CPU级的性能优化</title>
    <url>/2023/03/18/CPU%E7%BA%A7%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><strong>基本块布局、热点代码对齐，内存预取，循环优化</strong></p>
<span id="more"></span>
<p>之前给阳关电源做项目的时候，他们提出要对代码进行优化，所以学习了一些优化方法，现在正好来记录一下。<del>虽然最后并没用到多少下述方法...</del></p>
<h1 id="性能分析工具">性能分析工具</h1>
<h2 id="cc代码分析">C/C++代码分析</h2>
<p>因为这部分代码需要部署在服务器上，所以正好有perf工具可以使用。顺便top也是不错的工具，用来大致看一下load还是不错的。</p>
<p>perf工具我也只是掌握了基本的功能，深入的功能还有待后续学习，此处就不展开了。</p>
<p><a href="https://cloud-atlas.readthedocs.io/zh_CN/latest/kernel/perf/perf_startup.html">perf文档</a></p>
<p>比较常用的几个命令：</p>
<ul>
<li><code>perf top</code>：实时显示系统/进程的性能统计信息</li>
<li><code>perf stat</code>：分析系统/进程的整体性能概况</li>
<li><code>perf record</code>：记录一段时间内系统/进程的性能时间</li>
<li><code>perf report</code>：读取<code>perf record</code>生成的数据文件，并显示分析数据</li>
</ul>
<img src="/2023/03/18/CPU%E7%BA%A7%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic1.png" class="">
<h2 id="python代码分析">python代码分析</h2>
<h3 id="memory_profiler">memory_profiler</h3>
<p><a href="https://github.com/pythonprofilers/memory_profiler">memory_profiler文档</a></p>
<p>这个工具可以用于分析代码的内存开销，使用方法也很简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>把装饰器挂在待分析的函数上，直接执行就可以了。</p>
<p>每一行代码执行前后的开销都会被记录下来</p>
<img src="/2023/03/18/CPU%E7%BA%A7%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic2.png" class="">
<h3 id="viztracer">viztracer</h3>
<p>这个工具可以用于记录函数的调用栈和时间，不过目前发现它对<code>numpy</code>这类库支持效果不是很好，有些调用过程无法记录到。</p>
<p><em>看了一下issue，是因为numpy的函数都被优化成了纯C函数，而不是PYCFunction，所以没法触发hook导致无法被记录。不过这种基本运算也不是很需要被追踪...</em></p>
<p><a href="https://github.com/gaogaotiantian/viztracer">viztracer文档</a></p>
<p><del>viztracer的作者就是前一段时间锤wjk假唱的那位大佬(清华毕业，加州微软工作，年收入七位数，实在是太牛了)</del></p>
<p>还有一个小小的问题，如果windows下用户名是中文的话，需要修改Temp目录才行。</p>
<p><del>这个工具当时画出来的图我看的不是很明白，所以没敢往PPT上放</del></p>
<img src="/2023/03/18/CPU%E7%BA%A7%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic3.png" class="">
<h1 id="代码布局优化">代码布局优化</h1>
<p>代码中经常被执行到的区域定义为<strong>热路径</strong>，剩余的区域定义为<strong>冷路径</strong>。</p>
<p>由于<strong>指令本身也参与缓存</strong>，所以热路径的代码执行效率会比冷路径高很多。</p>
<p>另外，由于缓存(页表)的限制，热路径占用的空间也大，则页表项也多，被置换出去的概率就越大。</p>
<p>因此，代码布局优化的目的就是<strong>将热路径的代码放在一起，并让其尽可能小</strong>，这样可以<strong>提升缓存利用率</strong>，提高代码的执行效率。</p>
<h2 id="基本块布局">基本块布局</h2>
<p>考虑以下代码布局</p>
<img src="/2023/03/18/CPU%E7%BA%A7%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic4.png" class="">
<p>由于两个热路径之间插入了冷路径，其表现为<strong>热路径和冷路径代码位于相同的页表缓存项中</strong>，增大了缓存空间，不利于缓存。</p>
<p>这种代码布局常见于错误处理，如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 热代码</span></span><br><span class="line">fp = fopen(<span class="string">"hello.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="comment">// 打开文件失败比较少见，冷代码</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    <span class="comment">// 做了一些工作</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 正常处理，热代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果不做优化，那么产生的汇编的布局应该是这样的</p>
<img src="/2023/03/18/CPU%E7%BA%A7%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic5.png" class="">
<p>可以使用__builtin_expect函数来优化这种代码布局</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 热代码</span></span><br><span class="line">fp = fopen(<span class="string">"hello.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处表示该if项的条件为假的概率更大</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect(fp == <span class="literal">NULL</span>, <span class="number">0</span>)) </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    <span class="comment">// 做了一些工作</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 正常处理，热代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>__builtin_expect(cond, value)</code>即表示<code>cond</code>的值为<code>value</code>的概率更大。<br>
这样会有利于编译器生成更好的布局，如</p>
<img src="/2023/03/18/CPU%E7%BA%A7%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic6.png" class="">
<p>可以定义成宏使用，更加方便</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 热代码</span></span><br><span class="line">fp = fopen(<span class="string">"hello.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处表示该if项的条件为假的概率更大</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(fp == <span class="literal">NULL</span>)) </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    <span class="comment">// 做了一些工作</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 正常处理，热代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以用于<code>switch</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (__builtin_expect(x, <span class="number">3</span>))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 冷代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 冷代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="comment">// 热代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 冷代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>利用该注解，编译器可以微调代码，从而提高性能。</p>
<h2 id="冷代码拆分">冷代码拆分</h2>
<p>冷代码拆分和基本块布局类似，都是为了减少冷路径代码占用的缓存空间。</p>
<p>上述代码布局中，是将冷代码移到热代码后面，这样可以减少冷路径代码占用的缓存空间。<strong>但是如果有些时候，热路径贯穿始终，而冷路径基本都是些错误处理函数，这样移动到最后就有些不合适了(因为某个热路径可能需要保证错误被正确处理)</strong></p>
<img src="/2023/03/18/CPU%E7%BA%A7%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic7.png" class="">
<p>由于冷代码可能会被内联，这时候缓存页就会变大导致效率低下。</p>
<p>为了提升利用率，<strong>需要静止内联冷代码</strong>，这时候可以使用<code>noinline</code>属性来告知编译器不要内联该冷函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cold1</span><span class="params">()</span> __<span class="title function_">attribute__</span><span class="params">((noinline))</span> </span><br><span class="line">{ </span><br><span class="line">    <span class="comment">// 冷代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 热代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冷代码区域，避免内联且优化布局</span></span><br><span class="line"><span class="keyword">if</span>( __builtin_expect(cond, <span class="number">0</span>) )</span><br><span class="line">    cold1()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 热代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个时候，<code>cold1</code>函数将被置于<code>.text</code>段以外，而原<code>.text</code>段将被一条<code>call</code>指令替代，这样就保证了缓存利用率。</p>
<img src="/2023/03/18/CPU%E7%BA%A7%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic8.png" class="">
<h1 id="数据优化">数据优化</h1>
<p>数据优化一方面是要写出<strong>数据友好型的程序</strong>，另一方面也要保证<strong>CPU流水线尽可能少停摆</strong>。</p>
<p>数据友好型程序还是针对缓存而言的，主要就是对齐和预取。</p>
<p>CPU流水线不停摆就相对比较麻烦，这与CPU内部执行单元的数目和流水线深度高度依赖。这点在CSAPP中有比较详细的描述。</p>
<h2 id="内存对齐">内存对齐</h2>
<p>内存对齐这是一个老生常谈的问题，主要就是针对结构体，整倍数内存访问会更快，也更利于缓存(缓存都是内存对齐的，如果数据不对齐，会出现需要访问两次缓存的情况)</p>
<p>可以使用<code>alignas()</code>来指定对齐，一般的规则是：</p>
<ul>
<li>N B的数据对齐于能被N整除的地址 if N &lt;= 8</li>
<li>对齐于能被16整除的地址 else</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">alignas</span>(<span class="number">16</span>) <span class="type">int16_t</span> a[<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) S</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 数据</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="内存预取至缓存">内存预取至缓存</h2>
<p>缓存预取是为了解决循环处理数据时的缓存性能下降</p>
<p>类似这种情况</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">{</span><br><span class="line">    x[i] = dosth();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cond 为 1 的可能性为50%左右</span></span><br><span class="line">    <span class="keyword">if</span>( cond )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// i 和 j之间相差很大</span></span><br><span class="line">        j = index();</span><br><span class="line">        x[j] = dosth();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述情况中，由于<code>i</code>和<code>j</code>相差很大，缓存很可能不会预先保存<code>x[j]</code>的缓存项，但是<code>cond</code>发生概率又很大，就会导致性能下降。</p>
<p>这个时候，<strong>需要对<code>x[j]</code>进行预取，提前将其缓存</strong>。可以使用<code>__builtin_prefetch</code>来完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">{</span><br><span class="line">    x[i] = dosth();</span><br><span class="line">    </span><br><span class="line">    __builtin_prefetch(x+j, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// cond 为 1 的可能性为50%左右</span></span><br><span class="line">    <span class="keyword">if</span>( cond )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// i 和 j之间相差很大</span></span><br><span class="line">        j = index();</span><br><span class="line">        x[j] = dosth();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该内置函数原型为<code>void __builtin_prefetch (const void *addr, ...)</code>。还有两个可选参数:</p>
<ul>
<li><code>rw</code> ： 是个编译时的常数，或 1 或 0 。1 时表示写(w)，0
时表示读(r)</li>
<li><code>locality</code> :
必须是编译时的常数，也称为“时间局部性”(temporal locality)
。<em>时间局部性是指，如果程序中某一条指令一旦执行，则不久之后该指令可能再被执行；如果某数据被访问，则不久之后该数据会被再次访问。该值的范围在
0 - 3 之间。为 0
时表示，它没有时间局部性，也就是说，要访问的数据或地址被访问之后的不长的时间里不会再被访问；为
3 时表示，被访问的数据或地址具有高
时间局部性，也就是说，在被访问不久之后非常有可能再次访问；对于值 1 和
2，则分别表示具有低 时间局部性 和中等 时间局部性。该值默认为 3
。</em></li>
</ul>
<p><strong>这个预取指令不要提前插入以免污染缓存，也不要插入的太迟，导致没有生效。而且对于不同缓存大小的机器优化程度也不一样(甚至负优化)。</strong></p>
<h2 id="循环优化">循环优化</h2>
<p>循环优化非常多，也非常常见。</p>
<p>好的循环需要让缓存最大利用且流水线不停摆，有很多优化方法。</p>
<p><strong>大部分循环优化都会被编译器自动完成，感觉除非万不得已，不需要手动优化循环。</strong></p>
<h3 id="常值外提">常值外提</h3>
<p>很简单，下面给出示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">        a[i] = b[i] * c[j];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>劣于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    temp = c[j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">        a[i] = b[i] * temp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，这些其实不需要手动来优化，编译器优化等级开高会自动完成。</p>
<img src="/2023/03/18/CPU%E7%BA%A7%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/pic9.png" class="">
<h3 id="循环展开">循环展开</h3>
<p>循环展开也是经常提到的，它有利于流水线，但是编译器非常擅长循环展开，所以不需要手动展开(除非刷题时不给开优化，不过一般都是给开的吧)</p>
<p>而且处理器都是乱序执行+分支预测，肯定比盲目手动展开效果好。</p>
<p>如果想要手动控制编译器循环展开，可以使用<code>#pragma unroll(4)</code>这种指令来命令编译器进行展开。</p>
<h3 id="减弱循环内开销">减弱循环内开销</h3>
<p>可以在循环中利用更多开销小的指令来取缔一个开销大的指令。</p>
<p>比如CPU有4个加法运算单元，但是只有1个乘法运算单元，这个时候就要减少循环中的乘法运算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    a[i] = b[i*<span class="number">10</span>] * c[i];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更改为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">{</span><br><span class="line">    a[i] = b[j] * c[i];</span><br><span class="line">    j += <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际测试中，编译器会自动执行优化。</p>
<p>但是如果是函数操作的话，那么手动优化还是必要的。</p>
<h3 id="循环判断分离">循环判断分离</h3>
<p>如果循环内的分支判断是固定的，可以移动到循环外。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">{</span><br><span class="line">    a[i] += b[i];</span><br><span class="line">    <span class="keyword">if</span> ( cond_const )</span><br><span class="line">        b[i] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以优化成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cond_const)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    {</span><br><span class="line">        a[i] += b[i];</span><br><span class="line">        b[i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    {</span><br><span class="line">        a[i] += b[i];</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样，虽然代码翻倍，但是每个循环都可以被单独优化。</p>
<p>实际测试，编译器还是会自动优化。但是如果条件复杂，处理的内容较多时，优化能力下降。</p>
<h3 id="循环分块">循环分块</h3>
<p>就是矩阵运算的那个缓存友好型方法，比较繁琐，实际中也不好写。而且实测，编译器会自动优化，不谈了。</p>
<h3 id="向量化指令">向量化指令</h3>
<p>在优化的时候，我也尝试了一些SIMD指令。但是效果不好，感觉都是无优化或者负优化，这部分还是依赖编译器的自动向量化吧。</p>
<h1 id="总结">总结</h1>
<p>不得不说，编译器还是太牛了，我做代码优化的时候，上面提到的这些优化很少有实际有用的，最后还是对算法架构动刀，重构了关键代码才勉强有了提升。</p>
<p>在我单独测试的时候，很多循环的优化和缓存上的优化都被自动完成了，根本不需要手动来完成。</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>CPU级性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA高性能并行计算(1)--CUDA初步探究</title>
    <url>/2022/09/04/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-1/</url>
    <content><![CDATA[<h2 id="cuda初步探究">CUDA初步探究</h2>
<span id="more"></span>
<h3 id="什么是cuda">什么是CUDA</h3>
<p>CUDA，即Compute Unified Device
Architecture的简称，是由NVIDIA公司创立的基于他们公司生产的图形处理器GPUs的一个并行计算平台和编程模型。</p>
<p>通过CUDA，GPUs可以很方便地被用来进行通用计算（有点像在CPU中进行的数值计算等等）。在没有CUDA之前，GPUs一般只用来进行图形渲染（如通过OpenGL，DirectX）。<br>
开发人员可以通过调用CUDA的API，来进行并行编程，达到高性能计算目的。NVIDIA公司为了吸引更多的开发人员，对CUDA进行了编程语言扩展，如CUDA
C/C++,CUDA Fortran语言。注意CUDA
C/C++可以看作一个新的编程语言，因为NVIDIA配置了相应的编译器nvcc,CUDA
Fortran一样。更多信息可以参考文献。</p>
<div class="note primary">
            <p>本系列的博客跳过了CUDA环境的安装，如果有需要，请自行查阅相关教程，这方面资料还是很多的。</p><p>另外，本博客的环境是基于CUDA10.2，VS2017，windows10下的。</p>
          </div>
<h3 id="运行cuda的样例">运行CUDA的样例</h3>
<p>首先先找到CUDA的安装目录（本机是<code>C:\Program Files\NVIDIA GPU Computing Toolkit</code>），然后进入<code>extras/demo_suite</code>目录，就能看到已经编译好的样例程序。</p>
<p>我们运行<code>nbody.exe</code>，这是一个模拟上千个受到万有引力的粒子运动并进行可视化的程序。可以在控制台中进行调整参数，这个程序还有很炫酷的。</p>

<p>除了<code>nbody.exe</code>，这个目录下还有其他的一些例程可以运行，同样的，还有一些未被编译的例程，可以手动去编译。</p>
<h3 id="编写一个串行程序">编写一个串行程序</h3>
<p>我们首先使用传统方式来写一个计算一个点到一条直线上若干点的距离的程序。</p>
<p>这个简单的cpp程序使用了一个for循环，先对循环变量进行归一化处理，然后计算并存储与参考位置的距离。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">scale</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">float</span>)i / (n - <span class="number">1</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">distance</span><span class="params">(<span class="type">float</span> x1, <span class="type">float</span> x2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x2 - x1)*(x2 - x1));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">float</span> out[N] = { <span class="number">0.0f</span> };</span><br><span class="line">	<span class="type">float</span> ref = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">float</span> x = <span class="built_in">scale</span>(i, N);</span><br><span class="line">		out[i] = <span class="built_in">distance</span>(x, ref);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; i : out)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%f "</span>, i);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来我们使用另外一种方式来编写这个程序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">scale</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">float</span>)i / (n - <span class="number">1</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">distance</span><span class="params">(<span class="type">float</span> x1, <span class="type">float</span> x2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x2 - x1)*(x2 - x1));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">distanceArray</span><span class="params">(<span class="type">float</span> * out, <span class="type">float</span> * in, <span class="type">float</span> ref, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	{</span><br><span class="line">		out[i] = <span class="built_in">distance</span>(i, n);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">float</span> * in = (<span class="type">float</span> *)<span class="built_in">calloc</span>(N, <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">	<span class="type">float</span> * out = (<span class="type">float</span> *)<span class="built_in">calloc</span>(N, <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> ref = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	{</span><br><span class="line">		in[i] = <span class="built_in">scale</span>(i, N);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">distanceArray</span>(out, in, ref, N);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%f "</span>, out[i]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(in);</span><br><span class="line">	<span class="built_in">free</span>(out);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们来重新审视一下这两个程序，这两个程序都是使用串行的方式处理的，即每次处理一个数值，只是两个的写法不一样。</p>
<ul>
<li><p>第一个程序是在mian函数中手动处理每个点</p></li>
<li><p>而第二个程序则是提供了一个统一的抽象接口，mian函数只需要一次调用这个函数就能计算出所有的值</p></li>
</ul>
<p>表面上看这两个程序没有本质的区别，但是其标志性的指出了并行程序的编写思路：<strong><em>提供数据并调用接口，一次性获得所有的结果</em></strong></p>
]]></content>
      <categories>
        <category>CUDA并行程序设计</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA高性能并行计算(10)--线程束基本函数与协作组</title>
    <url>/2022/09/12/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-10/</url>
    <content><![CDATA[<h2 id="cuda线程束基本函数与协作组">CUDA线程束基本函数与协作组</h2>
<span id="more"></span>
<p>由于GPU的每次调度计算的最小单元就是一个拥有32个线程的线程束，所以我们首先再来回顾一下线程束和GPU的处理模式。</p>
<h3 id="单指令多线程的执行模式">单指令多线程的执行模式</h3>
<p>一个GPU在硬件上是由多个SM组成的，核函数中定义的线程块在执行时会被调度到一个资源还没有被完全占满的SM上。一个线程块只会被一个SM调度，但是一个SM上可以拥有很多线程块。</p>
<p>不同的线程块之间可以并发或顺序的执行，但是<strong>线程块之间一般不能同步</strong>，当某个线程块完成计算后，SM会进入部分或完全空闲状态并调度下一个线程块。</p>
<p>一个SM以线程束作为最小单元进行调度，一个线程束为32个线程。</p>
<h4 id="线程块分支发散">线程块分支发散</h4>
<p>在伏特架构之前，每个线程束只有一个程序计数器，导致所有的线程必须执行相同的指令。如果一个线程束内的线程顺序地执行分支语句中的不同分支时，就会导致分支发散。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(condition)</span><br><span class="line">{</span><br><span class="line">    A;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    B;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例如上述代码，在一个线程束内，首先满足condition的线程会执行A，其他线程闲置，然后不满足condition的线程再去执行B，其他线程闲置。因此，如果A,B的运算量相差不多，就会导致性能下降到原来的一半。而如果存在很多分支(switch-case)时，就会导致分支发散的很严重，性能严重下降。</p>
<p><strong>而在伏特架构开始</strong>，引入了线程独立调度，每个线程都有自己的程序计数器。因此分支发散的问题没有那么严重了，但是又引入了<strong>新的问题</strong>：</p>
<p>首先是由于CUDA核非常多，所以程序计数器也得非常多，导致空间浪费。另外，由于每个线程有自己的程序计数器，所以线程束也不再是完全同步执行的了。要引入线程束内同步，可以通过<code>__syncwarp()</code>来完成。</p>
<h3 id="线程块的基本函数">线程块的基本函数</h3>
<h4 id="线程束内线程同步函数">线程束内线程同步函数</h4>
<p>当需要同步的所有线程都位于一个线程块时，可以使用更加廉价的<code>__syncwarp(unsigned mask = 0xffffffff)</code>去代替线程块同步，其内部的掩模表示需要参与同步的线程块内的线程id。</p>
<p>但使用的时候需要十分注意，要保证范围内的线程同属一个线程块。</p>
<h4 id="线程束表决函数">线程束表决函数</h4>
<p>表决函数名字感觉有些奇怪，其函数族大致形如<code>__xxx_sync(mask, predicate)</code>，效果是线程块内所有线程求predicate的值，并根据所有线程块的计算结果来返回值。</p>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 69%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">unsigned __ballot_sync(unsigned mask,
int predicate)</td>
<td style="text-align: center;">mask掩模为1的线程参与计算。返回值也是一个掩模，其中位1的位表示对应的线程计算结果非0。<strong>相当于从旧的掩模中产生新的掩模</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">int __all_sync(unsigned mask, int
predicate)</td>
<td style="text-align: center;">make掩模为1的线程参与计算。只有所有参与计算的线程的计算结果均为非0，返回值为1，否则为0.<strong>所有人都同意才执行</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">int __any_sync(unsigned mask, int
predicate)</td>
<td style="text-align: center;">make掩模为1的线程参与计算。只要参与计算的线程中有一个计算结果非0，那么就返回1，否则返回0.<strong>只要有一个人同意就执行</strong></td>
</tr>
</tbody>
</table>
<p>这些函数结尾都带有<code>_sync</code>，因此其都具有隐式同步功能。</p>
<p>下面给出一个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"device_functions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TARGET 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FULL_MASK 0Xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">test_warp_primitives</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">	<span class="type">int</span> lane_id = tid % WIDTH;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出线程号</span></span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"threadIdx.x: "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%2d "</span>, tid);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n "</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出定义的线程束内线程号</span></span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"lane id: "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%2d "</span>, lane_id);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n "</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用表决函数计算mask并打印</span></span><br><span class="line">	<span class="type">unsigned</span> mask1 = __ballot_sync(FULL_MASK, tid &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="type">unsigned</span> mask2 = __ballot_sync(FULL_MASK, tid == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"fullmask = %x\n"</span>, FULL_MASK);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"mask1 = %x\n"</span>, mask1);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"mask2 = %x\n"</span>, mask2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面也是表决函数的使用</span></span><br><span class="line">	<span class="type">int</span> result = __all_sync(FULL_MASK, tid);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"all_sync(fullmask) = %d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">	result = __any_sync(mask1, tid);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"any_sync(mask1) = %d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">	result = __any_sync(FULL_MASK, tid);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"any_sync(fullmask) = %d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">	result = __any_sync(mask2, tid);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"any_sync(mask2) = %d\n"</span>, result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	test_warp_primitives &lt;&lt; &lt;<span class="number">1</span>, BLOCK_SIZE &gt;&gt; &gt; ();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子介绍了表决函数的使用，非常简单，不再赘述。</p>
<h4 id="线程束洗牌函数">线程束洗牌函数</h4>
<p>下面介绍洗牌函数的功能</p>
<table>
<colgroup>
<col style="width: 36%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">T __shfl_sync(unsigned mask,T v,int
srcLane,int w = warpSize)</td>
<td style="text-align: center;">参与线程返回标号为scrLane的线程中变量v的值。即广播数据交互，将一个线程的数据广播到线程束中所有的线程上(包括自身)。</td>
</tr>
<tr class="even">
<td style="text-align: center;">T __shfl_up_sync(unsigned mask,T
v,unsigned d,int w = warpSize)</td>
<td style="text-align: center;">标号为t的参与线程中会返回t-d的线程中变量的值。标号满足t-d&lt;0的线程返回原来v的值，也就是数据向标号高的线程传递</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T __shfl_down_sync(unsigned mask,T
v,unsigned d,int w = warpSize)</td>
<td style="text-align: center;">标号为t的参与线程中会返回t+d的线程中变量的值。标号满足t+d&gt;w的线程返回原来v的值，也就是数据向标号低的线程传递</td>
</tr>
<tr class="even">
<td style="text-align: center;">T __shfl_xor_sync(unsigned mask,T v,int
laneMask,int w = warpSize)</td>
<td style="text-align: center;">标号为t的参与线程返回标号为t^laneMask的线程中的变量为v的值</td>
</tr>
</tbody>
</table>
<p>洗牌函数可以用于将数据进行线程内传递，同样是同步的。<strong>注意其中的参数w表示作用的范围，比如其值取8的时候，表示把线程束再按照8个线程一组分成更小的'线程束'</strong></p>
<div class="note primary">
            <p>可能会觉得这几个函数令人费解，下面来具体讲述一下。</p><p>首先线程是从核函数创建的，所以每个线程内部的代码都是一样的(类似c语言的fork)，这也就是说，<strong>假如在核函数中写了一个洗牌函数，那么实际上所有的线程内都会有这个洗牌函数</strong>。假如在核函数内有这么一句</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">val = __shfl_up_sync(<span class="number">0xffffffff</span>, tid, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 其中tid = threadIdx.x</span></span><br></pre></td></tr></table></figure><p>由于所有线程都参与了，就不用考虑参与线程的问题。</p><p>下表给出了16个线程中val的值，其中tid_{i}表示这个值来自于线程i</p><table><thead><tr class="header"><th style="text-align: center;">线程编号</th><th style="text-align: center;">线程内val值</th><th style="text-align: center;"></th><th style="text-align: center;">线程编号</th><th style="text-align: center;">线程内val值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0,即tid_0，下同</td><td style="text-align: center;"></td><td style="text-align: center;">8</td><td style="text-align: center;">6,即tid_6，下同</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;">9</td><td style="text-align: center;">7</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">0</td><td style="text-align: center;"></td><td style="text-align: center;">10</td><td style="text-align: center;">8</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;">11</td><td style="text-align: center;">9</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;"></td><td style="text-align: center;">12</td><td style="text-align: center;">10</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">3</td><td style="text-align: center;"></td><td style="text-align: center;">13</td><td style="text-align: center;">11</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">4</td><td style="text-align: center;"></td><td style="text-align: center;">14</td><td style="text-align: center;">12</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;"></td><td style="text-align: center;">15</td><td style="text-align: center;">13</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">6</td><td style="text-align: center;"></td><td style="text-align: center;">16</td><td style="text-align: center;">14</td></tr></tbody></table>
          </div>
<p>同样给出一个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"device_functions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TARGET 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FULL_MASK 0Xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">test_warp_primitives</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">	<span class="type">int</span> lane_id = tid % WIDTH;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出线程号</span></span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"threadIdx.x: "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%2d "</span>, tid);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n "</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出定义的线程束内线程号</span></span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"lane id: "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%2d "</span>, lane_id);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n "</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把2号线程的值广播到0-7号中，把10号线程的值广播到8-15中</span></span><br><span class="line">	<span class="type">int</span> value = __shfl_sync(FULL_MASK, tid, <span class="number">2</span>, WIDTH);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"shfl : "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%2d "</span>, value);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在每个小的线程束内把值向上传递</span></span><br><span class="line">	value = __shfl_up_sync(FULL_MASK, tid, <span class="number">1</span>, WIDTH);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"shfl_up : "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%2d "</span>, value);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在每个小的线程束内把值向下传递</span></span><br><span class="line">	value = __shfl_down_sync(FULL_MASK, tid, <span class="number">1</span>, WIDTH);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"shfl_down : "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%2d "</span>, value);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类似上面，线程号异或后判断传递方向</span></span><br><span class="line">	value = __shfl_xor_sync(FULL_MASK, tid, <span class="number">1</span>, WIDTH);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"shfl_xor : "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%2d "</span>, value);</span><br><span class="line">	<span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	test_warp_primitives &lt;&lt; &lt;<span class="number">1</span>, BLOCK_SIZE &gt;&gt; &gt; ();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主要使用了洗牌函数并查看其在线程束内的工作情况。</p>
<h2 id="协作组">协作组</h2>
<p>在有些算法中，需要若干线程之间进行协作，而协作，就需要用到某种同步机制，否则乱序是没有办法进行很好的协作的。</p>
<p><strong>协作组</strong>可以看成是线程块与线程束的同步机制的推广，它提供了更加灵活的线程协作方式，包括<strong>线程块内部同步</strong>、<strong>线程块之间(计算网格)同步</strong>和<strong>设备与设备之间的同步</strong>。</p>
<p>使用协作组的相关函数时需要包含头文件<code>#include &lt;cooperative_groups.h&gt;</code>，且声明命名空间<code>using namespace cooperative_groups;</code></p>
<h4 id="线程块级别的协作组">线程块级别的协作组</h4>
<p>协作组编程中最基本的类型就是线程组thread_group类，我们把其头文件中源码放上来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_group</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> _CG_QUALIFIER thread_group <span class="title">this_thread</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> _CG_QUALIFIER thread_group <span class="title">tiled_partition</span><span class="params">(<span class="type">const</span> thread_group&amp; parent, <span class="type">unsigned</span> <span class="type">int</span> tilesz)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">thread_block</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">__align__</span>(<span class="number">8</span>) {</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> type : <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">struct</span> {</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> type : <span class="number">8</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> size : <span class="number">24</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> mask;</span><br><span class="line">        } coalesced;</span><br><span class="line">        <span class="keyword">struct</span> {</span><br><span class="line">            <span class="type">void</span>* ptr[<span class="number">2</span>];</span><br><span class="line">        } buffer;</span><br><span class="line">    } _data;</span><br><span class="line"></span><br><span class="line">    _CG_QUALIFIER thread_group <span class="keyword">operator</span>=(<span class="type">const</span> thread_group&amp; src);</span><br><span class="line">    <span class="function">_CG_QUALIFIER <span class="title">thread_group</span><span class="params">(__internal::groupType type)</span> </span>{</span><br><span class="line">        _data.type = type;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(_data) == <span class="number">16</span>, <span class="string">"Failed size check"</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 接口</span></span><br><span class="line">    <span class="function">_CG_QUALIFIER <span class="type">unsigned</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">_CG_QUALIFIER <span class="type">unsigned</span> <span class="type">int</span> <span class="title">thread_rank</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">_CG_QUALIFIER <span class="type">void</span> <span class="title">sync</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到其接口只有三个函数</p>
<ul>
<li>size() : 返回组的大小</li>
<li>sync() : 同步</li>
<li>thread_rank() : 返回当前调用该函数的线程在组内标号(从0开始)</li>
</ul>
<p>另外我们注意到其有一个友元类<code>thread_block</code>，这个类公有继承自thread_group，且提供了额外的公有接口，我们介绍两个</p>
<ul>
<li>dim3 group_index() : 等价于blockIdx</li>
<li>dim3 thread_index() : 等价于threadIdx</li>
</ul>
<p>我们可以使用如下方式定义一个thread_block对象<br>
<code>thread_block g = this_thread_block();</code><br>
其中this_thread_block()也是一个常量，这样定义的g就变成了我们熟悉的线程块。调用g.sync()等价于__syncthreads()函数。而g.group_index()和g.thread_index()也完全等于内建变量。</p>
<p>可以使用函数<code>tiled_partition()</code>来讲一个线程块进行分割</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 将线程块分成32一组的线程束</span></span><br><span class="line">thread_block g32 = <span class="built_in">tiled_partition</span>(<span class="built_in">this_thread_block</span>(), <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以分割成更细的线程束</span></span><br><span class="line">thread_block g4 = <span class="built_in">tiled_partition</span>(g32), <span class="number">4</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当线程组大小在编译时就能确定，可以使用<strong>静态结构</strong>进行定义，更高效。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">thread_block_tile&lt;<span class="number">32</span>&gt; g32 = <span class="built_in">tiled_partition</span>&lt;<span class="number">32</span>&gt;(<span class="built_in">this_thread_block</span>());</span><br><span class="line">thread_block_tile&lt;<span class="number">4</span>&gt; g4 = <span class="built_in">tiled_partition</span>&lt;<span class="number">4</span>&gt;(g32);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>线程组内也可以使用表决函数和洗牌函数等，但是其不能有掩模和宽度，也就是所有的线程必须参与进去。</p>
<h2 id="总结">总结</h2>
<ul>
<li>__syncwarp()可以用于线程束内同步，__syncthreads()则用于线程块同步。</li>
<li>表决函数可以用于线程束内线程计算表达式并返回计算结果，可以用于将一个掩模映射成另一个掩模。表决函数时同步的。</li>
<li>洗牌函数可以用于将数据进行线程内传递，同样是同步的。洗牌函数可以指定作用在更小的"线程束"上。</li>
<li>使用协作组的相关函数时需要包含头文件<code>#include &lt;cooperative_groups.h&gt;</code>，且声明命名空间<code>using namespace cooperative_groups;</code>。</li>
<li>协作组使用tiled_partition()进行分割，thread_block类用于确定线程块协作组。</li>
</ul>
]]></content>
      <categories>
        <category>CUDA并行程序设计</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA高性能并行计算(11)--CUDA流</title>
    <url>/2022/09/13/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-11/</url>
    <content><![CDATA[<h2 id="cuda流">CUDA流</h2>
<span id="more"></span>
<p>CUDA程序的并行层次主要有两个，一个是在核函数内部的并行，另一个是在核函数外部的并行。之前的线程块、计算网格之类的都是内部的并行，而外部的并行主要包括核函数计算与数据传输之间的并行、主机计算与数据传输之间的并行、不同数据传输(方向)之间的并行、核函数计算与主机计算之间的并行以及不同核函数之间并行。</p>
<p>不过核函数外部的并行并不是编程时考虑的重点内容。但是如果需要考虑核函数外的并行，就需要涉及到流的概念了。</p>
<h3 id="流概述">流概述</h3>
<p>一个CUDA流是指由主机发出的在一个设备中执行的CUDA操作序列。除了主机端发送的流外，设备端也可以发送流，不过此处我们只考虑前者。</p>
<p>一个流的哥哥操作的次序是由主机控制的，按照主机发布的次序执行，但是来自于两个不同的流的操作不一定按照某个次序执行，而是按照并发或交错地执行。</p>
<p>任何CUDA操作都存在于某个流中，要么是默认流，也称空流，要么是明确的非默认流。如果没有显式地指定一个流，那么所有的CUDA操作都是在空流中进行的。</p>
<p>非默认的流，需要在主机端产生与销毁。一个CUDA流可以由以下的CUDA运行时API产生:<code>cudaError_t cudaStreamCreate(cudaStream_t *)</code>，其输入参数是<code>cudaStream_t</code>类型的一个指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cudaStream_t stream_1;</span><br><span class="line"><span class="built_in">cudaStreamCreate</span>(&amp;stream_1); <span class="comment">// 创建,这个需要传递流地址</span></span><br><span class="line"><span class="built_in">cudaStreamDestroy</span>(stream_1); <span class="comment">// 销毁,这个不需要流地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了实现不同的CUDA流之间的并发，主机在向某个CUDA流中发布一系列命令后必须马上获得程序的控制权，不用等待CUDA流在GPU中执行完毕。这样就可以通过主机产生多个并行的CUDA流。</p>
<p>可以用以下函数检查一个CUDA流的所有操作是否在设备中执行完。</p>
<ul>
<li>cudaError_t cudaStreamSynchronize(cudaStream_t stream);
强制阻塞主机，直到所有CUDA流中的操作执行完毕。</li>
<li>cudaError_t cudaStreamQuery(cudaStream_t stream);
检查CUDA流中操作是否执行完毕，但不阻塞主机。</li>
</ul>
<h3 id="在默认流中重叠主机和设备计算">在默认流中重叠主机和设备计算</h3>
<p>同一个CUDA流中的所有CUDA操作都是顺序执行的，但是依然可以重叠默认流和主机之间的计算。</p>
<p>由于一个CUDA流内是顺序执行的，而我们前面也说过，主机执行完核函数后会立刻执行下一条指令，而不等待设备。因此如果主机执行完核函数后的下一条指令仍然是CUDA相关的(比如从设备中复制计算结果数据到主机)，就会导致这条指令被阻塞(因为设备会等待核函数结束后再执行这条复制相关的指令)。</p>
<p><strong>而如果主机在执行核函数后执行的指令与设备无关，那么就能实现主机和设备同时计算</strong>。这样就让设备和主机之间的计算重叠，这个技巧有时候会有用，前提是设备和主机执行的计算量差不多。</p>
<h3 id="用非默认的cuda流来重叠多个核函数的执行">用非默认的CUDA流来重叠多个核函数的执行</h3>
<p>要实现多个核函数之间并行必须需要使用多个流。</p>
<h4 id="核函数中流参数">核函数中流参数</h4>
<p>其实一个核函数在尖括号内可以传递4个参数，分别是网格尺寸，线程块尺寸，共享内存大小，流。因此要配置不同的流，就可以按照前述方法先创建出流，然后传递进核函数就可以了。<strong>其中共享内存大小可以为0</strong>。</p>
<p><code>xxx_kernel&lt;&lt;&lt;gridDim, blockDim, sharedMem, streamId&gt;&gt;&gt;(...)</code></p>
<h4 id="重叠多个核函数的例子">重叠多个核函数的例子</h4>
<p>下面给出一个简单的例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __global__ <span class="title">stream_kernel</span><span class="params">(<span class="type">int</span> streamid)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d thread in %d block in %d\n"</span>, threadIdx.x, blockIdx.x, streamid);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cudaStream_t streams[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : streams)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cudaStreamCreate</span>(&amp;x); <span class="comment">// 创建流</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i++)</span><br><span class="line">	{</span><br><span class="line">		stream_kernel &lt;&lt; &lt;<span class="number">2</span>, <span class="number">64</span>, <span class="number">0</span>, streams[i] &gt;&gt; &gt; (i); <span class="comment">// 调用核函数</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : streams)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cudaStreamDestroy</span>(x); <span class="comment">// 销毁流</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="不同流之间核函数的执行与数据传递">不同流之间核函数的执行与数据传递</h4>
<p>要实现核函数执行与数据传输的并发，必须让这两个操作处于不同的非默认流中，<strong>且数据传输必须使用<code>cudaMemcpy()</code>的异步版本<code>cudaMemcpyAsync()</code></strong>(这个由GPU中DMA来实现的)；另外，由于我们需要将数据传输实现成异步形式，因此<code>需要使用不可分页内存</code>而不能使用常规的可分页内存(也就是默认的分配内存，因为这些内存在传输时需要和主机进行同步，比如缺页，达不到异步的效果)，可以用<code>cudaMallocHost()</code>函数来实现，不可分页内存需要用<code>cudaFreeHost()</code>来进行释放，否则会出现错误。下面来具体介绍一下这些API。</p>
<ul>
<li>cudaError_t cudaMallocHost(void **ptr, size_t size) :
将*ptr指向的地址分配成不可分页地址。</li>
<li>cudaError_t cudaFreeHost(void *ptr) : 释放掉不可分页地址</li>
<li>cudaError_t cudaMemcpyAsync(void *dst, const void *src, size_t size,
enum cudaMemcpyKind kind, cudaStream_t stream) :
前面几个参数与cudaMemcpy()一致，最后一个参数是需要复制到的流中。</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>cudaStreamCreate()和cudaStreamDestroy()可以用于创建和销毁流。</li>
<li>cudaStreamSynchronize()强制阻塞主机，直到所有CUDA流中的操作执行完毕。cudaStreamQuery()，检查CUDA流中操作是否执行完毕，但不阻塞主机。</li>
<li>核函数调用中尖括号内第四个参数是流。</li>
<li>cudaMallocHost()和cudaFreeHost()可以用于分配和销毁不可分页内存。</li>
<li>cudaMemcpyAsync()可以在流内异步传输数据，且数据类型必须为不可分页内存。</li>
</ul>
]]></content>
      <categories>
        <category>CUDA并行程序设计</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA高性能并行计算(12)--CUDA标准库与生态</title>
    <url>/2022/09/14/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-12/</url>
    <content><![CDATA[<h2 id="cuda标准库与生态">CUDA标准库与生态</h2>
<span id="more"></span>
<h3 id="标准库">标准库</h3>
<p>CUDA提供了覆盖数学函数、线性代数、图像处理和机器学习以及其他重要领域的标准库供大家使用。这些库提供了大量高性能算法，可以节约大量时间。</p>
<table>
<colgroup>
<col style="width: 8%">
<col style="width: 91%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">库名称</th>
<th style="text-align: center;">介绍</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">数学库</td>
<td style="text-align: center;">涉及到各种精度的数学计算，可以查看<a href="https://docs.nvidia.com/cuda/cuda-math-api/">文档</a></td>
</tr>
<tr class="even">
<td style="text-align: center;">Thrust</td>
<td style="text-align: center;">类似C++的标准模板库</td>
</tr>
<tr class="odd">
<td style="text-align: center;">cuBLAS</td>
<td style="text-align: center;">基本线性代数子程序</td>
</tr>
<tr class="even">
<td style="text-align: center;">cuFFT</td>
<td style="text-align: center;">快速傅里叶变换</td>
</tr>
<tr class="odd">
<td style="text-align: center;">cuSPARSE</td>
<td style="text-align: center;">稀疏矩阵</td>
</tr>
<tr class="even">
<td style="text-align: center;">cuRAND</td>
<td style="text-align: center;">随机数生成库</td>
</tr>
<tr class="odd">
<td style="text-align: center;">cuSolver</td>
<td style="text-align: center;">稠密矩阵和稀疏矩阵计算库</td>
</tr>
<tr class="even">
<td style="text-align: center;">cuDNN</td>
<td style="text-align: center;">深度神经网络</td>
</tr>
</tbody>
</table>
<p>上述库需要使用时查阅<a href="https://docs.nvidia.com/cuda/">文档</a>即可</p>
<h4 id="thrust库">Thrust库</h4>
<p>这是一个实现了众多基本并行算法的C++模板库，类似于STL。</p>
<p>其提供了两种矢量结构(vector)，需要包含<code>&lt;thrust/host_vector.h&gt;</code>或<code>&lt;thrust/device_vector.h&gt;</code>来使用。</p>
<ul>
<li>thrust::host_vector<t> : 存储于主机的vector</t></li>
<li>thrust::device_vector<t> : 存储于设备的vector</t></li>
</ul>
<p>当然，其也提供了很多常用的算法</p>
<p>关于Thrust库的文档请查阅<a href="https://nvidia.github.io/thrust/">此处</a></p>
<h4 id="cublas">cuBLAS</h4>
<p>这个库专门用于进行矩阵运算，提供了诸多的矩阵相关的API，可以参阅<a href="https://docs.nvidia.com/cuda/cublas/index.html">文档</a></p>
<p>在使用的时候个地方需要特别提及一下，这个库由于最开始是使用Fortran语言实现的，因此带有Fortran语言风格。<strong>比如矩阵式按列有限存储的，这对局部性会产生印象，需要注意</strong>。</p>
<h4 id="cusolver">cuSolver</h4>
<p>这个库也是处理矩阵的，但是其主要处理高级矩阵运算，比如矩阵求逆或者对角化之类的东西。</p>
<h4 id="curand">cuRAND</h4>
<p>这个库用于产生随机数，可以产生伪随机数和准随机数。</p>
]]></content>
      <categories>
        <category>CUDA并行程序设计</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA高性能并行计算(2)--CUDA基础知识</title>
    <url>/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-2/</url>
    <content><![CDATA[<h2 id="cuda基础知识">CUDA基础知识</h2>
<span id="more"></span>
<h3 id="并行计算与串行计算">并行计算与串行计算</h3>
<p>对于计算密集型任务，当我们有很多计算核心时，每次只调用其中的一个核心进行一次计算任务，这时很浪费的，而这恰恰正式上一节中编写的程序的工作模式。而为了提高计算单元的效率，我们需要将串行工作模式改成并行计算模式，而这就需要用到CUDA和其API接口。</p>
<h3 id="cuda的基本概念">CUDA的基本概念</h3>
<p>由于GPU存在成千上万个廉价的计算单元，如果我们能将一个计算任务分解成多个子任务，这样就可以用GPU来完成并行计算，下面来介绍一下在并行计算中的规划方法。</p>
<p>CUDA引用了<strong>单指令多线程</strong>的并行模式(即每个线程执行相同的数据计算，然后使用一条指令控制从而减少控制器数目和系统复杂度--设想成千上万的线程各自做不同的事情，如果再有线程间通讯/同步，将会是怎样的梦魇)，GPU中包含大量的基础计算单元，称为<strong>核</strong>，每个核都包含了一个逻辑计算单元和一个浮点计算单元，多个核集成在一起被称为<strong>流多处理器</strong>。</p>
<img src="/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-2/pic1.png" class="">
<p>而将每个计算任务分解成多个子任务，称为<strong>线程</strong>，多个线程被组织成<strong>线程块</strong>，线程块被分解成大小与一个SM中核数量相同的<strong>线程束</strong>(大小为32)，每个线程束由一个SM负责执行，这些多流处理器的控制单元指挥其他所有核同时在一个线程束的每个线程中执行同一个指令，这是单指令多线程的来源。</p>
<h3 id="gpu与cpu对比">GPU与CPU对比</h3>
<p>众所周知，CPU也是可以执行并行计算的，那两者有什么区别呢？</p>
<p>首先，CPU是通用计算单元，其核心数目比较少，但是具备处理能力较强，同时其芯片上大部分空间是被设计成用于加速IO的高速缓存。而GPU拥有大量的能力稍弱的核，且每次都是使用一堆核做相同的计算(并不是做一摸一样的计算，而是做类型一样的计算，比如都是加法这样，这是更大的计算任务中的一小部分)，与CPU另一个不同之处在于GPU倾向于延迟隐藏，由于GPU上没有很多高速缓存，因此当一个线程束需要的数据不可达时，SM会转向去处理另一个线程束(挂起)。</p>
<h3 id="cuda计算任务流程">CUDA计算任务流程</h3>
<p>GPU计算中的关键结构是<strong>核函数</strong>，其产生大量组织成可以分配给SM的计算线程。</p>
<p>因此在计算时，需要加载核函数来创建一个由多个线程块组成的<strong>线程网格</strong>，同一个网格上的线程共享相同的全局内存空间，每个网格内有很多线程块，而每个线程块由多个线程组成。</p>
<p>一个线程块只会由一个SM来调度，但是一个SM可以调度多个线程块。另外由于SM的资源是有限的，所以其调用线程是由上限的。</p>
<img src="/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-2/pic2.png" class="">
<h3 id="核函数">核函数</h3>
<p>上面说了核函数是计算的关键函数，下面就来了解一下核函数怎么写。</p>
<h4 id="核函数的声明与标识符">核函数的声明与标识符</h4>
<p>由于GPU是一个外部设备，因此每个函数都需要指明这个函数是在主机上调用(CPU)还是在外部设备上调用(GPU)，并根据调用来编译出不同的代码。</p>
<p>为了告知编译器在哪个设备上编译，就需要额外引入标识符，有以下三种标识符</p>
<ul>
<li><p>__global__：在CPU调用父函数，子函数在GPU执行(异步)。用__global__修饰的一般就是内核(kernel)函数。</p></li>
<li><p>__device__：在GPU调用父函数，子函数在GPU执行。
由__device__修饰的函数可以被由__global__和__device__修饰的函数调用，这种情况是动态并行。</p></li>
<li><p>__host__：在CPU调用父函数，子函数在CPU执行（这是默认的标识符）。</p></li>
</ul>
<span class="label info">用__host__与__device__修饰的函数将同时在主机核设备上被编译。</span>
<div class="note primary">
            <p>一般来说，我们只需要2个修饰词就够了，但是cuda却提供了3个——2个执行位置为GPU。这儿要引入一个“函数执行环境标识符”的概念。父函数调用子函数时，父函数可能运行于CPU或者GPU，相应的子函数也可能运行于CPU或者GPU，但是这绝不是一个2*2的组合关系。因为GPU作为CPU的计算组件，不可以调度CPU去做事，所以不存在父函数运行于GPU，而子函数运行于CPU的情况。</p>
          </div>
<p>另外，核函数不能带有返回值，因此返回类型通常为void，以及在GPU上的核函数是不能访问主机端CPU可以访问的内存数据。</p>
<p>给出一个声明实例<code>__global__ void run_on_gpu()</code></p>
<h4 id="核函数的调用">核函数的调用</h4>
<p>核函数是一种特殊的函数，调用核函数从一个函数名开始，然后以一个包含逗号分割的参数列表，其中网格维度核线程块维度被放在参数列表中(三个尖括号，这是编译器扩展后的)。</p>
<p>形如<code>aKernal &lt;&lt;&lt;2, 2 &gt;&gt;&gt; ();</code></p>
<h4 id="一个示例">一个示例</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__host__ __device__ <span class="type">int</span> <span class="title">run_on_cpu_or_gpu</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">run_on_gpu</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"run_on_cpu_or_gpu GPU: %d\n"</span>, <span class="built_in">run_on_cpu_or_gpu</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"run_on_cpu_or_gpu CPU: %d\n"</span>, <span class="built_in">run_on_cpu_or_gpu</span>());</span><br><span class="line">	run_on_gpu &lt;&lt; &lt;<span class="number">2</span>, <span class="number">2</span> &gt;&gt; &gt; ();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CUDA并行程序设计</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA高性能并行计算(3)--CUDA编程初试</title>
    <url>/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-3/</url>
    <content><![CDATA[<h2 id="cuda编程初试">CUDA编程初试</h2>
<span id="more"></span>
<h3 id="第一个调用gpu计算的程序">第一个调用GPU计算的程序</h3>
<p>在前面，我们已经写了一个串行的dist程序计算，现在我们尝试对其进行改进，从而得到一个使用GPU进行计算的程序。</p>
<p>为了调用GPU，所以我们需要写一个核函数，从而在主机端调用GPU。由于核函数是用于不断产生出线程，而线程才是真正用于计算的东西，所以我们在核函数内需要为每个线程分配计算任务，这个就是等价之前for循环内部的东西。</p>
<p>值得注意的是，每个被核函数调用出来的线程执行的计算都是相同的，所以在核函数内需要为每个线程分配数据，这样就可以执行计算。</p>
<div class="note primary">
            <p>与之类比，在C语言中fork出的新线程可以执行与原有线程不一样的指令。</p>
          </div>
<h4 id="每个线程分配计算数据">每个线程分配计算数据</h4>
<p>那如何为每个线程分配数据呢？</p>
<p>在核函数内，有以下的变量可以用于给不同的线程分配数据，这些变量是提供线程块核线程的维度数核索引变量</p>
<ul>
<li><p><code>gridDim</code>：声明了网格中的线程块数目</p></li>
<li><p><code>blockDim</code>：声明了每个线程块中的线程数目</p></li>
<li><p><code>blockIdx</code>：给出了线程块在这个网格中的索引</p></li>
<li><p><code>threadIdx</code>：给出了这个线程在这个线程块中的索引</p></li>
</ul>
<div class="note primary">
            <p>前两个的类型为<code>dim3</code>，这是一个1*3的向量，可以使用.x.y.z来访问。</p><p>后面两个类型为<code>uint3</code>，这也是一个1*3向量，遇上一个类似。</p><p>核函数调用时的&lt;&lt;&lt;A,B&gt;&gt;&gt;其实是&lt;&lt;&lt;dim3(A,1,1),dim3(B,1,1)&gt;&gt;&gt;，即目前声明的都是1维数组，当需要计算二维、三维的时候，就可以声明高维数组。</p><p><span class="label info">每个线程块的线程数不超过1024</span></p>
          </div>
<h4 id="主机端与gpu的数据通信">主机端与GPU的数据通信</h4>
<p>由于GPU不能直接访问主机端中的数据，所以，CUDA提供了一系列可以把数据从设备传回主机的API</p>
<p>位于头文件<code>cuda_runtime.h</code></p>
<ul>
<li><p><code>cudaMalloc()</code>：分配设备端内存</p></li>
<li><p><code>cudaMemcpy()</code>：将数据传入或传出设备</p></li>
<li><p><code>cudaFree()</code>：释放设备内存</p></li>
<li><p><code>size_</code>：内存大小的专用变量</p></li>
<li><p><code>cudaError_t</code>：错误处理专用变量</p></li>
</ul>
<h4 id="编写程序">编写程序</h4>
<p>有了上面的内容，我们很容易就将之前的串行程序改成GPU并行程序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TPB 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行放缩的函数</span></span><br><span class="line"><span class="function">__device__ <span class="type">float</span> <span class="title">scale</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">float</span>)i / (n - <span class="number">1</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算距离的函数</span></span><br><span class="line"><span class="function">__device__ <span class="type">float</span> <span class="title">distance</span><span class="params">(<span class="type">float</span> x1, <span class="type">float</span> x2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x1 - x2)*(x1 - x2));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核函数，每个线程通过当前的线性维度来处理数组中的数据</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">distanceKernel</span><span class="params">(<span class="type">float</span> *d_out, <span class="type">float</span> ref, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 由于有两个网格，每个网格内有数目相等的线程</span></span><br><span class="line">    <span class="comment">// 所以就分别对其编号就可以了</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> i = blockIdx.x*blockDim.x + threadIdx.x;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> x = <span class="built_in">scale</span>(i, len);</span><br><span class="line">	d_out[i] = <span class="built_in">distance</span>(x, ref);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"i = %2d: dist from %f to %f is %f\n"</span>, i, ref, x, d_out[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> ref = <span class="number">0.5f</span>;</span><br><span class="line">	<span class="type">float</span> *d_out = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 分配设备端内存</span></span><br><span class="line">	<span class="built_in">cudaMalloc</span>(&amp;d_out, N * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">	distanceKernel &lt;&lt; &lt;N / TPB, TPB &gt;&gt; &gt; (d_out, ref, N);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cudaFree</span>(d_out);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行<code>nvcc distcuda.cu</code>来编译，运行后可以看到，程序的执行顺序是乱的，但是其结果都被打印出来了。</p>
<h2 id="另一个更深入的cuda程序">另一个更深入的CUDA程序</h2>
<p>我们之前写过两个版本的dist，现在我们把第二个版本的dist并行化。<br>
这是一个更加通用的结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DIST == 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;device_launch_parameters.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TPB 32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">scale</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">float</span>)i / (n - <span class="number">1</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">float</span> <span class="title">distance</span><span class="params">(<span class="type">float</span> x1, <span class="type">float</span> x2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x2 - x1)*(x2 - x1));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">distanceKernel</span><span class="params">(<span class="type">float</span> *d_out, <span class="type">float</span> * d_in, <span class="type">float</span> ref)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> i = blockIdx.x*blockDim.x + threadIdx.x;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> x = d_in[i];</span><br><span class="line">	d_out[i] = <span class="built_in">distance</span>(x, ref);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"i = %2d: dist from %f to %f is %f\n"</span>, i, ref, x, d_out[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">distanceArray</span><span class="params">(<span class="type">float</span> * out, <span class="type">float</span> *in, <span class="type">float</span> ref, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">float</span> *d_out = <span class="number">0</span>;</span><br><span class="line">	<span class="type">float</span> *d_in = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cudaMalloc</span>(&amp;d_out, len * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">	<span class="built_in">cudaMalloc</span>(&amp;d_in, len * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cudaMemcpy</span>(d_in, in, len * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">	distanceKernel &lt;&lt; &lt;N / TPB, TPB &gt;&gt; &gt; (d_out, d_in, ref);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cudaMemcpy</span>(out, d_out, len * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cudaFree</span>(d_in);</span><br><span class="line">	<span class="built_in">cudaFree</span>(d_out);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> ref = <span class="number">0.5f</span>;</span><br><span class="line">	<span class="type">float</span> * in = (<span class="type">float</span> *)<span class="built_in">calloc</span>(N, <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">	<span class="type">float</span> * out = (<span class="type">float</span> *)<span class="built_in">calloc</span>(N, <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	{</span><br><span class="line">		in[i] = <span class="built_in">scale</span>(i, N);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">distanceArray</span>(out, in, ref, N);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(in);</span><br><span class="line">	<span class="built_in">free</span>(out);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="程序执行过程">程序执行过程</h3>
<ol type="1">
<li>在设备上创建数组，这个数组大小和主机上的数组大小一致。</li>
<li>在内存上分配内存来存储输入的数据。</li>
<li>将主机端的数组复制到设备中(<code>cudaMemcpy</code>函数)</li>
<li>启动核函数执行计算并将输出值存储在设备内存上的输出数组中</li>
<li>将设备上的结果赋值到主机端</li>
<li>释放内存</li>
</ol>
<p>注意到，在GPU上的计算比在主机端的计算不一样的地方：</p>
<ul>
<li>在设备上创建一个镜像数组，然后需要把数据拷贝过去</li>
<li>启动一个核函数并执行大量计算</li>
<li>把结果拷贝回主机</li>
</ul>
<p>很明显，只有当核函数并行计算的收益超过拷贝数据时，使用GPU计算才是合理的。</p>
<h3 id="统一内存与托管数组">统一内存与托管数组</h3>
<p>在两个设备之间传递已有的很大数组这个步骤是必要且有点冗余的，所以出现了统一内存来<strong>简化开发流程</strong>。</p>
<p>统一内存就是一个主机和设备可以共同访问的内存，但实际上只是CUDA帮助我们完成了在主机与设备之间拷贝数组的活，这项工作本身没有消失，只是不需要显示地做了。另外，CUDA系统调度内存可能不如手工管理内存那样好。</p>
<p>其实现方式是使用<code>cudaMallocManaged()</code>即可。</p>
<p>我们对上一个程序使用统一内存来进行简化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;device_launch_parameters.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TPB 32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">scale</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">float</span>)i / (n - <span class="number">1</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">float</span> <span class="title">distance</span><span class="params">(<span class="type">float</span> x1, <span class="type">float</span> x2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x2 - x1)*(x2 - x1));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">distanceKernel</span><span class="params">(<span class="type">float</span> *d_out, <span class="type">float</span> * d_in, <span class="type">float</span> ref)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> i = blockIdx.x*blockDim.x + threadIdx.x;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> x = d_in[i];</span><br><span class="line">	d_out[i] = <span class="built_in">distance</span>(x, ref);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"i = %2d: dist from %f to %f is %f\n"</span>, i, ref, x, d_out[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">distanceArray</span><span class="params">(<span class="type">float</span> * out, <span class="type">float</span> *in, <span class="type">float</span> ref, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	distanceKernel &lt;&lt; &lt;N / TPB, TPB &gt;&gt; &gt; (out, in, ref);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> ref = <span class="number">0.5f</span>;</span><br><span class="line">	<span class="type">float</span> * in = <span class="number">0</span>;</span><br><span class="line">	<span class="type">float</span> * out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cudaMallocManaged</span>(&amp;in, N * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">	<span class="built_in">cudaMallocManaged</span>(&amp;out, N * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	{</span><br><span class="line">		in[i] = <span class="built_in">scale</span>(i, N);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">distanceArray</span>(out, in, ref, N);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cudaFree</span>(in);</span><br><span class="line">	<span class="built_in">cudaFree</span>(out);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意到distanceArray函数中不再需要冗长的复制数据的过程了，这样就非常的方便了。</p>
<h2 id="总结">总结</h2>
<ul>
<li>核函数只能在设备上执行，不能向主机端返回变量，其可以访问设备内存，但是不能访问主机内存(这也是为什么需要用<code>cudaMalloc</code>而不是<code>malloc</code>)。</li>
<li>可以使用<code>cudaMallocManaged()</code>来自动传递内存，而避免使用<code>cudaMemcpy()</code>来显示传递数据。</li>
<li>一般每个线程块的线程数目是32的整倍数时，可以对应SM中的CUDA核心数目，这样性能更好。</li>
<li>gridDim、blockDim、blockIdx、threadIdx这些变量可以用于定位线程的处理数据的索引。</li>
</ul>
]]></content>
      <categories>
        <category>CUDA并行程序设计</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA高性能并行计算(5)--CUDA二维计算网格</title>
    <url>/2022/09/08/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-5/</url>
    <content><![CDATA[<h2 id="cuda二维计算网格">CUDA二维计算网格</h2>
<span id="more"></span>
<h3 id="二维计算网格">二维计算网格</h3>
<h4 id="核函数创建二维计算网格">核函数创建二维计算网格</h4>
<p>之前我们的核函数是按照如下方式来创建计算网格的。</p>
<p><code>xxx_kernel &lt;&lt; &lt;2, 2 &gt;&gt; &gt; ();</code></p>
<p>前几篇也介绍过，这里会自动转换成<code>xxx_kernel &lt;&lt; &lt;dim3(2,1,1), dim3(2,1,1) &gt;&gt; &gt; ();</code>，后面两个维度的参数默认是1。</p>
<div class="note primary">
            <p>需要注意的是，在开普勒、图灵架构中，线程块内线程总数不超过1024</p>
          </div>
<p>所以我们需要创建一个二维网格只需要按照下面的方式调用核函数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">dim3 <span class="title">gridSize</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">blockSize</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">xxx_kernel&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="核函数内部确定线程位置">核函数内部确定线程位置</h4>
<p>在一维计算网格中，我们使用<code>blockIdx.x</code>和<code>threadIdx.x</code>来获取当前线程处的索引。在二维计算网格中，也是类似的，我们给核函数传递的网格维度和线程块维度存储在<code>gridDim</code>，<code>blockDim</code>中，这两个变量有<code>x</code>,<code>y</code>,<code>z</code>三个成员存储传入dim3的三个维度。</p>
<p>与之类似，<code>blockIdx</code>和<code>threadIdx</code>也有<code>x</code>,<code>y</code>,<code>z</code>三个成员分别存储当前线程块索引和线程索引。</p>
<p>下面给出一个简单的二维计算网格的程序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;device_launch_parameters.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK(call)                                   \</span></span><br><span class="line"><span class="meta">do                                                    \</span></span><br><span class="line"><span class="meta">{                                                     \</span></span><br><span class="line"><span class="meta">    const cudaError_t error_code = call;              \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (error_code != cudaSuccess)                    \</span></span><br><span class="line"><span class="meta">    {                                                 \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"CUDA Error:\n"</span>);                      \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"    File:       %s\n"</span>, __FILE__);     \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"    Line:       %d\n"</span>, __LINE__);     \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"    Error code: %d\n"</span>, error_code);   \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"    Error text: %s\n"</span>,                \</span></span><br><span class="line"><span class="meta">            cudaGetErrorString(error_code));          \</span></span><br><span class="line"><span class="meta">        exit(1);                                      \</span></span><br><span class="line"><span class="meta">    }                                                 \</span></span><br><span class="line"><span class="meta">} while (0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TY 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 核函数，这里的float2是一个二维向量</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">distanceKernel</span><span class="params">(<span class="type">float</span> * d_out, <span class="type">int</span> w, <span class="type">int</span> h, float2 pos)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c = blockIdx.x * blockDim.x + threadIdx.x; <span class="comment">// 行索引</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> r = blockIdx.y*blockDim.y + threadIdx.y; <span class="comment">// 列索引</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> i = r * w + c; <span class="comment">// 行优先存储，获取到当前线程的实际位置</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((c &gt;= w) || (r &gt;= h))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	d_out[i] = <span class="built_in">sqrtf</span>((c - pos.x)*(c - pos.x) + (r - pos.y)*(r - pos.y)); <span class="comment">// 计算结果</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread (%d, %d) in grid (%d, %d) computes the result is %f\n"</span>, threadIdx.x, threadIdx.y, blockIdx.x, blockIdx.y,d_out[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">float</span> *out = (<span class="type">float</span> *)<span class="built_in">calloc</span>(W*H, <span class="built_in">sizeof</span>(<span class="type">float</span>)); <span class="comment">// 主机内存</span></span><br><span class="line">	<span class="type">float</span> * d_out; <span class="comment">// 设备内存</span></span><br><span class="line">	<span class="built_in">cudaMalloc</span>(&amp;d_out, W*H* <span class="built_in">sizeof</span>(<span class="type">float</span>)); <span class="comment">// 为设备分配内存</span></span><br><span class="line">	<span class="type">const</span> float2 pos = { <span class="number">0.0f</span>,<span class="number">0.0f</span> }; <span class="comment">// 初始化计算过程中传递的常量</span></span><br><span class="line">	<span class="function"><span class="type">const</span> dim3 <span class="title">blockSize</span><span class="params">(TX, TY)</span></span>; <span class="comment">// 指定线程块大小</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> bx = (W + TX - <span class="number">1</span>) / TX; <span class="comment">// 向上舍入计算出x方向的计算网格数目</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> by = (H + TY - <span class="number">1</span>) / TY; <span class="comment">// 向上摄入计算处y方向的计算网格数目</span></span><br><span class="line">	<span class="type">const</span> dim3 gridSize = <span class="built_in">dim3</span>(bx, by); <span class="comment">// 指定计算网格大小</span></span><br><span class="line"></span><br><span class="line">	distanceKernel &lt;&lt; &lt;gridSize, blockSize &gt;&gt; &gt; (d_out, W, H, pos); <span class="comment">// 启动核函数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cudaDeviceSynchronize</span>(); <span class="comment">// 同步设备与主机</span></span><br><span class="line">	<span class="built_in">cudaMemcpy</span>(out, d_out, W*H * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyDeviceToHost); <span class="comment">// 拷贝计算结果</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cudaFree</span>(d_out); <span class="comment">// 释放内存</span></span><br><span class="line">	<span class="built_in">free</span>(out);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，执行这个程序的时候，可以观测到明显的输出卡顿，这就是前面提到的由于GPU高速缓存能力比较弱，所以当核函数执行简单的计算时内存IO将成为瓶颈。</p>
<h2 id="总结">总结</h2>
<ul>
<li>线程块内线程总数不超过1024。</li>
<li>blockIdx和threadIdx存在三个成员来保存维度</li>
</ul>
]]></content>
      <categories>
        <category>CUDA并行程序设计</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA高性能并行计算(4)--CUDA错误检测与程序计时</title>
    <url>/2022/09/06/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-4/</url>
    <content><![CDATA[<h2 id="cuda错误检测与程序计时">CUDA错误检测与程序计时</h2>
<span id="more"></span>
<h3 id="错误检测">错误检测</h3>
<h4 id="程序中的错误">程序中的错误</h4>
<p>前面写的程序其实是存在重大问题的，只是我们刻意选择了一些数据来规避了错误的触发。</p>
<p>其引起错误的关键是这里</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TPB 32</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">distanceKernel &lt;&lt; &lt;N / TPB, TPB &gt;&gt; &gt; (d_out, d_in, ref);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>核函数会创建N/TPB个线程块，每个线程块中有TPB个线程。此处每个线程块内的线程数目是确定的(因为一般都是2的整数次幂)。</p>
<p>而如果N不是2的整数次幂，比如N=63，此时计算出来的N/TPB = 63/32 =
1，也就意味着此时只分配一个有32个线程组成的线程块，是不足以完成整个计算的。</p>
<p>所以我们需要N/TPB向上取整才对，将这个公式改成<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="8.434ex" height="2.774ex" role="img" focusable="false" viewBox="0 -880.9 3728 1225.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(237,398) scale(0.707)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1666,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mrow" transform="translate(220,-345) scale(0.707)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(704,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(1455,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g><rect width="1765.5" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(2227.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3228,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>就完成了向上取整的任务。但是此时又会引入新的问题。</p>
<p>比如此时N取65，那么就会分配64/32+1=3个线程块，而每个线程块内又有32个线程，这样就分配了96个线程用于计算，而每个线程会访问其索引对应的数组位置，但是我们只分配了N=65个浮点数的内存，当后续的线程访问对应的数组下标时，其实引发了数组越界的问题，会导致段错误或者是完成计算但是结果匪夷所思。</p>
<p>此处我们当然可以在核函数内使用如下形式的if来结束掉不必要的线程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt;= N)</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>核函数不可以有返回值，但是能用return，return后不能带参数</p>
          </div>
<h4 id="检测cuda运行时的宏函数">检测CUDA运行时的宏函数</h4>
<p>上面的错误是比较明显的，所以我们可以直接纠正。但是还有一部分错误我们可能没有办法快速定位(因为CUDA不会主动抛出错误，造成DEBUG上困难)。</p>
<div class="note primary">
            <p>此处只讨论运行时错误，因为编译时错误肯定会被检测出来。</p>
          </div>
<p>但是，虽然我们没法直接定位错误，但是所有以cuda开头的函数其实都是有返回值的，其返回值的类型为<code>cudaError_t</code>，代表了一种错误信息，只有当返回值为<code>cudaSuccess</code>时，才成功调用了函数。</p>
<p>可以创建一个用于在运行时检测CUDA函数错误的宏函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK(call)                                   \</span></span><br><span class="line"><span class="meta">do                                                    \</span></span><br><span class="line"><span class="meta">{                                                     \</span></span><br><span class="line"><span class="meta">    const cudaError_t error_code = call;              \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (error_code != cudaSuccess)                    \</span></span><br><span class="line"><span class="meta">    {                                                 \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"CUDA Error:\n"</span>);                      \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"    File:       %s\n"</span>, __FILE__);     \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"    Line:       %d\n"</span>, __LINE__);     \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"    Error code: %d\n"</span>, error_code);   \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"    Error text: %s\n"</span>,                \</span></span><br><span class="line"><span class="meta">            cudaGetErrorString(error_code));          \</span></span><br><span class="line"><span class="meta">        exit(1);                                      \</span></span><br><span class="line"><span class="meta">    }                                                 \</span></span><br><span class="line"><span class="meta">} while (0)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在调用一个cudafunc时，可以CHECK(cudafunc)这样来调用，当函数出现错误时，就能被宏函数捕捉到。</p>
<h4 id="检查核函数中的错误">检查核函数中的错误</h4>
<p>上述方法只能用于检测以cuda函数开头的函数是否被正确执行。但是由于核函数不存在返回值，所以核函数需要用别的方法进行检查。</p>
<p>下面给出两个自带的函数：</p>
<ul>
<li><code>cudaGetLastError()</code>：捕捉上一个错误。</li>
<li><code>cudaDeviceSynchronize()</code>：同步主机与设备。</li>
</ul>
<div class="note primary">
            <p><strong>同步主机与设备</strong></p><p>由于核函数是异步调用的，即主机调用完核函数后会直接执行下一条指令，而不会等核函数执行完。</p><p>不过由于同步操作相当耗时，所以一般不在循环内层调用。只会在必要的时候调用。</p>
          </div>
<p>在核函数调用后加上下面这两句就能实现检测核函数错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">CHECK</span>(<span class="built_in">cudaGetLastError</span>());</span><br><span class="line"><span class="built_in">CHECK</span>(<span class="built_in">cudaDeviceSynchronize</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="检查内存错误">检查内存错误</h4>
<p>CUDA提供了CUDA-MEMCHECK工具集，可以在命令行使用<code>cuda-memcheck</code>来使用。</p>
<p>当使用nvcc编译程序后，执行<code>cuda-memcheck ./a.out</code>就可以看到内存错误检查后的结果。</p>
<h3 id="cuda事件计时">CUDA事件计时</h3>
<p>对一个函数或程序进行计时是很常见的事情，毕竟，我们用GPU改写了一个程序后，肯定想定量的计算性能的提升。</p>
<p>在CUDA中，提供了基于CUDA事件的计时方法。在CUDA程序中，CPU端将命令写到命令缓冲区中，GPU端会依次读取命令缓冲区并执行任务，一般的程序中，GPU需要给CPU汇报任务的工作进度。命令缓冲区和“同步信息位置”都位于锁页主机内存上，所以CPU和GPU都能同时读写这些数据。在这个“同步信息位置”的内存上，会设置一个单调递增的整数值（“进度值”），GPU完成一条命令操作之后，就会更新递增这个“同步值”，CPU读取这个“同步值”，就可以知道GPU的工作进度。</p>
<p>CUDA事件可以反映这种硬件能力，cudaEventRecord()函数的作用是将一个命令加入队列，使一个新的同步值写入共享同步位置中，cudaEventQuery()和cudaEventSynchronize()则分别用于检查和等待这个事件的同步值。</p>
<p>其实原理很简单：先用cudaEventRecord()记录下一个起始事件的时刻，然后再记录下结束事件的时刻，然后两者做差就能得到时间了。但是需要注意，事件记录这件事本身也是异步的，因此需要在结束事件的位置进行同步，让CPU等待这个事件被记录。</p>
<p>下面是抽象出来的记录时间的代码片段</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cudaEvent_t start, stop; <span class="comment">// 创建事件</span></span><br><span class="line"><span class="built_in">cudaEventCreate</span>(&amp;start); <span class="comment">// 初始化事件</span></span><br><span class="line"><span class="built_in">cudaEventCreate</span>(&amp;stop); <span class="comment">// 初始化事件</span></span><br><span class="line"><span class="built_in">cudaEventRecord</span>(start); <span class="comment">// 事件开始，用于计时</span></span><br><span class="line"><span class="built_in">cudaEventQuery</span>(start); <span class="comment">// 刷新队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面是需要被计时的代码片段*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*上面是需要被计时的代码片段*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cudaEventRecord</span>(stop); <span class="comment">// 结束事件记录</span></span><br><span class="line"><span class="built_in">cudaEventSynchronize</span>(stop); <span class="comment">// 让主机等待事件stop被记录完毕</span></span><br><span class="line"><span class="type">float</span> times = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cudaEventElapsedTime</span>(&amp;times, start, stop); <span class="comment">// 获取起始事件和结束事件的差值，单位ms</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"time = %f\n"</span>, times); </span><br><span class="line"><span class="built_in">cudaEventDestroy</span>(start); <span class="comment">// 销毁事件</span></span><br><span class="line"><span class="built_in">cudaEventDestroy</span>(stop);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note primary">
            <p>如果不在结束事件出进行同步，那么是不会得到正确的时间的。</p><p>可以把同步处代码注释掉，然后将获取时间的部分改成<code>CHECK(cudaEventElapsedTime(&amp;times, start, stop));</code></p><p>这样就能看到device notready的错误了，且输出的时间为0，也是不正确的。</p>
          </div>
<h4 id="分析代码性能工具">分析代码性能工具</h4>
<p>CUDA工具箱中存在一个叫<code>nvprof</code>的程序，可以执行性能分析。但是注意要将cuda下的<code>extras\CUPTI\lib64</code>添加到环境变量，同时此程序必须运行在管理员模式下。</p>
<p>输入<code>nvprof {程序名}</code>即可执行代码性能分析。</p>
<h4 id="影响gpu加速的关键因素">影响GPU加速的关键因素</h4>
<ul>
<li>由于调用设备GPU计算需要将数据先传递到GPU中，这会导致额外的耗时，所以小规模计算是不划算的。另外，GPU与CPU的连接桥PCIE总线速度是远远低于GPU显存带宽的，因此不能将数据来回传递。</li>
<li>GPU由于没有很多空间去布置高速缓存，因此在GPU中，对内存进行读写是相当耗时的。这导致开销比较低的计算(比如简单加法)时受到内存读写瓶颈的限制，导致性能下降。</li>
<li>GPU一个SM能驻留1024个线程，而一个GPU有几个到几十个SM，因此能开到几万至几十万个线程，当我们的并行规模远小于这个数目时，性能就不能达到最优。</li>
</ul>
<p>因此我们想要获得很好的加速性能就需要满足以下几点：</p>
<ul>
<li>数据传输比例小，减少主机与设备的数据传输。</li>
<li>提高核函数的运算强度。</li>
<li>增大核函数的并行规模。</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>每个cuda函数都使用宏函数来检测错误</li>
<li>使用CHECK(cudaGetLastError())来检测核函数错误</li>
<li>cuda-memcheck工具来检测内存错误</li>
<li>使用cuda事件用于计时</li>
<li>nvprof来进行代码分析</li>
</ul>
]]></content>
      <categories>
        <category>CUDA并行程序设计</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA高性能并行计算(6)--CUDA内存组织与使用</title>
    <url>/2022/09/08/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-6/</url>
    <content><![CDATA[<h2 id="cuda内存组织与使用">CUDA内存组织与使用</h2>
<span id="more"></span>
<h3 id="cuda的内存组织结构">CUDA的内存组织结构</h3>
<p>与CPU的内存结构相似，GPU也是存在类似L1、L2之类的高速缓存的东西，而且CUDA为程序员提供更多的控制权，下面列出CUDA的内存模型。</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 26%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">内存类型</th>
<th style="text-align: center;">物理位置</th>
<th style="text-align: center;">访问权限</th>
<th style="text-align: center;">可见范围</th>
<th style="text-align: center;">生命周期</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">全局内存</td>
<td style="text-align: center;">芯片外</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">所有线程和主机端</td>
<td style="text-align: center;">主机分配和释放</td>
</tr>
<tr class="even">
<td style="text-align: center;">常量内存</td>
<td style="text-align: center;">芯片外</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">所有线程和主机端</td>
<td style="text-align: center;">主机分配和释放</td>
</tr>
<tr class="odd">
<td style="text-align: center;">纹理和表面内存</td>
<td style="text-align: center;">芯片外</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">所有线程和主机端</td>
<td style="text-align: center;">主机分配和释放</td>
</tr>
<tr class="even">
<td style="text-align: center;">寄存器内存</td>
<td style="text-align: center;">芯片内</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">单个线程</td>
<td style="text-align: center;">所在线程</td>
</tr>
<tr class="odd">
<td style="text-align: center;">局部内存</td>
<td style="text-align: center;">芯片外</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">单个线程</td>
<td style="text-align: center;">所在线程</td>
</tr>
<tr class="even">
<td style="text-align: center;">共享内存</td>
<td style="text-align: center;">芯片内</td>
<td style="text-align: center;">R/W</td>
<td style="text-align: center;">单个线程块</td>
<td style="text-align: center;">所在线程块</td>
</tr>
</tbody>
</table>
<img src="/2022/09/08/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-6/pic1.jpg" class="">
<p>下面对这些内存逐一阐述</p>
<h4 id="全局内存">全局内存</h4>
<p>全局内存是指核函数中所有线程都访问的内存，与C语言中的全局内存概念上存在差异。其容量是最大的，基本上就是显存容量。当然，其访问速度也是相对比较低的。</p>
<p>全局内存的主要目的就是为核函数提供数据、在主机与设备和在设备与设备之间传递数据。</p>
<p>全局内存对所有线程可见，且其是完全由主机端来进行分配和回收的，另外，全局内存是线性排列的。</p>
<p>我们通过使用cudaMalloc()函数可以动态地在全局内存中分配，但是我们也可以在全局内存上分配静态内存，这样的<code>全局的静态全局内存变量</code>必须在所有函数外部定义，即类似与C语言中的全局变量的定义，同样是所有线程可访问，且大小在编译时确定。</p>
<p>定义方法如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">__device__ T x; <span class="comment">// 单个类型为T的变量</span></span><br><span class="line">__device__ T x[<span class="number">120</span>]; <span class="comment">// 固定长度的数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在核函数内可以对这些<code>全局的静态全局内存变量</code>进行访问，而不需要显示传递，但是这些变量对主机端不可见。</p>
<p>要想让主机端访问这些变量，或者在主机端和设备之间传递这些数据，需要用到<code>cudaMemcpyToSymbol(symbol:设备符号, src:主机符号, count:长度, offset:设备偏移量, Flag:方向)</code>和<code>cudaMemcpyFromSymbol(dst:主机, symbol:设备, count:长度, offset:设备偏移量,Flag:方向)</code>来进行传递。</p>
<h4 id="常量内存">常量内存</h4>
<p>常量内存是有常量缓存的内存，数量有限，只有64K，其可见范围与生存周期与全局内存一样。不过常量内存仅可读，不可写。但是由于其存在缓存，所以速度会高很多。如果想得到高速的访问速度，需要保证线程束中的线程(线程块中相邻的32个线程)读取相同的常量内存(这样高速缓存才会命中)，(每个线程束由一个SM负责处理)。</p>
<p>定义常量内存的方式是使用<code>__constant__</code>关键字来修饰变量，并使用<code>cudaMemcpyToSymbol()</code>来将数据复制到设备端。一般来说，给核函数按指传递的数据就放在常量内存中，但给核函数传递的参数最多在核函数内使用4KB常量内存。</p>
<h4 id="纹理内存与表面内存">纹理内存与表面内存</h4>
<p>纹理内存与表面内存类似与常量内存，有相同的可见范围与生命周期，但是其容量更大，使用方式也略微有些区别。</p>
<p>对比较新的架构，对全局只读内存使用<code>__ldg(*addr)</code>函数可以通过全局只读缓存读取，这样速度会快一些。</p>
<h4 id="寄存器">寄存器</h4>
<p>核函数中定义的不加任何修饰符的变量就位于寄存器，gridDim这些也位于特殊的寄存器，所以访问的很快。在核函数中定义的数组有可能放在寄存器中，这取决于数组大小。</p>
<p>寄存器变量位于芯片中，是访问速度最高的，且与所属线程生命周期一样长。</p>
<h4 id="局部内存">局部内存</h4>
<p>局部内存是全局内存的一部分，所以延迟很高，但是其使用方式跟寄存器内存一致。即在核函数内定义的不加修饰的变量或数组，存的下的位于寄存器，存不下的位于局部内存。</p>
<p>每个线程最多使用512k的局部内存，但是使用过多会降低性能。</p>
<h4 id="共享内存">共享内存</h4>
<p>共享内存位于芯片上，读写速度仅次于寄存器，不过其声明周期是与线程块一样长。线程块内的所有线程都可以访问共享内存。</p>
<h4 id="缓存">缓存</h4>
<p>一般来说，高速缓存是不能被编程的，其执行过程是自动的，但是其对优化程序速度非常大。</p>
<p>GPU的缓存有L1缓存(SM层次)、L2缓存(设备层次)，但是从硬件角度看L1缓存、纹理缓存和共享内存使用的相同的物理结构。</p>
<div class="note primary">
            <p>此处仅考虑图灵架构，因为图灵架构是最新的架构。</p>
          </div>
<p>因此，共享内存其实就可以看成是可以编程的缓存。</p>
<h3 id="sm中的资源数目">SM中的资源数目</h3>
<p>一个GPU是由多个SM组成的，一个SM包含以下资源：</p>
<ul>
<li>一定数量的寄存器</li>
<li>一定数量的共享内存</li>
<li>常量内存缓存</li>
<li>纹理和表面内存缓存</li>
<li>L1缓存</li>
<li>线程束调度器，用于对就绪线程发出执行命令</li>
<li>执行核心
<ul>
<li>若干整型运算核心INT32</li>
<li>若干单精度浮点数运算核心FP32</li>
<li>若干双精度浮点数运算核心FP64</li>
<li>若干单精度浮点数超越函数的函数单元SFUs</li>
<li>若干混合精度的张量核心tensor core</li>
</ul></li>
</ul>
<p>因为一个SM的资源是有限的，所以有些情况下SM中驻留的线程数可能达不到理想的最大值，也就是SM的占有率不足100%。</p>
<p>一般来说，让SM占有率保持在一个值(25%)以上，才可能获得高性能计算。</p>
<p>另外，在图灵架构中，一个SM最多拥有16个线程块，且一个SM中最多有1024个线程（注意一个线程块中最多线程数目也是1024，而一个线程束大小为32）</p>
<h4 id="运行时api查询设备">运行时API查询设备</h4>
<p>通过一些运行时API来查询设备资源，可以用于编写针对不同架构的的显卡的程序。</p>
<p>下面给出一个代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;device_launch_parameters.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TARGET 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK(call)                                   \</span></span><br><span class="line"><span class="meta">do                                                    \</span></span><br><span class="line"><span class="meta">{                                                     \</span></span><br><span class="line"><span class="meta">    const cudaError_t error_code = call;              \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (error_code != cudaSuccess)                    \</span></span><br><span class="line"><span class="meta">    {                                                 \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"CUDA Error:\n"</span>);                      \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"    File:       %s\n"</span>, __FILE__);     \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"    Line:       %d\n"</span>, __LINE__);     \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"    Error code: %d\n"</span>, error_code);   \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">"    Error text: %s\n"</span>,                \</span></span><br><span class="line"><span class="meta">            cudaGetErrorString(error_code));          \</span></span><br><span class="line"><span class="meta">        exit(1);                                      \</span></span><br><span class="line"><span class="meta">    }                                                 \</span></span><br><span class="line"><span class="meta">} while (0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET == 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> device_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cudaDeviceProp prop;</span><br><span class="line">	<span class="built_in">CHECK</span>(<span class="built_in">cudaGetDeviceProperties</span>(&amp;prop, device_id)); <span class="comment">// 获取设备数据</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"device id : %d \n"</span>, device_id);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"device name : %s \n"</span>, prop.name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"compute capability %d.%d\n"</span>, prop.major, prop.minor);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"global mem : %g GB\n"</span>, prop.totalGlobalMem / (<span class="number">1024.0</span> * <span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"constant mem : %g kb\n"</span>, prop.totalConstMem / <span class="number">1024.0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"max grid size : (%d, %d, %d)\n"</span>, prop.maxGridSize[<span class="number">0</span>], prop.maxGridSize[<span class="number">1</span>], prop.maxGridSize[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"max block size : (%d, %d, %d)\n"</span>, prop.maxThreadsDim[<span class="number">0</span>], prop.maxThreadsDim[<span class="number">1</span>], prop.maxThreadsDim[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"numbers of SM : %d\n"</span>, prop.multiGpuBoardGroupID);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"max shared mem per block : %g kb\n"</span>, prop.sharedMemPerBlock / <span class="number">1024.0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"max numbers of register per block : %d K\n"</span>, prop.regsPerBlock);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"max numbers of register per SM : %d K\n"</span>, prop.regsPerMultiprocessor/<span class="number">1024</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"max number of threads per block : %d\n"</span>, prop.maxThreadsPerBlock);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"max number of threads per SM : %d\n"</span>, prop.maxThreadsPerMultiProcessor);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CUDA并行程序设计</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA高性能并行计算(7)--CUDA软件抽象与硬件抽象</title>
    <url>/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-7/</url>
    <content><![CDATA[<h2 id="cuda软件抽象与硬件抽象">CUDA软件抽象与硬件抽象</h2>
<span id="more"></span>
<p>之前我们了解了许多概念，比如SM、计算网格、线程块等等，但这些包含对软件部分的抽象和对硬件部分的抽象，下面我们来分别对这些层次的抽象进行具体的描述。</p>
<h3 id="硬件抽象">硬件抽象</h3>
<img src="/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-7/pic1.jpg" class="">
<p>硬件抽象包括SM(流多处理器，大核心)、SP(流处理器，小核心)。SP是GPU最基本的处理单元，也称为CUDA
core，每个SM中包含几十或者上百个CUDA核心。</p>
<p>其中，SP是执行每个线程的单元，一个SP对应一个线程。每个SP有自己的寄存器和局部内存，可以看作是微型CPU。</p>
<p>而SM则是多个SP聚合在一起，并且有负责管理线程调度的单元，和共享内存等。</p>
<div class="note primary">
            <p>可以用下面这个例子来进行类比：</p><p>将GPU比作教学楼，那么SM就是教学楼中的每一个楼层，有着一些共享设施(wrap调度器、共享内存等)；而SP就是每一间教室里的学生，有着自己的课桌和其他资源(寄存器、局部内存、运算器等)；而每间教室则可以看成是对SP进行的一个分组(线程束)，活动(计算)都是以班级为单位整体进行的(即单指令多线程)。</p>
          </div>
<h3 id="软件抽象">软件抽象</h3>
<img src="/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-7/pic2.png" class="">
<p>软件抽象包括计算网格、线程块、线程束、线程。</p>
<p>计算网格是用于对计算任务的抽象，其大小限制为(<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.816ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 3012.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>,<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="5.656ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 2500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(2000,0)"></path></g></g></g></svg></mjx-container></span>,<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="5.656ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 2500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(2000,0)"></path></g></g></g></svg></mjx-container></span>)，主要目的是用于将计算任务划分成不同的最小计算单元。<strong>计算网格是GPU级别的基本调度单位</strong>。</p>
<p>线程块也是用于对计算任务的抽象，线程块大小最大为1024。同一线程块的线程(线程束)将会被分配到同一个SM上。<strong>线程块是SM级别的基本调度单位</strong>。</p>
<p>线程束，线程束就是软件抽象与硬件抽象的桥梁，与硬件中的线程束相对应，线程束大小为32。每个线程束中的线程是通过单指令多线程来执行的，所以每个线程做的工作是一样的。<strong>线程束是ALU级别的基本调度单位</strong>。</p>
<p>线程，线程是执行具体计算的东西，但是线程不会被单个调度，都是以线程束为整体进行调度的。</p>
<div class="note primary">
            <p>可以用下面这个例子来进行类比：</p><p>将GPU所有的计算资源看作学校，那么计算网格就是学校里面的年级，有时候不同年级也会出现在同一层楼中(一个SM可以对应多个线程块，<strong>但这里稍微有些差异，因为一个线程块只能对应一个SM</strong>)；线程块对应的是班级，一个班级的所有人肯定是在一层楼中的(对应线程块上所有线程束在同一个SM上)，且班级一般都是一样大的(最大线程数相同)；线程束是班级里面划分的小组，一般收作业都是每个小组一起交(线程束统一被调度，且任务相同)；线程则对应个人。</p>
          </div>
<h3 id="执行计算过程">执行计算过程</h3>
<img src="/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-7/pic3.png" class="">
<p>有了软件抽象和硬件抽象，下面我们就来考虑具体的任务是怎么被执行的。</p>
<p>虽然GPU是并行运行，但也并不是我们理想中所有的线程一起工作。下面我们还是以例子来进行说明。</p>
<p>当学校组织全校大扫除时(计算任务)，首先会按照年级来为各年级(SM)下达指令(计算网格)，然后每个年级再为每个班级(线程块)分配包干区(线程块分配)，在打扫卫生时，并不是所有学生一起干活，学生经过老师（这里我们理解为线程束调度器）安排后，分为一组一组的小组(线程束)，每一个小组都只会做一件一样的事情，如果有人先做完了或者不需要做，那么他也会在旁边等他的组员，处于等待状态，直到小组内所有组员工作完成；另外，由于工具是有限的(计算资源有限)，所以可能会存在一部分小组暂时干不了活(没有足够资源调度)，且某个小组干完活之后送还工具是需要时间的(调度耗时)。</p>
]]></content>
      <categories>
        <category>CUDA并行程序设计</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA高性能并行计算(9)--原子函数及其合理使用</title>
    <url>/2022/09/11/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-9/</url>
    <content><![CDATA[<h2 id="cuda全局内存共享内存的合理使用">CUDA全局内存、共享内存的合理使用</h2>
<span id="more"></span>
<h3 id="原子操作">原子操作</h3>
<p>所谓原子操作，就是不能被中断的操作，因为在多线程任务中，假设有全局内存可以被所有线程访问，且线程的任务均为读--将值加一--写回，那么当线程1进行加一的操作时，线程2将其结果写入到该内存中，那么接下来线程1再写回时，就覆盖了线程2的计算结果。如果这个任务被用于计数的话，那么结果就是线程之间串扰导致错误。</p>
<p>因此，我们希望某个线程在执行这一套流程时，其他线程不能访问这个全局内存，只有这样我们才能保证最终结果的正确性，这就是<strong>原子操作</strong>。</p>
<p>当然，假如说每个线程执行的任务都是需要对共享内存进行大量的原子读写，就会导致性能下降的很多。</p>
<p>我们可以使用形如<code>atomicxxx(addr, val)</code>的函数来进行原子操作，**原子函数都是__device__修饰的**。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">T atomicAdd(T*, T)</td>
<td style="text-align: center;">加法</td>
</tr>
<tr class="even">
<td style="text-align: center;">T atomicSub(T*, T)</td>
<td style="text-align: center;">减法</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T atomicExch(T*, T)</td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="even">
<td style="text-align: center;">T atomicMin(T*, T)</td>
<td style="text-align: center;">最小值</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T atomicMax(T*, T)</td>
<td style="text-align: center;">最大值</td>
</tr>
<tr class="even">
<td style="text-align: center;">T atomicInc(T*, T)</td>
<td style="text-align: center;">自增</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T atomicDec(T*, T)</td>
<td style="text-align: center;">自减</td>
</tr>
<tr class="even">
<td style="text-align: center;">T atomicCAS(T*, T1, T2)</td>
<td style="text-align: center;">比较-交换</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T atomicAnd(T*, T)</td>
<td style="text-align: center;">按位与</td>
</tr>
<tr class="even">
<td style="text-align: center;">T atomicOr(T*, T)</td>
<td style="text-align: center;">按位或</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T atomicXor(T*, T)</td>
<td style="text-align: center;">按位异或</td>
</tr>
</tbody>
</table>
<div class="note primary">
            <p>其结果一般都是 *(T*) = *(T *) operate T</p><p>原子函数的返回值都是*(T *)的原始值。</p><p>举例：T atomicSub(T* addr, T val)</p><p>等效于</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">T tmp = *addr;</span><br><span class="line">*addr = *addr - val;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中比较特殊的T atomicCAS(T*, T1, T2)的作用是*(T*) = (*(T*) = T1) ?T2 : *(T*)</p>
          </div>
<div class="note info">
            <p>还有需要注意一点，原子函数是有精度限制的，比如atomicSub要求数据类型为<code>int</code>,<code>unsigned</code>,<code>unsigned long long</code>，而不能是浮点数类型。</p><p>一般所有的原子操作都是通过atomicCAS来实现，但是在实际过程中要避免这样做，因为性能会下降。</p>
          </div>
<p>下面给出一个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"device_atomic_functions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TPB 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">dotKernel</span><span class="params">(<span class="type">int</span> * d_res, <span class="type">const</span> <span class="type">int</span> *d_a, <span class="type">const</span> <span class="type">int</span> * d_b, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> idx = threadIdx.x + blockDim.x * blockIdx.x;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> s_idx = threadIdx.x;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (idx &gt;= n)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	__shared__ <span class="type">int</span> s_prod[TPB];</span><br><span class="line">	s_prod[s_idx] = d_b[idx] * d_a[idx];</span><br><span class="line">	__syncthreads(); <span class="comment">// 至此，所有的分块计算都完成了</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s_idx == <span class="number">0</span>) <span class="comment">// 使用每个线程块中的第一个线程进行数据合并计算</span></span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> blockSum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; blockDim.x; ++j)</span><br><span class="line">		{</span><br><span class="line">			blockSum += s_prod[j];</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"block %d, blocksum %d\n"</span>, blockIdx.x, blockSum);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ATOMIC == 1</span></span><br><span class="line">		<span class="built_in">atomicAdd</span>(d_res, blockSum); <span class="comment">// 原子计算</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		*d_res += blockSum; <span class="comment">// 直接计算</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doLauncher</span><span class="params">(<span class="type">int</span> * res, <span class="type">const</span> <span class="type">int</span> *a, <span class="type">const</span> <span class="type">int</span> *b, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> * d_res;</span><br><span class="line">	<span class="type">int</span> *d_a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> *d_b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配内存</span></span><br><span class="line">	<span class="built_in">cudaMalloc</span>(&amp;d_res, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="built_in">cudaMalloc</span>(&amp;d_a, n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="built_in">cudaMalloc</span>(&amp;d_b, n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝数据</span></span><br><span class="line">	<span class="built_in">cudaMemset</span>(d_res, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="built_in">cudaMemcpy</span>(d_a, a, n * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line">	<span class="built_in">cudaMemcpy</span>(d_b, b, n * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用核函数计算并将数据写回主机端</span></span><br><span class="line">	dotKernel &lt;&lt; &lt;(n + TPB - <span class="number">1</span>) / TPB, TPB &gt;&gt; &gt; (d_res, d_a, d_b, n);</span><br><span class="line">	<span class="built_in">cudaMemcpy</span>(res, d_res, <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放内存</span></span><br><span class="line">	<span class="built_in">cudaFree</span>(d_res);</span><br><span class="line">	<span class="built_in">cudaFree</span>(d_a);</span><br><span class="line">	<span class="built_in">cudaFree</span>(d_b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> cpu_res = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> gpu_res = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> *a = (<span class="type">int</span> *)<span class="built_in">malloc</span>(N * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="type">int</span> *b = (<span class="type">int</span> *)<span class="built_in">malloc</span>(N * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">	{</span><br><span class="line">		a[i] = <span class="number">1</span>;</span><br><span class="line">		b[i] = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先调用CPU计算结果</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	{</span><br><span class="line">		cpu_res += a[i] * b[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n\ncpu res = %d\n\n"</span>, cpu_res);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用GPU对比计算结果</span></span><br><span class="line">	<span class="built_in">doLauncher</span>(&amp;gpu_res, a, b, N);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n\ngpu res = %d\n\n"</span>, gpu_res);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以修改宏ATOMIC来查看使用原子操作和非原子操作的结果。其中原子操作每次都能给出正确结果，而非原子操作每次结果都不一样，且都不正确。</p>
<h2 id="总结">总结</h2>
<ul>
<li>当涉及归约或者其他类型的需要多个线程访问同一个地址时，需要使用原子操作。</li>
</ul>
]]></content>
      <categories>
        <category>CUDA并行程序设计</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA高性能并行计算(8)--CUDA全局内存、共享内存的合理使用</title>
    <url>/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-8/</url>
    <content><![CDATA[<h2 id="cuda全局内存共享内存的合理使用">CUDA全局内存、共享内存的合理使用</h2>
<span id="more"></span>
<h3 id="全局内存与合理使用">全局内存与合理使用</h3>
<p>由于全局内存是GPU内存中容量最大、访问速度最慢的内存，因此对全局内存的关注是十分必要的，只有正确使用全局内存，才能写出高性能的CUDA程序。一般依次传输数据量是32字节。</p>
<p>对全局内存是存在L1、L2高速缓存的，因此访问全局内存首先会经过缓存，如果不命中则执行缺页中断，再从主存中取出。对全局内存的访问有合并和非合并两种方式。</p>
<h4 id="全局内存的合并与非合并访问">全局内存的合并与非合并访问</h4>
<p>合并访问是指一个线程束对全局内存的一次访问申请求所导致的最小数量的数据传输，否则称为非合并访问。</p>
<p>即如果一次请求的数据全部是线程束需要的就是合并访问，否则就是非合并访问。因此合并度可以看作是资源利用率，合并度越高则说明效率越高。</p>
<p>合并度不到100%的原因是因为内存对齐问题，内存对齐在CPU中是非常普遍的现象，<code>malloc</code>分配的内存全部都是内存对齐的，内存对齐也有利于访问速度的提升，此处不再赘诉。在GPU中，全局内存转移到L2缓存的内存是首地址为32字节的整数倍，因此内存首地址需要被对齐到32的整倍数时，即首地址满足<code>addr &amp; ~~(11111b) == 0</code>(低5位位0)才能满足合并度为100%。</p>
<p>使用<code>cudaMalloc()</code>分配的内存地址至少为256的整倍数。</p>
<div class="note primary">
            <p>当读取与写入都是非合并的时候，最好合并写入，因为非合并的读取会被__lgd()优化。</p><p>也可以尝试使用共享内存将非合并转换成合并。</p>
          </div>
<h3 id="共享内存与合理使用">共享内存与合理使用</h3>
<p>前面也提到过，共享内存就是可以被直接编程的缓存，读写速度十分的高，所以很有必要了解其使用。</p>
<h4 id="对大数组求和">对大数组求和</h4>
<p>对一个大数组进行求和与两个大数组相加的编程思路是不一样的，后者只需要定义相同元素个线程然后两两相加即可。对于前者，可能C++语言会编写出如下的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="built_in">array</span>[N]={...};</span><br><span class="line"><span class="type">float</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp; i:<span class="built_in">array</span>)</span><br><span class="line">    result += <span class="built_in">array</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是上述代码没有办法直接转化成并行计算模式。如果数组大小刚好是2的N次幂时，可以将数组每次分成一半，后一半加到前一半上，直到只剩一个元素就是最终结果。下面给出并行计算的核函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __global__ <span class="title">sum_kernel</span><span class="params">(readl *d_x, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n = blockDim.x * blockIdx.x + threadIdx.x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> offset = N&lt;&lt;<span class="number">1</span>; offset &gt; <span class="number">0</span>; offset&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(n &lt; offset )</span><br><span class="line">            d_x[n] += d_x[n + offset];</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是如果想要在并行计算中使用这个方法，需要注意由于每个线程执行顺序是不确定的，因此需要保证当所有线程都完成当前轮迭代后再开启下一轮。</p>
<p>可以使用<code>__syncthreads()</code>函数来进行<strong>同步</strong>，当其不带任何参数时，会等待一个线程块内所有线程束完成后再继续执行。我们此处先简单考虑，假设线程块为128，先将d_x[n]这个大数组每128个元素求和，并保存在d_y[n/128]中，因此可以得到这样一个代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __global__ <span class="title">sum_kernel</span><span class="params">(real *d_x, <span class="type">int</span> N,real *d_y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">    real * x = d_x + blockDim.x * block.x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> offset = N&lt;&lt;<span class="number">1</span>; offset &gt; <span class="number">0</span>; offset&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(tid &lt; offset )</span><br><span class="line">            d_y[tid] += x[tid + offset];</span><br><span class="line">        __syncthreads();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tid == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        d_y[blockIdx.x] = x[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很明显，上述代码需要频繁的访问d_y，且由于d_y位于全局内存中，这样IO速度会慢很多。同时d_y是多个线程合作的结果，所以也不能使用寄存器(既存不下也不能被其他线程访问)，所以此处加速的方法是使用共享内存。</p>
<p><strong>共享内存声明</strong>是使用修饰符<code>__shared__</code>即可，由于每个线程都能访问线程块的共享内存，因此将全局内存数据复制到共享内存中不需要写循环。下面给出代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __global__ <span class="title">sum_kernel</span><span class="params">(real *d_x, <span class="type">int</span> N,real *d_y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">    real * x = d_x + blockDim.x * block.x;</span><br><span class="line">    __shared__ s_y[<span class="number">128</span>];</span><br><span class="line">    s_y[tid] = (n &lt; N) ? d_X[n] : <span class="number">0.0</span>; <span class="comment">// 执行数据的复制，</span></span><br><span class="line">    __syncthreads();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> offset = N&lt;&lt;<span class="number">1</span>; offset &gt; <span class="number">0</span>; offset&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(tid &lt; offset )</span><br><span class="line">            s_y[tid] += s_y[tid + offset];</span><br><span class="line">        __syncthreads();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tid == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        d_y[blockIdx.x] = x[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是这种共享内存的声明是硬编码的方式声明的，可扩展与可移植性不好，下面给出动态共享内存的声明方式。</p>
<p>首先，使用了动态共享内存的核函数必须传递三个参数<code>xxx_kernel&lt;&lt;&lt;gridSize,blockSize,sizof(T)*N&gt;&gt;&gt;(...)</code>，其中第三个参数为声明的共享内存大小，且在核函数内部必须以<code>extern __shared__ T array[];</code>的方式进行声明。</p>
<div class="note primary">
            <p>不能声明成extern <strong>shared</strong> T *array;</p><p>因为指针与数组是不同的，所以这样会编译错误。</p>
          </div>
<div class="note info">
            <p>在设备上使用动态共享内存和静态共享内存是没有明显的性能差距的，所以最好使用动态共享内存。</p>
          </div>
<h4 id="共享内存的bank冲突">共享内存的bank冲突</h4>
<p>在共享内存中，连续的32-bits字被分配到连续的32个bank中，这就像电影院的座位一样：一列的座位就相当于一个bank，所以每行有32个座位，在每个座位上可以“坐”一个32-bits的数据(或者多个小于32-bits的数据，如4个char型的数据，2个short型的数据)；而正常情况下，我们是按照先坐完一行再坐下一行的顺序来坐座位的，在shared
memory中地址映射的方式也是这样的。下图中内存地址是按照箭头的方向依次映射的：</p>
<img src="/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-8/pic1.png" class="">
<p>每个bank内的存储数据是共用一根总线的，所以当有两个及以上的线程需要访问一个bank内的数据时，需要两次总线操作；而所有线程访问不同bank内的数据时，所有的访问都能在一次总线操作，因此bank冲突会导致性能下降。</p>
<h2 id="总结">总结</h2>
<ul>
<li>__syncthreads()函数可以用于线程块内线程同步。</li>
<li>静态共享内存在核函数内使用<code>__shared__</code>修饰符进行修饰。</li>
<li>动态共享内存需要在核函数调用时传递第三个参数<code>xxx_kernel&lt;&lt;&lt;gridSize,blockSize,sizof(T)*N&gt;&gt;&gt;(...)</code>，并且在核函数内声明为<code>extern __shared__ array[];</code></li>
<li>要尽可能避免bank冲突。</li>
</ul>
]]></content>
      <categories>
        <category>CUDA并行程序设计</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧(1)--基本数据结构与算法</title>
    <url>/2022/08/30/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-1/</url>
    <content><![CDATA[<h2 id="基本数据结构与算法----来源于cookbook第一章">基本数据结构与算法----来源于cookbook第一章</h2>
<span id="more"></span>
<p><font color="#dda0a0">记录第一章中比较有意思的部分</font></p>
<hr>
<h3 id="元素分解">元素分解</h3>
<div class="note primary">
            <p>通过<code>*表达式</code>来解包裹实现分解</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)]</span><br><span class="line"></span><br><span class="line">first, *_, (*__, last) = l</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(first,last) <span class="comment"># 1 7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="将字典的键映射到多个值上">将字典的键映射到多个值上</h3>
<div class="note primary">
            <ul><li><p>通过使用<code>collections</code>中的<code>defaultdict</code>来实现一键多值字典</p></li><li><p>通过<code>dict</code>类的<code>setdefault</code>方法来实现</p></li></ul>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">d = defaultdict(<span class="built_in">list</span>) <span class="comment"># 或defaultdict(set)</span></span><br><span class="line">d[<span class="string">'a'</span>].append(<span class="number">1</span>)</span><br><span class="line">d[<span class="string">'a'</span>].append(<span class="number">2</span>)</span><br><span class="line">d[<span class="string">'b'</span>].append(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(d) <span class="comment"># {'a': [1, 2], 'b': [3]}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"></span><br><span class="line">d = {}</span><br><span class="line">d.setdefault(<span class="string">'a'</span>,[]).append(<span class="number">1</span>)</span><br><span class="line">d.setdefault(<span class="string">'a'</span>,[]).append(<span class="number">2</span>)</span><br><span class="line">d.setdefault(<span class="string">'b'</span>,[]).append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(d) <span class="comment"># {'a': [1, 2], 'b': [3]}</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="两个字典的集合运算">两个字典的集合运算</h3>
<div class="note primary">
            <p>字典支持集合运算符，可以对其求交集、并集等</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = {</span><br><span class="line">    <span class="string">'x'</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">'y'</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">'z'</span> : <span class="number">3</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">b={</span><br><span class="line">    <span class="string">'x'</span> : <span class="number">10</span>,</span><br><span class="line">    <span class="string">'w'</span> : <span class="number">11</span>,</span><br><span class="line">    <span class="string">'z'</span> : <span class="number">3</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.keys() &amp; b.keys()) <span class="comment"># {'z', 'x'}</span></span><br><span class="line"><span class="built_in">print</span>(a.keys() - b.keys()) <span class="comment"># {'y'}</span></span><br><span class="line"><span class="built_in">print</span>(a.items() &amp; b.items()) <span class="comment"># {('z', 3)}</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字典推导式">字典推导式</h3>
<div class="note primary">
            <p>感觉字典推导式不如生成器推导式和列表推导式用的多</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">prices = {</span><br><span class="line">    <span class="string">'a'</span> : <span class="number">45</span>,</span><br><span class="line">    <span class="string">'b'</span> : <span class="number">32</span>,</span><br><span class="line">    <span class="string">'c'</span> : <span class="number">10</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">p1 = {key:value <span class="keyword">for</span> key,value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> value &gt;<span class="number">20</span>}</span><br><span class="line"><span class="built_in">print</span>(p1) <span class="comment"># {'a': 45, 'b': 32}</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonCookbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧(10)--并发</title>
    <url>/2023/01/03/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-10/</url>
    <content><![CDATA[<h2 id="并发----来源于cookbook第十二章">并发----来源于cookbook第十二章</h2>
<span id="more"></span>
<p><font color="#daa00d">记录第十二章中比较有意思的部分</font></p>
<hr>
<h3 id="线程与线程池">线程与线程池</h3>
<div class="note primary">
            <p>可以通过python内置库来创建线程执行任务，为了高效，通常是以线程池的方式实现</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#################### 线程 ####################</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"now count <span class="subst">{n}</span>"</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建线程</span></span><br><span class="line">    t = Thread(target=count, args=(<span class="number">10</span>,))</span><br><span class="line">    <span class="comment"># 开启线程</span></span><br><span class="line">    t.start()</span><br><span class="line">    <span class="comment"># 主线程不被阻塞</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"start target, is alive? <span class="subst">{t.is_alive()}</span>"</span>)</span><br><span class="line">    <span class="comment"># 等待线程结束</span></span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment">#################### 线程池 ####################</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">n, <span class="built_in">id</span></span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"<span class="subst">{<span class="built_in">id</span>}</span> now count <span class="subst">{n}</span>"</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建线程池</span></span><br><span class="line">    pool = ThreadPoolExecutor(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 向线程池提交任务</span></span><br><span class="line">    a = pool.submit(count, <span class="number">10</span>, <span class="string">"a"</span>)</span><br><span class="line">    b = pool.submit(count, <span class="number">5</span>, <span class="string">"b"</span>)</span><br><span class="line">    c = pool.submit(count, <span class="number">4</span>, <span class="string">"c"</span>)</span><br><span class="line">    d = pool.submit(count, <span class="number">3</span>, <span class="string">"d"</span>)</span><br><span class="line">    <span class="comment"># 获取任务的返回值</span></span><br><span class="line">    <span class="built_in">print</span>(a.result(), b.result(), c.result(), d.result())</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>在python的线程都是<strong>系统级线程</strong>，想要实现用户级线程需要用yield来实现。</p><p>此处的线程只能设置成守护线程或检测线程是否存活，除此之外的终止线程、向线程发信号、调整线程调度属性的操作都没有，需要自己去构建。</p><p>线程池还可以使用Queue来实现，<strong>Queue的实现是线程安全的</strong>。</p><p>最后，对于线程而言，可以使用<code>Thread.local()</code>来创建<strong>线程私有变量</strong>，主要用于线程需要使用某种系统资源时(如套接字、文件这类)</p>
          </div>
<h3 id="线程的事件条件和信号">线程的事件、条件和信号</h3>
<div class="note primary">
            <p>可以同样使用python的标准库来实现线程中的信号量、事件等功能</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#################### 事件 ####################</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">n, start_env</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"thread start"</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 线程设置事件</span></span><br><span class="line">    start_env.<span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"now count <span class="subst">{n}</span>"</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    start_env = Event()</span><br><span class="line">    t = Thread(target=count, args=(<span class="number">10</span>, start_env))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待事件被设置，会阻塞</span></span><br><span class="line">    start_env.wait()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"now set env"</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment">#################### 条件 ####################</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Condition</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">n, timer</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"thread start"</span>)</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 重复等待信号到来</span></span><br><span class="line">        timer.wait_for_tick()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"now count <span class="subst">{n}</span>"</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, intervel</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._intervel = intervel</span><br><span class="line">        self._flag = <span class="number">0</span></span><br><span class="line">        self._cv = Condition()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        t = Thread(target=self.run)</span><br><span class="line">        t.daemon = <span class="literal">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            sleep(self._intervel)</span><br><span class="line">            <span class="comment"># with的写法是锁的上下文管理协议</span></span><br><span class="line">            <span class="keyword">with</span> self._cv:</span><br><span class="line">                self._flag ^= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 会唤醒所有线程，notify_all本身不会释放锁</span></span><br><span class="line">                self._cv.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wait_for_tick</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># with的写法是锁的上下文管理协议</span></span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            last_flag = self._flag</span><br><span class="line">            <span class="keyword">while</span> last_flag == self._flag:</span><br><span class="line">                <span class="comment"># 调用wait会阻塞线程并释放锁</span></span><br><span class="line">                <span class="comment"># 被唤醒后需要重新请求锁</span></span><br><span class="line">                self._cv.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    timer = Timer(<span class="number">2</span>)</span><br><span class="line">    timer.start()</span><br><span class="line">    Thread(target=count, args=(<span class="number">10</span>, timer)).start()</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment">#################### 信号量 ####################</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Semaphore</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">id_, sema</span>):</span><br><span class="line">    <span class="comment"># 等待信号量</span></span><br><span class="line">    sema.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"<span class="subst">{id_}</span> working"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sema = Semaphore(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        t = Thread(target=worker, args=(i, sema))</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># 释放信号量</span></span><br><span class="line">        sema.release()</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>Event对象最好是<strong>一次性使用</strong>，虽然可以使用<code>clear</code>来清除事件，但是容易造成死锁。</p><p>如果打算<strong>一遍一遍重复通知某个事件</strong>，最好使用Condition对象</p><p>Event可以唤醒所有等待线程，若<strong>只想从中唤醒一个线程</strong>，最好使用信号量或Condition对象</p>
          </div>
<h3 id="线程间通信">线程间通信</h3>
<div class="note primary">
            <p>可以使用queue模块中的Queue对象进行线程间通信，也可以通过锁来手动实现一个多线程队列</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">out_q</span>):</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        env = Event()</span><br><span class="line">        out_q.put((i, env))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        env.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">in_q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        i, env = in_q.get(timeout=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"get <span class="subst">{i}</span>"</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        env.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 可以设置队列容量</span></span><br><span class="line">    q = Queue(<span class="number">10</span>)</span><br><span class="line">    t1 = Thread(target=producer, args=(q,))</span><br><span class="line">    t2 = Thread(target=consumer, args=(q,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>Queue对象可以设置容量，且put和get方法都支持超时机制和阻塞机制</p><p>如果用于多线程，则不要依赖Queue的len、empty这些方法</p>
          </div>
<h3 id="锁">锁</h3>
<div class="note primary">
            <p>可以使用Lock对象来对临界区加锁</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span>  Lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, init_val=<span class="number">0</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._value = init_val</span><br><span class="line">        self._value_lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incr</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 锁存在上下文管理协议，可以直接with使用</span></span><br><span class="line">        <span class="keyword">with</span> self._value_lock:</span><br><span class="line">            self._value += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decr</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> self._value_lock:</span><br><span class="line">            self._value -= <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>除了基本的Lock对象外，还有RLock可重入锁。</p>
          </div>
<h3 id="section"></h3>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonCookbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧(11)--Python调用C/C++动态链接库</title>
    <url>/2023/01/08/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-11/</url>
    <content><![CDATA[<h2 id="python调用cc动态链接库----来源于cookbook第十五章">Python调用C/C++动态链接库----来源于cookbook第十五章</h2>
<span id="more"></span>
<p><font color="#0d0aad">记录第十五章中比较有意思的部分</font></p>
<hr>
<h3 id="使用ctypes来从python中调用cc的动态链接库">使用ctypes来从python中调用C/C++的动态链接库</h3>
<div class="note primary">
            <p>将C/C++代码编译成动态链接库，然后使用Python的ctypes模块加以调用，从而提升整体执行效率。</p><p>其中C/C++函数原型主要有以下几种主要的形式，分别对应不同的调用方法：</p><ul><li>仅常规类型，无指针</li><li>包含指针的常规类型，或使用指针实现多返回值</li><li>C数组</li><li>结构体</li></ul>
          </div>
<p>假设有以下的C函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 仅常规类型，无指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">funa</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含指针的常规类型，或使用指针实现多返回值</span></span><br><span class="line"><span class="comment">/* 假设 y 是第二个返回值 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">funb</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> *y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C数组</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">func</span><span class="params">(<span class="type">double</span> *a ,<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">}</span><br><span class="line"><span class="type">double</span> <span class="title function_">fund</span><span class="params">(Point *x, Point *y)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>且上述的函数被编译成动态链接库<code>func.dll</code>，那么在Python中需要按照以下方法来调用对应函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先加载动态链接库</span></span><br><span class="line">dll = ctypes.cdll.LoadLibrary(<span class="string">"func.dll"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅常规类型，无指针</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funa_warp</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="comment"># 从dll中获取到函数</span></span><br><span class="line">    funa = dll.funa</span><br><span class="line">    <span class="comment"># 给定函数原型</span></span><br><span class="line">    funa.argtypes = (ctypes.c_int, ctypes.c_double)</span><br><span class="line">    <span class="comment"># 函数返回值</span></span><br><span class="line">    funa.restype = ctypes.c_int</span><br><span class="line">    <span class="comment"># 调用</span></span><br><span class="line">    <span class="keyword">return</span> funa(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含指针的常规类型，或使用指针实现多返回值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funb_warp</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="comment"># 从dll中获取到函数</span></span><br><span class="line">    funb = dll.funb</span><br><span class="line">    <span class="comment"># 给定函数原型，注意指针类型</span></span><br><span class="line">    funb.argtypes = (ctypes.c_int, ctypes.POINTER(ctypes.c_double))</span><br><span class="line">    <span class="comment"># 返回值</span></span><br><span class="line">    funb.restype = ctypes.c_int</span><br><span class="line">    <span class="comment"># 准备好指针返回值</span></span><br><span class="line">    rem = ctypes.c_double()</span><br><span class="line">    <span class="comment"># 调用函数并计算出返回值</span></span><br><span class="line">    res = funb(x, rem)</span><br><span class="line">    <span class="comment"># 返回所有返回值</span></span><br><span class="line">    <span class="keyword">return</span> res, rem.value</span><br><span class="line"></span><br><span class="line"><span class="comment"># C数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_warp</span>(<span class="params">list_</span>):</span><br><span class="line">    <span class="comment"># 从dll中获取到函数</span></span><br><span class="line">    func = dll.func</span><br><span class="line">    <span class="comment"># 给定函数原型</span></span><br><span class="line">    <span class="comment"># 构造一个C数组类型，前面括号是类型转换，后面是变长参数</span></span><br><span class="line">    val = ((ctypes.c_double) * <span class="built_in">len</span>(list_))(*list_)</span><br><span class="line">    func.argtypes = (val, ctypes.c_int)</span><br><span class="line">    <span class="comment"># 返回值</span></span><br><span class="line">    func.restype = ctypes.c_double</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> func(val, <span class="built_in">len</span>(list_))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要先构造出契合结构体的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [(<span class="string">'x'</span>, ctypes.c_double),</span><br><span class="line">                (<span class="string">'y'</span>, ctypes.c_double)]</span><br><span class="line"><span class="comment"># 然后开始包装函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fund_warp</span>(<span class="params">p1, p2</span>):</span><br><span class="line">    <span class="comment"># 从dll中获取到函数</span></span><br><span class="line">    fund = dll.fund</span><br><span class="line">    <span class="comment"># 给定函数原型，注意指针类型</span></span><br><span class="line">    fund.argtypes = (ctypes.POINTER(Point), ctypes.POINTER(Point))</span><br><span class="line">    <span class="comment"># 返回值</span></span><br><span class="line">    fund.restype = ctypes.c_double</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fund(p1, p2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>除此之外，还有比如指针数组、结构体指针数组等等比较复杂的东西，当时使用的相对比较少。</p>
          </div>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonCookbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧(2)--字符串与文本</title>
    <url>/2022/08/30/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-2/</url>
    <content><![CDATA[<h2 id="字符串与文本----来源于cookbook第二章">字符串与文本----来源于cookbook第二章</h2>
<span id="more"></span>
<p><font color="#a0dda0">记录第二章中比较有意思的部分</font></p>
<hr>
<div class="note info">
            <p>其实这一章讲的方法挺多挺杂的，但是日常使用基本就正则和python自带的字符串方法，其他的感觉用不到的样子。</p><p>正则的话平时写多了自然就会了，这里就不记录了</p>
          </div>
<h3 id="字符串开头结尾文本匹配">字符串开头结尾文本匹配</h3>
<div class="note primary">
            <p>使用<code>str.startswith()</code>和<code>str.endwith()</code>即可。在写文件批处理脚本的时候用得到。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">files = [<span class="string">'a.h'</span>,<span class="string">'a.c'</span>,<span class="string">'a.exe'</span>]</span><br><span class="line">selected = [file <span class="keyword">for</span> file <span class="keyword">in</span> files <span class="keyword">if</span> file.endswith((<span class="string">".h"</span>,<span class="string">".c"</span>))]</span><br><span class="line"><span class="built_in">print</span>(selected) <span class="comment"># ['a.h', 'a.c']</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字符串去除首尾不需要的字符">字符串去除首尾不需要的字符</h3>
<div class="note primary">
            <p>使用<code>str.lstrip()</code>和<code>str.rstrip()</code>即可</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">s = <span class="string">'-=-=hellp-=-world-=-=-='</span></span><br><span class="line">s = s.lstrip(<span class="string">"-="</span>)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment"># 'hellp-=-world-=-=-='</span></span><br><span class="line">s = s.rstrip(<span class="string">"-="</span>)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment"># 'hellp-=-world'</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字符串拼接">字符串拼接</h3>
<div class="note primary">
            <p><code>+</code>：效率最低，但是简单</p><p><code>join</code>：效率高，支持列表等</p><p><code>print(*args,sep=",")</code>：容易被遗忘的一种方法</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">','</span>.join(<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> [a,b,c])) <span class="comment"># 1,2,3</span></span><br><span class="line"><span class="built_in">print</span>(a,b,c,sep=<span class="string">","</span>) <span class="comment"># 1,2,3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="给字符串中变量名做插值">给字符串中变量名做插值</h3>
<div class="note primary">
            <p>作者在书中提到python没法直接处理字符串插值，并实现了一些复杂的方法，<br>幸运的是，新版本的python已经直接支持插值了，不需手动去实现了</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">name = <span class="string">'book'</span></span><br><span class="line">price = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"<span class="subst">{name}</span>' price is <span class="subst">{price}</span>"</span>) <span class="comment"># book' price is 10</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonCookbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧(3)--处理数字、时间和日期</title>
    <url>/2022/08/30/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-3/</url>
    <content><![CDATA[<h2 id="处理数字时间和日期----来源于cookbook第三章">处理数字、时间和日期----来源于cookbook第三章</h2>
<span id="more"></span>
<p><font color="#a0a0dd">记录第三章中比较有意思的部分</font></p>
<hr>
<h3 id="精确的小数计算">精确的小数计算</h3>
<div class="note primary">
            <p>使用<code>decimal</code>中的<code>Decimal</code>类就可以实现精确小数计算，而避免引入浮点数误差。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统浮点数会引入误差</span></span><br><span class="line">a = <span class="number">4.2</span></span><br><span class="line">b = <span class="number">2.1</span></span><br><span class="line"><span class="built_in">print</span>(a + b) <span class="comment"># 6.300000000000001</span></span><br><span class="line"><span class="built_in">print</span>(a + b == <span class="number">6.3</span>) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Decimal</span></span><br><span class="line">a = Decimal(<span class="string">'4.2'</span>)</span><br><span class="line">b = Decimal(<span class="string">'2.1'</span>)</span><br><span class="line"><span class="built_in">print</span>(a + b) <span class="comment"># 6.3</span></span><br><span class="line"><span class="built_in">print</span>(a + b == Decimal(<span class="string">'6.3'</span>)) <span class="comment"># True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="精确的分数计算">精确的分数计算</h3>
<div class="note primary">
            <p>使用<code>fractions</code>中的<code>Fraction</code>可以精确的计算分数</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"></span><br><span class="line">a = Fraction(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">b = Fraction(<span class="number">7</span>,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(a + b) <span class="comment"># 27/16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="numpy的matrix与array在处理矩阵上的微妙区别">numpy的matrix与array在处理矩阵上的微妙区别</h3>
<div class="note primary">
            <p><code>matrix</code>是矩阵，而<code>array</code>主要是数组，两者在运算上存在一些区别</p><ul><li><p>首先array的<code>*</code>，<code>**</code>都是点乘，其矩阵乘法需要使用<code>np.dot()</code></p></li><li><p>而matrix的<code>*</code>，<code>**</code>都是矩阵乘法，其点乘需要用到<code>np.multiply()</code></p></li><li><p>matrix求逆可以直接<code>.I</code>，而array求逆需要使用<code>np.linalg.inv()</code></p></li></ul>
          </div>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonCookbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧(4)--迭代器</title>
    <url>/2022/08/30/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-4/</url>
    <content><![CDATA[<h2 id="迭代器----来源于cookbook第四章">迭代器----来源于cookbook第四章</h2>
<span id="more"></span>
<p><font color="#add0a0">记录第四章中比较有意思的部分</font></p>
<hr>
<h3 id="实现容器的委托迭代">实现容器的委托迭代</h3>
<div class="note primary">
            <p>只需要为容器实现<code>__iter__</code>魔法方法即可。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">        self._value = value</span><br><span class="line">        self._children = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node({!r})"</span>.<span class="built_in">format</span>(self._value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_child</span>(<span class="params">self,value</span>):</span><br><span class="line">        self._children.append(value)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self._children)</span><br><span class="line"></span><br><span class="line">a = Node(<span class="string">"list"</span>)</span><br><span class="line">a.append(<span class="number">1</span>)</span><br><span class="line">a.append(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">""</span>) <span class="comment">## 12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="简单的方法实现迭代协议">简单的方法实现迭代协议</h3>
<div class="note primary">
            <p>使用<code>yield from</code>即可</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    <span class="comment"># 注意，此处yield出去的仍然是一个迭代器，</span></span><br><span class="line">    <span class="keyword">yield</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> x <span class="keyword">if</span> i &gt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">a = gen()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment"># &lt;generator object gen.&lt;locals&gt;.&lt;genexpr&gt; at 0x000001C6FC019D60&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_good</span>():</span><br><span class="line">    x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    <span class="comment"># 此时yield出去的是我们需要的整数</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> x <span class="keyword">if</span> i &gt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">a = gen()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment"># 4 5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="反向迭代">反向迭代</h3>
<div class="note primary">
            <p>只需要实现<code>__reversed__()</code>方法即可，实现反向迭代后的效率更高</p>
          </div>
<h3 id="迭代器切片">迭代器切片</h3>
<div class="note primary">
            <p>使用<code>itertools</code>的<code>islice()</code>方法即可</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> islice(gen(),<span class="number">10</span>,<span class="number">20</span>):</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment"># 10....19</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是注意，islice会消耗掉迭代器，所以没法倒回去访问数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="以索引-值的形式迭代序列">以索引-值的形式迭代序列</h3>
<div class="note primary">
            <p>使用<code>enumerate()</code>即可</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">    <span class="built_in">print</span>(index,word) <span class="comment"># 0 a  1 b  2 c</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="同时迭代多个序列">同时迭代多个序列</h3>
<div class="note primary">
            <p>使用<code>zip()</code>函数即可，其返回一个迭代器，长度是参数中较短的一个</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(a,b):</span><br><span class="line">    <span class="built_in">print</span>(x,y) <span class="comment"># 1 4  2 5  3 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="在多个容器中进行迭代">在多个容器中进行迭代</h3>
<div class="note primary">
            <p>使用<code>itertools</code>的<code>chain()</code>函数即可，可以逐个迭代多个容器</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> chain(a,b):</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment"># 1 2 3 4 5 6 7</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用迭代器取代while循环">使用迭代器取代while循环</h3>
<div class="note primary">
            <p><code>iter(func,sentinal)</code>可以一直调用无参函数func直到其返回哨兵值sentinal为止</p><p>这样就可以将while循环转换成迭代器模式</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">times = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    <span class="keyword">global</span> times</span><br><span class="line">    <span class="keyword">if</span> times==<span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    times +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">iter</span>(gen,-<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonCookbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧(5)--文件和IO</title>
    <url>/2022/09/02/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-5/</url>
    <content><![CDATA[<h2 id="文件和io----来源于cookbook第五章">文件和IO----来源于cookbook第五章</h2>
<span id="more"></span>
<p><font color="#a0add0">记录第五章中比较有意思的部分</font></p>
<hr>
<h3 id="open函数打开文件的小技巧">open函数打开文件的小技巧</h3>
<div class="note primary">
            <p>由于有些文件中会出现编码错误或与当前主机不匹配，使用<code>open</code>函数时可以增加<code>errors='ignore'</code>来忽略掉错误的编码。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">g = <span class="built_in">open</span>(<span class="string">"somefile.txt"</span>, <span class="string">'rt'</span>, encoding = <span class="string">'utf-8'</span>, errors = <span class="string">'ignore'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用print函数重定向到文件">使用print函数重定向到文件</h3>
<div class="note primary">
            <p>使用<code>print</code>函数的<code>file = handler</code>参数即可</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">'3'</span>,(<span class="number">4</span>,<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"file"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(*l, sep = <span class="string">','</span>, file = f)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="对不存在的文件进行写入操作">对不存在的文件进行写入操作</h3>
<div class="note primary">
            <p>直接使用<code>xt</code>模式来操作文件即可</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"somefile"</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f: <span class="comment"># 当somefile不存在时会报错</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"somefile"</span>, <span class="string">'xt'</span>) <span class="keyword">as</span> f: <span class="comment"># 当somefile不存在时会创建，存在时不影响</span></span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="将二进制文件做内存映射">将二进制文件做内存映射</h3>
<div class="note primary">
            <p>使用<code>mmap</code>模块来创建映射，这样可以直接访问，而不需要频繁的seek、read等操作。</p><p>另外，由于虚拟内存的存在，多个python解释器可以映射到同一个文件上从而实现共享数据。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">memory_map</span>(<span class="params">filename, access = mmap.ACCESS_WRITE</span>):</span><br><span class="line">    size = os.path.getsize(filename)</span><br><span class="line">    fd = os.<span class="built_in">open</span>(filename, os.O_RDWR)</span><br><span class="line">    <span class="keyword">return</span> mmap.mmap(fd, size, access = access)</span><br><span class="line"></span><br><span class="line">m = memory_map(<span class="string">"data"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时就可以像操作数组那样操作m</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(m))</span><br><span class="line"><span class="built_in">print</span>(m[:<span class="number">34</span>])</span><br><span class="line">m[:<span class="number">11</span>] = <span class="string">b'hello world'</span></span><br><span class="line">m.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="将字节数据写入文本文件">将字节数据写入文本文件</h3>
<div class="note primary">
            <p>只需要简答的将字节数据写入到文件底层buffer中就可以了。</p>
          </div>
<div class="note warning">
            <p>在python中调用print时，事实上调用了sys.stdout.write(obj+'\n')</p><p>而stdout就像是一个类文件对象，因为你可以将他赋值给任意的一个文件对象，重定向输出</p><p>原始的sys.stdout指向控制台，如果把文件的对象引用赋给sys.stdout，那么print调用的就是文件对象的write方法</p><p>而buffer是缓冲区，所以此操作就是不调用上层的write方法而直接写入底层的缓冲区</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 示例一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.stdout.buffer.write(<span class="string">b'hello\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例二</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.stdout = <span class="built_in">open</span>(<span class="string">"filename"</span>,<span class="string">"xt"</span>)</span><br><span class="line"></span><br><span class="line">sys.stdout.buffer.write(<span class="string">b'hello\n'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="创建临时文件与文件夹">创建临时文件与文件夹</h3>
<div class="note primary">
            <p><code>tempfile</code>模块中有各种实现了上下文管理协议的函数来处理临时文件</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryFile</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> TemporaryFile(<span class="string">'w+t'</span>, encoding = <span class="string">'utf-8'</span>, errors = <span class="string">'ignore'</span>, delete = <span class="literal">True</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="序列化python对象">序列化python对象</h3>
<div class="note primary">
            <p><code>pickle</code>模块的dump和load函数就足以处理这些</p>
          </div>
<div class="note warning">
            <p>注意不要对来源不明的对象进行load，因为这会产生副作用，严重甚至可能导致计算机被入侵。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"filename"</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(a,f)</span><br><span class="line">    ...</span><br><span class="line">    pickle.load(a,f)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonCookbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧(6)--函数</title>
    <url>/2022/09/12/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-6/</url>
    <content><![CDATA[<h2 id="函数----来源于cookbook第七章">函数----来源于cookbook第七章</h2>
<span id="more"></span>
<p><font color="#a0dad0">记录第七章中比较有意思的部分</font></p>
<hr>
<h3 id="只接受关键词参数的函数">只接受关键词参数的函数</h3>
<div class="note primary">
            <p>关键词参数放在*打头的参数后面或者放在一个单独的*后面即可</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, *args, y</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, *, y</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">func(<span class="number">10</span>, y = <span class="number">20</span>) <span class="comment"># 调用func</span></span><br><span class="line">func(<span class="number">10</span>, <span class="number">20</span>) <span class="comment"># 错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="默认参数的问题">默认参数的问题</h3>
<div class="note primary">
            <p>python函数的默认参数只会被初始化一次，所以只能赋值给不可变对象。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">_no_value = <span class="built_in">object</span>() <span class="comment"># 元类来构建出一个表示没有参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意不传递参数和传递None的区别</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> b <span class="keyword">is</span> _no_value:</span><br><span class="line">        b = []</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是一个错误示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">l = []</span>): <span class="comment"># 请务必不要这么做</span></span><br><span class="line">    l.append(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line">func() <span class="comment"># 输出[1]</span></span><br><span class="line">func() <span class="comment"># 输出[1, 1]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="匿名函数的一些问题">匿名函数的一些问题</h3>
<div class="note primary">
            <p>匿名函数即lambda函数，<strong>请时刻记住匿名函数是懒惰求值的</strong>。</p><p>要固定下匿名函数中使用的参数，<strong>必须在匿名函数参数列表中确定</strong>。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">示例一 懒惰求值</span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">1</span></span><br><span class="line">a = <span class="keyword">lambda</span> x:x+y</span><br><span class="line"><span class="built_in">print</span>(a(<span class="number">20</span>)) <span class="comment"># 21 </span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a(<span class="number">20</span>)) <span class="comment"># 22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例二 绑定变量，此时y的值被定下来了</span></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">1</span></span><br><span class="line">a = <span class="keyword">lambda</span> x, y=y:x+y</span><br><span class="line"><span class="built_in">print</span>(a(<span class="number">20</span>)) <span class="comment"># 21 </span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a(<span class="number">20</span>)) <span class="comment"># 21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例三 列表推导式</span></span><br><span class="line">funs = [<span class="keyword">lambda</span> x:x+n <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> funs:</span><br><span class="line">    <span class="built_in">print</span>(f(<span class="number">0</span>)) <span class="comment"># 4 4 4 4 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例四 列表推导式2</span></span><br><span class="line">funs = [<span class="keyword">lambda</span> x,n=n:x+n <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> funs:</span><br><span class="line">    <span class="built_in">print</span>(f(<span class="number">0</span>)) <span class="comment"># 0 1 2 3 4 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="固定多个参数的函数的某些参数">固定多个参数的函数的某些参数</h3>
<div class="note primary">
            <p>可以使用<code>functools</code>中的<code>partial()</code>工厂方法来实现。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b,c,d</span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b,c,d)</span><br><span class="line"></span><br><span class="line">func2 = partial(func, <span class="number">1</span>) <span class="comment"># 即a = 1</span></span><br><span class="line">func3 = partial(func, <span class="number">1</span>, <span class="number">2</span>, d =<span class="number">4</span>) <span class="comment"># 即a = 1, b = 2, d = 4</span></span><br><span class="line"></span><br><span class="line">func2(-<span class="number">2</span>,-<span class="number">3</span>,-<span class="number">4</span>) <span class="comment"># 1 -2 -3 -4</span></span><br><span class="line">func3(-<span class="number">3</span>) <span class="comment"># 1 2 -3 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>可以使用此方法将参数数目不兼容的代码组合到一起。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">points = [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>)] <span class="comment"># 点集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">p1,p2</span>): <span class="comment"># 求两点距离</span></span><br><span class="line">    <span class="keyword">return</span> math.hypot(p1[<span class="number">0</span>]-p2[<span class="number">0</span>],p1[<span class="number">1</span>]-p2[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">points.sort(key = partial(distance,(<span class="number">0</span>,<span class="number">0</span>))) <span class="comment"># 对点集求两点距离</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="闭包与单个函数的类">闭包与单个函数的类</h3>
<div class="note primary">
            <p>可以用闭包的工厂方法来代替只有单个函数的类。因为引入类的作用就是为了保存在类内可以使用的固定参数。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">template</span>(<span class="params">template</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">opener</span>(<span class="params">*args</span>):</span><br><span class="line">        <span class="keyword">return</span> template.<span class="built_in">format</span>(args)</span><br><span class="line">    <span class="keyword">return</span> opener</span><br><span class="line"></span><br><span class="line">func = template(<span class="string">"{} is {}"</span>) <span class="comment"># 将常量保存在func内部</span></span><br><span class="line">func(args)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="闭包但是可以修改参数">闭包，但是可以修改参数</h3>
<div class="note primary">
            <p>上述的闭包只是将传递的参数作为常量来使用，现在我们需要修改它，比如计数功能。</p><p>只需要在内层的函数内使用<code>nonlocal</code>关键字即可</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle</span>():</span><br><span class="line">    seq = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_handle</span>(<span class="params">result</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> seq</span><br><span class="line">        seq+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"<span class="subst">{seq}</span> : <span class="subst">{result}</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> inner_handle</span><br><span class="line"></span><br><span class="line">h = handle()</span><br><span class="line">h(<span class="string">"first"</span>) <span class="comment"># 1 : first</span></span><br><span class="line">h(<span class="string">"second"</span>) <span class="comment"># 2 : second</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="协程与回调函数">协程与回调函数</h3>
<div class="note primary">
            <p>可以利用yield关键字中断发送和接受数据的方式来构造协程。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 示例一 : 重写可以修改参数的闭包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle</span>():</span><br><span class="line">    seq = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        result = <span class="keyword">yield</span></span><br><span class="line">        seq += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"<span class="subst">{seq}</span> : <span class="subst">{result}</span>"</span>)</span><br><span class="line"></span><br><span class="line">h = handle()</span><br><span class="line"><span class="built_in">next</span>(h) <span class="comment"># 让协程执行到yield上</span></span><br><span class="line">h.send(<span class="string">"first"</span>) <span class="comment"># 1 : first</span></span><br><span class="line">h.send(<span class="string">"second"</span>) <span class="comment"># 2 : second</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例二 : 一个比较复杂的内联回调函数</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_async</span>(<span class="params">func, args, *, callback</span>): <span class="comment"># 这个是回调函数本身</span></span><br><span class="line">    result = func(*args)</span><br><span class="line">    callback(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Async</span>: <span class="comment"># 一个保存函数和参数的类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func, args</span>):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inline_async</span>(<span class="params">func</span>): <span class="comment"># 一个装饰器</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">warpper</span>(<span class="params">*args</span>):</span><br><span class="line">        f = func(*args) <span class="comment"># 先拿到生成器</span></span><br><span class="line">        <span class="built_in">print</span>(f)</span><br><span class="line">        result_queue = Queue() <span class="comment"># 创建一个队列</span></span><br><span class="line">        result_queue.put(<span class="literal">None</span>) <span class="comment"># 队列初始值为None</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            result = result_queue.get() <span class="comment"># 获取队列中的值</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                a = f.send(result) <span class="comment"># 然后把值发送给生成器，同时接受到值</span></span><br><span class="line">                <span class="comment"># 下面把计算结果发送到队列中</span></span><br><span class="line">                apply_async(a.func, a.args, callback = result_queue.put)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> warpper</span><br><span class="line"></span><br><span class="line"><span class="comment">## 应用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"><span class="meta">@inline_async</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    r = <span class="keyword">yield</span> Async(add,(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line">    r = <span class="keyword">yield</span> Async(add,(<span class="string">"hello "</span>, <span class="string">"world"</span>))</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>这个例子感觉有些复杂，但其实它使用装饰器后可以简化在业务逻辑(test()函数)中处理回调函数(不然就得写成apply_async(add,(2,3),callback= ...)这种东西，需要手动去管理回调函数)</p><p>实现的原理是利用yield来获取到调用的函数和参数(被通过一个类封装了)，然后执行计算、回调等任务，再使用send方法把这个值发送到业务逻辑中。</p>
          </div>
<h3 id="访问在闭包内的变量">访问在闭包内的变量</h3>
<div class="note primary">
            <p>一般来说闭包内的变量不太好被外界给访问和修改，但是我们可以创建存取函数来实现。</p><p>因为python中一切皆对象，所以闭包就可以当作轻量级的类来用。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closure</span>():</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"n = <span class="subst">{n}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_</span>():</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_</span>(<span class="params">value</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> n</span><br><span class="line">        n = value</span><br><span class="line"></span><br><span class="line">    func.getn = get_</span><br><span class="line">    func.setn = set_</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">f = closure()</span><br><span class="line">f() <span class="comment"># 0</span></span><br><span class="line">f.get() <span class="comment"># 0</span></span><br><span class="line">f.<span class="built_in">set</span>(<span class="number">10</span>) </span><br><span class="line">f.get() <span class="comment"># 10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>这个结构基本上就是一个类了，但是其运行速度会更快，更加轻量级。</p>
          </div>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonCookbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧(7)--类的技巧(其一)</title>
    <url>/2022/11/06/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-7/</url>
    <content><![CDATA[<h2 id="类----来源于cookbook第八章">类----来源于cookbook第八章</h2>
<span id="more"></span>
<p><font color="#ad0d0a">记录第八章中比较有意思的部分</font></p>
<hr>
<h3 id="示例的字符串表示">示例的字符串表示</h3>
<div class="note primary">
            <p>定义魔法方法<code>__repr__(self)</code>和<code>__str__(self)</code></p><p>其中前者尽可能描述<code>eval(repr(x)) == x</code>，后者描述一下该对象的作用</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x : <span class="built_in">int</span> = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"{0.x}"</span>.<span class="built_in">format</span>(self)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>格式化代码{0.x}用于指代0的属性x</p><p>"{0.x}".format(self)中0的含义就是self</p>
          </div>
<h3 id="让类直接参与format格式化">让类直接参与format格式化</h3>
<div class="note primary">
            <p>定义魔法方法<code>__format__(self, code)</code>即可</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__format__</span>(<span class="params">self, code</span>):</span><br><span class="line">        code = <span class="string">"the x is {}"</span> <span class="keyword">if</span> code == <span class="string">""</span> <span class="keyword">else</span> code</span><br><span class="line">        <span class="keyword">return</span> code.<span class="built_in">format</span>(self.x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = Data()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(d)) <span class="comment"># 'the x is 1'</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="上下文管理协议">上下文管理协议</h3>
<div class="note primary">
            <p>定义魔法方法<code>__enter__(self)</code>和<code>__exit__(self, exc_ty, exc_val, tb)</code>即可</p><ul><li>当遇到<code>with</code>语句时，<code>__enter__()</code>首先被触发，其返回值会被放在<code>with..as..</code>中的<code>as</code>里</li><li>然后开始执行<code>with</code>之中的代码</li><li>最后<code>__exit__()</code>函数被调用用于清理，其三个参数分别代表异常类型、异常值和对挂起的异常的追溯。当它返回<code>True</code>时，表示异常已经被清理干净</li></ul>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Con</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"enter !"</span>)</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_ty, exc_val, tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(exc_ty, exc_val, tb)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"exit !"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Con() <span class="keyword">as</span> c:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">"end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"test over"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># enter !</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># &lt;class 'Exception'&gt; end &lt;traceback object at 0x00000169C1261D80&gt;</span></span><br><span class="line"><span class="comment"># exit !</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="节省内存的方法">节省内存的方法</h3>
<div class="note primary">
            <p>只需要为类中增加<code>__slot__</code>这个类属性，就能大大减少内存占用</p><p>当存在这个属性的时候，会使用一种更加紧凑的方式进行表示，不再为每个实例创建__dict__字典，而是一个固定长度的小数组</p><p><strong>所以只要包含这个属性，就没法动态为类增加删除属性</strong></p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>:</span><br><span class="line">    __slots__ = [<span class="string">"year"</span>, <span class="string">"month"</span>, <span class="string">"day"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, year, month, day</span>):</span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day <span class="comment"># 这里的属性名要和__slots__的一致</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="可管理的属性">可管理的属性</h3>
<div class="note primary">
            <p>使用<code>@property</code>来管理一个属性，可以为值的获取、修改和删除增加额外的限制</p><p>此时这个类方法已经类似于属性了，不能被调用</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first</span>):</span><br><span class="line">        self.first = first <span class="comment"># 注意这里和下面的属性的区别</span></span><br><span class="line">        <span class="comment"># 此处用first的目的是为了保证在初始化时也能被类型检查</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">first</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"get !"</span>)</span><br><span class="line">        <span class="keyword">return</span> self._first</span><br><span class="line"></span><br><span class="line"><span class="meta">    @first.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">first</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"set !"</span>)</span><br><span class="line">        self._first = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @first.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">first</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"delete !"</span>)</span><br><span class="line">        <span class="keyword">del</span> self._first</span><br><span class="line"></span><br><span class="line">a = Data(<span class="number">123</span>) <span class="comment"># set !</span></span><br><span class="line"><span class="built_in">print</span>(a.first) <span class="comment"># get ! \n 123</span></span><br><span class="line">a.first = <span class="number">1</span> <span class="comment"># set !</span></span><br><span class="line"><span class="keyword">del</span> a.first <span class="comment"># delete !</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>注意类中__init__中的初始化的方式，如果不这样写，会导致在初始化时不进行检查</p><p>本质是将一系列方法绑定到一起，property的属性fget, fset,fdel分别对应了绑定的方法</p>
          </div>
<h3 id="super调用父类的方法">super调用父类的方法</h3>
<div class="note primary">
            <p>使用<code>super()</code>函数来调用父类的方法</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"A init"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pri</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"A"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"B init"</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pri</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"B"</span>)</span><br><span class="line">        <span class="built_in">super</span>().pri()</span><br><span class="line"></span><br><span class="line">b = B() <span class="comment"># B init \n A init</span></span><br><span class="line">b.pri() <span class="comment"># B \n A</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p><code>super()</code>函数可以避免多态继承时重复调用父类构造函数的问题。</p><p>其本质是基于方法解析顺序表(MRO)，MRO将多个构造函数线性排列，可以使用<code>class.__mro__</code>查看</p>
          </div>
<div class="note info">
            <p><code>super()</code>函数本身可以带两个参数，具体而言为<code>super(subclass, self)</code>，含义为搜索<code>subclass</code>的父类，并返回父类的代理对象，而<code>self</code>这是在调用代理对象的方式时被传递。</p><p>比如一般都是这样调用<code>super(subclass, self).method()</code>，这会调用<code>subclass</code>的父类的<code>method</code>方法，且将<code>self</code>传递进去。</p>
          </div>
<h3 id="描述符">描述符</h3>
<div class="note primary">
            <p>可以使用描述符来设计一种通用的数据结构，且可以对数据进行检查</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, cls</span>):</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"not a int"</span>)</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self, instance</span>):</span><br><span class="line">        <span class="keyword">del</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    x = Integer(<span class="string">"x"</span>)</span><br><span class="line">    y = Integer(<span class="string">"y"</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>描述符定义就像上面<code>Integer</code>所示，感觉有点奇怪，下面进行解释。</p><p>首先注意到在使用描述符的类中(此处为<code>Point</code>类)，<strong>变量声明不是位于任何函数中，而是在类中声明，即在类的层次上定义</strong>。</p><p>对于一个实例<code>p = Point(1,2)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">p.x  <span class="comment"># 等价于调用Point.x.__get__(p, Point)</span></span><br><span class="line"></span><br><span class="line">Point.x <span class="comment">#等价于调用Point.x.__get__(None, Point)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为可以看到，从类中调用描述符和从实例中调用描述符，传入的<code>instance</code>变量是不同的；且这两者调用从功能上来说也本应该是不同的(从类中调用没有实际意义，因为变量还没被初始化)，所以在<code>get</code>和<code>set</code>中的处理方法也是不同的</p>
          </div>
<h3 id="属性惰性求值">属性惰性求值</h3>
<div class="note primary">
            <p>本质上是利用描述符中类调用和实例调用存在差异的特性来实现的</p><p>即利用一个属性重写同名方法</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lazy</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, cls</span>):</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = self.func(instance)</span><br><span class="line">            <span class="comment"># 关键在这里，用一个属性重写了同名的函数</span></span><br><span class="line">            <span class="built_in">setattr</span>(instance, self.func.__name__, value)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, r</span>):</span><br><span class="line">        self.r = r</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @lazy</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"computing..."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span>*self.r**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">c = circle(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(c.r) <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(c.__dict__) <span class="comment"># {'r': 2}</span></span><br><span class="line"><span class="built_in">print</span>(c.area) <span class="comment"># computing... \n12.56</span></span><br><span class="line"><span class="built_in">print</span>(c.__dict__) <span class="comment"># {'r': 2, 'area': 12.56}</span></span><br><span class="line"><span class="built_in">print</span>(c.area) <span class="comment"># 12.56</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="纯虚基类">纯虚基类</h3>
<div class="note primary">
            <p>使用<code>abc</code>模块的<code>ABCMeta</code>、<code>abstractmethod</code>来实现</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IStream</span>(metaclass = ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, maxbytes = -<span class="number">1</span></span>):</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self, data</span>):</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p><code>abstractmethod</code>可以跟其他装饰器一起使用，但是必须是<code>abstractmethod</code>紧靠函数</p>
          </div>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonCookbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧(8)--类的技巧(其二)</title>
    <url>/2022/12/13/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-8/</url>
    <content><![CDATA[<h2 id="类----来源于cookbook第八章">类----来源于cookbook第八章</h2>
<span id="more"></span>
<p><font color="#d0ad0a">记录第八章中比较有意思的部分</font></p>
<hr>
<h3 id="强制类型检查">强制类型检查</h3>
<div class="note primary">
            <p>可以使用描述符和MIXIN类的方式来对其进行检查。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 先创建一个描述符类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Descriptor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="literal">None</span>, **opts</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> opts.items():</span><br><span class="line">            <span class="built_in">setattr</span>(self, key, value)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面创建出用来类型检查的的二级基类，也不应实例化，本质还是描述符</span></span><br><span class="line"><span class="comment"># 这些类不应该被实例化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Typed</span>(<span class="title class_ inherited__">Descriptor</span>):</span><br><span class="line">    <span class="comment"># 在赋值的时候会检查类型是否相符</span></span><br><span class="line">    expected_type = <span class="built_in">type</span>(<span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, expected_type):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"expected "</span> + <span class="built_in">str</span>(self.expected_type))</span><br><span class="line">        <span class="built_in">super</span>().__set__(instance, value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Unsigned</span>(<span class="title class_ inherited__">Descriptor</span>):</span><br><span class="line">    <span class="comment"># 继承自描述符类，改写set方法，用来赋值时检查值是否大于0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"value must &gt; 0"</span>)</span><br><span class="line">        <span class="built_in">super</span>().__set__(instance, value)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxSized</span>(<span class="title class_ inherited__">Descriptor</span>):</span><br><span class="line">    <span class="comment"># 继承自描述符类，检查赋值的字符串长度是否超出限制</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="literal">None</span>, **opt</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'size'</span> <span class="keyword">not</span> <span class="keyword">in</span> opt:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"missing size option"</span>)</span><br><span class="line">        <span class="built_in">super</span>.__init__(name, **opt)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(value) &gt;= self.size:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"&gt; size"</span>)</span><br><span class="line">        <span class="built_in">super</span>.__set__(instance, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面基于描述符类来创建出需要用到检测类型的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>(<span class="title class_ inherited__">Typed</span>):</span><br><span class="line">    expected_type = <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsignedInteger</span>(Integer, Unsigned):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>(<span class="title class_ inherited__">Typed</span>):</span><br><span class="line">    expected_type = <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SizedString</span>(String, MaxSized):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后就可以使用这些类来进行类型约束</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span>:</span><br><span class="line">    name = SizedString(<span class="string">'name'</span>, size = <span class="number">8</span>)</span><br><span class="line">    shares = UnsignedInteger(<span class="string">'shares'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kargs</span>):</span><br><span class="line">        ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>下面来解释一下流程:</p><ul><li>首先<code>Descriptor</code>只是一个简单的描述符基类，且只有<code>set</code>方法</li><li><code>Typed</code>, <code>Unsigned</code>,<code>MaxSized</code>也是描述符，这些二级描述符继承自<code>Descriptor</code>，并重写了其<code>set</code>方法，分别检测赋值时类型、长度。</li><li><code>Integer</code>, <code>UnsignedInteger</code>,<code>String</code>,<code>SizedString</code>是继承上述描述符类，并基于上述限制来进行组合。由于默认没有构造函数，会使用基类的构造函数。<strong>同样也是描述符。</strong></li><li>直接使用的描述符是<code>Integer</code>,<code>UnsignedInteger</code>, <code>String</code>,<code>SizedString</code></li></ul><p><strong>同样，也可以使用装饰器的方式来完成，且速度更快！</strong></p>
          </div>
<h3 id="委托属性的访问">委托属性的访问</h3>
<div class="note primary">
            <p>当类访问到不存在的属性时，会调用<code>__getattr__</code>这个方法</p><p><strong>但是不适用于双下划线开头结尾的魔法方法</strong></p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">1</span></span><br><span class="line">        self.y = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a = A()</span><br><span class="line">        self.y = <span class="number">3</span></span><br><span class="line">        self.z = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.a, name)</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"><span class="built_in">print</span>(b.x) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(B.y) <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(b.z) <span class="comment"># 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="maxin技术">MAXIN技术</h3>
<div class="note primary">
            <p>主要是用来继承，通过调用<code>super()</code>函数来调用另一个类的一些方法。</p><p>目的是用来使用一些方法扩充其他的类。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 先给出MixIN类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SetOnceMixIN</span>:</span><br><span class="line">    __slots__ = () <span class="comment"># 没有实例对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="comment"># 此处的MIXIN类要和dict类一起使用</span></span><br><span class="line">        <span class="comment"># self即字典</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self: </span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">"already exists"</span>)</span><br><span class="line">        <span class="comment"># 虽然没有继承，但是仍然可以使用super，这会调用同一级别继承的函数</span></span><br><span class="line">        <span class="built_in">super</span>().__setitem__(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时SetOnceDict就将SetOnceMixIN和dict两种功能混合在一起</span></span><br><span class="line"><span class="comment"># SetOnceMixIN的super()会调用dict中对应的函数，这和MRO表有关</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SetOnceDict</span>(SetOnceMixIN, <span class="built_in">dict</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">a = SetOnceDict()</span><br><span class="line">a[<span class="string">'x'</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="string">'x'</span>] = <span class="number">2</span> <span class="comment">#会报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>一般都是为了已有的类增加一些可选的功能而设计的，标准库中很多</p><p>mixin类不能被实例化，或者说实例化没有意义</p><p>mixin类也主要用于继承中</p>
          </div>
<h3 id="使用字符串来访问对象的属性">使用字符串来访问对象的属性</h3>
<div class="note primary">
            <p>可以使用<code>getattr()</code>函数来通过字符串调用类的方法</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pri</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pri_num</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line">    </span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">getattr</span>(a, <span class="string">"pri"</span>)() <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">getattr</span>(a, <span class="string">"pri_num"</span>)(<span class="number">123</span>) <span class="comment"># 123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonCookbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧(9)--元编程</title>
    <url>/2022/12/25/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-9/</url>
    <content><![CDATA[<h2 id="元编程----来源于cookbook第九章">元编程----来源于cookbook第九章</h2>
<span id="more"></span>
<p><font color="#da00ad">记录第九章中比较有意思的部分</font></p>
<hr>
<h3 id="类方法与装饰器">类方法与装饰器</h3>
<div class="note primary">
            <p>将类方法作为装饰器时需要处理的小问题就是cls与self的问题</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">####### 将普通装饰器用于类普通方法---处理self</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.x) <span class="comment"># 由于此时需要访问实例内数据，因此需要显示指明self</span></span><br><span class="line">        func(self, *args)</span><br><span class="line">    <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">1</span></span><br><span class="line">        self.y = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @dec1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">p</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.y)</span><br><span class="line">        <span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.p(<span class="number">123</span>) <span class="comment"># 1 \n 2 \n 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####### 将一个类的方法作为装饰器用于这个类的其他方法方法---一个错误示范</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">1</span></span><br><span class="line">        self.y = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">a_dec</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">self, * args</span>):</span><br><span class="line">            <span class="built_in">print</span>(self.x)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="meta">    @ a_dec </span><span class="comment">#由于这个方法是类普通方法，所以需要绑定到某个实例上，如@a.a_dec</span></span><br><span class="line">    <span class="comment"># 如果a_dec是类方法，由于此时类还没创建出来，所以也不能用</span></span><br><span class="line">    <span class="comment"># 因此不要把一个类的某个方法作为装饰器来作用在同一个类的另外一个方法上！</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">p</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.y)</span><br><span class="line">        <span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.p(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">####### 将一个类的方法作为装饰器用于其他函数---处理self和cls</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec1</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec1"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec2</span>(<span class="params">cls, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec2"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line"><span class="meta">@a.dec1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">p1</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@A.dec2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">p2</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">p1()</span><br><span class="line">p2()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p><del>不要尝试将一个类中的某个方法作为装饰器用于同一个类的其他方法上</del></p><p>可以看更新的文章，给出了这样做的方法</p>
          </div>
<h3 id="元类">元类</h3>
<div class="note primary">
            <p>可以使用元类来管理类的创建，具体而言有实例、类、元类</p><p>实例 = 类() ===&gt; 元类("类", "基类", "属性字典")即调用元类的__init__方法</p><p>因此需要通过元类对类进行定制化修改往往在元类的__init__函数中进行(对属性字典)</p><p>另外，实例() ===&gt; 类.__call__，而类本身是元类的对象，所以类()===&gt;元类.__call__，在元类的call函数中会控制调用类的__new__、__init__方法，并<strong>返回</strong>结果。</p><p>所以类的创建顺序:</p><ul><li>实例 = 类() ===&gt; 实例 = 元类("类", "基类", "属性字典")</li><li>然后回调用元类的__new__方法生成出一个'对象'，这个'对象'就是类，并调用元类的__init__来初始化类</li><li>调用元类的__call__方法来生成类的对象实例，会依次调用类的__new__、<strong>init</strong>，并最终返回对象</li></ul><p>至于在元类中重新定义__init__还是__new__，取决于如何具体操作。__new__会在类创建之前调用，如果想要修改属性字典的时候就可以重写<strong>new</strong>；__init__会在类完成创建后调用，不需要控制类的创建的时候就可以重写__init__方法。</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'type 调用了 Mymeta 的 new 方法--生成一个空对象，即 People 类'</span>)</span><br><span class="line">        <span class="string">"这里调用的是 type 的 new 方法,传入参数需要注意全部传会 type 元类"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, class_name, class_bases, class_dic</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'初始化这个对象--- People 类，给 People 类添加额外的功能'</span>)</span><br><span class="line">        <span class="built_in">super</span>(Mymeta, self).__init__(class_name,</span><br><span class="line">                                     class_bases, class_dic)  <span class="comment"># 重用父类的功能</span></span><br><span class="line">        <span class="comment"># 自定义的类的功能</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> class_name.istitle():</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'类名%s请修改为首字母大写'</span> % class_name)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'__doc__'</span> <span class="keyword">not</span> <span class="keyword">in</span> class_dic <span class="keyword">or</span> <span class="built_in">len</span>(class_dic[<span class="string">'__doc__'</span>].strip(<span class="string">' \n'</span>)) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'类中必须有文档注释，并且文档注释不能为空'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 传入 Mymeta的参数：People, 以及传入People的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        self---&lt;class '__main__.People'&gt;</span></span><br><span class="line"><span class="string">        :param args: (1,)</span></span><br><span class="line"><span class="string">        :param kwargs: {'y': 2}</span></span><br><span class="line"><span class="string">        :return: 返回最终初始化好的代码</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'调用了 Mymeta 的 call 方法'</span>)</span><br><span class="line">        <span class="comment"># 调用 People 类里的 __new__方法，生成空对象</span></span><br><span class="line">        People_obj = self.__new__(self, *args, **kwargs)</span><br><span class="line">        <span class="comment"># 调用 People 类里的 __init__方法，初始化空对象,注意：第一个传入的参数是生成好的空对象</span></span><br><span class="line">        self.__init__(People_obj, *args, **kwargs)</span><br><span class="line">        <span class="comment"># 给 People 类生成的对象 obj 添加额外的功能</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"给 People 类生成的对象 obj 添加额外的功能"</span>)</span><br><span class="line">        People_obj.__dict__[<span class="string">"新增一个属性"</span>] = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 返回初始化好的对象</span></span><br><span class="line">        <span class="keyword">return</span> People_obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(metaclass=Mymeta):</span><br><span class="line">    <span class="string">"""People 类的注释"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 产生 People 类真正的对象</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 在这里就可以定制功能</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'生成 People 类的空对象'</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'传入的位置参数'</span>, args)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'传入的位置参数'</span>, kwargs)</span><br><span class="line">        <span class="comment"># 调用所继承的父类的__new__方法，这里就是 object 类,一定要传入 cls(当前这个类)</span></span><br><span class="line">        <span class="string">"这里要区别于自定义元类的 new 方法，自定义元类调用的是 type 的 new 方法,传入参数是不一样的"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"初始化 People 类的对象"</span>)</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"初始化 People 类的对象结束"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用People 类生成对象---&gt; People()= Mymeta.__call__()</span></span><br><span class="line">obj = People(<span class="number">1</span>, y=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'最终的对象字典：'</span>, obj.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">结果输出</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">type 调用了 Mymeta 的 new 方法--生成一个空对象，即 People 类</span></span><br><span class="line"><span class="string">初始化这个对象--- People 类，给 People 类添加额外的功能</span></span><br><span class="line"><span class="string">调用了 Mymeta 的 call 方法</span></span><br><span class="line"><span class="string">生成 People 类的空对象</span></span><br><span class="line"><span class="string">传入的位置参数 (1,)</span></span><br><span class="line"><span class="string">传入的位置参数 {'y': 2}</span></span><br><span class="line"><span class="string">初始化 People 类的对象</span></span><br><span class="line"><span class="string">初始化 People 类的对象结束</span></span><br><span class="line"><span class="string">给 People 类生成的对象 obj 添加额外的功能</span></span><br><span class="line"><span class="string">最终的对象字典： {'x': 1, 'y': 2, '新增一个属性': None}</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PythonCookbook</tag>
      </tags>
  </entry>
  <entry>
    <title>TODO</title>
    <url>/2022/08/28/TODO/</url>
    <content><![CDATA[<p>博客补全计划...</p>
<span id="more"></span>
<p>目前，本博客刚刚建成，因此后续打算将之前的笔记转移到此博客上，从而形成一个比较集中的管理。</p>
<h5 id="高优先级部分">高优先级部分</h5>
<ul class="task-list">
<li><input type="checkbox" disabled="">levelDB源码剖析</li>
<li><input type="checkbox" disabled="">python技巧系列</li>
<li><input type="checkbox" disabled="">CUDA开发</li>
<li><input type="checkbox" disabled="">小工具的源码剖析</li>
<li><input type="checkbox" disabled="">3D视觉</li>
</ul>
<h5 id="中优先级部分">中优先级部分</h5>
<ul class="task-list">
<li><input type="checkbox" disabled="">SICP读书笔记转移</li>
<li><input type="checkbox" disabled="">CSAPP笔记转移</li>
<li><input type="checkbox" disabled="">OpenCV源码剖析</li>
<li><input type="checkbox" disabled="">一些的工具使用与开发</li>
</ul>
<h5 id="低优先级部分">低优先级部分</h5>
<ul class="task-list">
<li><input type="checkbox" disabled="">机器学习中的笔记</li>
<li><input type="checkbox" disabled="">python爬虫部分，涉及xpath、re、scrapy、selenium、splash、代理池等等</li>
<li><input type="checkbox" disabled="">计算机网络部分笔记</li>
<li><input type="checkbox" disabled="">Notability上的手写笔记转成md格式存储</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(1)--概述levelDB项目结构</title>
    <url>/2022/08/28/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-1/</url>
    <content><![CDATA[<h2 id="概述leveldb项目结构">概述levelDB项目结构</h2>
<span id="more"></span>
<hr>
<p><em><a href="https://zhuanlan.zhihu.com/p/203578801">参考1</a></em></p>
<p><em><a href="https://zhuanlan.zhihu.com/p/436037845">参考2</a></em></p>
<p><em><a href="https://github.com/google/leveldb">项目地址</a></em></p>
<hr>
<h3 id="leveldb项目概述">levelDB项目概述</h3>
<p>levelDB
是一个持久化<code>kv</code>存储数据库，<code>kv</code>均为任意的字节数组。</p>
<p>其随机写、顺序写/读的性能很高，但是随机读的性能一般。</p>
<h4 id="lsm-tree">LSM Tree</h4>
<p>其实现原理为<code>LSM Tree</code>，简单来说就是讲磁盘的随机写转换成顺序写.</p>
<p>由于磁盘的寻址非常耗时，因此顺序写的速度远远超过随机写.</p>
<p><code>LSM Tree</code>由两部分组成分别是<code>Log structed</code>和<code>Merge Tree</code>.</p>
<p>其中<code>Log structed</code>是日志结构，而日志本身是不会修改的，只需要追加写.</p>
<p><code>Merge Tree</code>是合并树，即将多个树合并成一个更大的树.</p>
<p><em>所以，<code>LSM Tree</code>是数据以追加写的方式写入文件，成为一颗小树，然后合并成更大的树.</em></p>
<p>在<code>LSM Tree</code>中，<strong>更新一个数据不需要修改过去的旧数据</strong>，但是此时，<br>
其写的性能很强大，但是需要支付额外的存储空间来作为代价。为了同步提升其读的性能，levelDB也同样支付了一些存储空间作为读性能提升的代价。</p>
<p>具体而言，将索引树结构拆分成多个大小逐渐变大的结构<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>、<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>...<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.765ex" height="1.952ex" role="img" focusable="false" viewBox="0 -705 1222.3 862.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></span>，其均为有序的。</p>
<p>最小的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>位于内存，是所有操作数据的落脚点，保存了最近写入的kv，其也可以随时原地更新，支持随时查询。</p>
<img src="/2022/08/28/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-1/pic1.jpg" class="">
<p>其余的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>...<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.765ex" height="1.952ex" role="img" focusable="false" viewBox="0 -705 1222.3 862.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></span>均位于磁盘中，但是每棵树也是有序的。</p>
<p><strong><em>当执行写操作时</em></strong>：首先将数据加入到<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>层索引树中，当<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>层数据大小达到一定程度时，会执行<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>与<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>层的合并。由于两者均为有序的，所以这个过程类似一个归并，而归并这个操作只需要用到有序写，合并出来的新的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>会取代掉旧的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>，当<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>到达指定大小后，也会同样向后合并。</p>
<img src="/2022/08/28/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-1/pic2.jpg" class="">
<p><strong><em>当执行读操作时</em></strong>：在<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>、<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>...<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.765ex" height="1.952ex" role="img" focusable="false" viewBox="0 -705 1222.3 862.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></span>中逐层查找，直到找到为止，因此，即使数据没有更新到较高的层中，也不影响数据的正确性。</p>
<p>当然，levelDB具体的实现还是存在一些细节的。</p>
<hr>
<h3 id="leveldb的项目结构">levelDB的项目结构</h3>
<h4 id="一些头文件及其作用">一些头文件及其作用</h4>
<p><code>include</code>: 函数库的头文件</p>
<p><code>port</code>: 可移植性相关的功能</p>
<p><code>util</code>: 项目用到的一些功能函数</p>
<p><code>table</code>: SSTable的实现</p>
<p><code>helpers/memenv</code>：简单完全内存的文件系统，提供操作目录文件接口</p>
<p><code>benchmarks</code>：性能测试相关代码</p>
<p><code>db</code>:
数据库实现，版本管理，Compaction，WAL和MemTable实现</p>
<h4 id="接口文件的对应功能">接口文件的对应功能</h4>
<p><code>cache.h</code>:
缓存接口，提供了默认的LRU缓存，也可以自己实现缓存</p>
<p><code>comparator.h</code>:
定以数据库比较器的接口，用来比较键，可以使用默认的基于字节的比较，可以定义自己的比较器</p>
<p><code>dumpfile.h</code>: 以可读文本形式导出一个文件，调试使用</p>
<p><code>export.h</code>: 可移植性相关</p>
<p><code>iterator.h</code>: 迭代器接口</p>
<p><code>slice.h</code>: 实现一个字符串，存储指针和长度，指向字符串</p>
<p><code>table_builder.h</code>: 构造一个SSTable</p>
<p><code>write_batch.h</code>: 实现批量写入的接口</p>
<p><code>c.h</code>: 实现C语言相关的接口</p>
<p><code>db.h</code>: 操作数据库的主要接口</p>
<p><code>env.h</code>: 定义操作系统相关的功能，如读写文件之类的</p>
<p><code>filter_policy.h</code>: 定义布隆过滤器接口</p>
<p><code>options.h</code>: 配置选项</p>
<p><code>status.h</code>: 定义数据库操作的返回状态</p>
<p><code>table.h</code>: SSTable相关的接口</p>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(10)--MemTable结构</title>
    <url>/2022/09/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-10/</url>
    <content><![CDATA[<h2 id="memtable结构">MemTable结构</h2>
<span id="more"></span>
<div class="note primary">
            <p>源码位置与说明<br>db/skiplist.h : 跳跃表实现<br>db/memtable.h db/memtable.cc : MemTable的实现</p>
          </div>
<p>MemTable是levelDB的存储结构，并且其是内存中的组织结构，其内部是有序的。只有当大小到达一定程度时才会被写入到磁盘上的SSTable中，这也就是为什么SSTable中写入kv时要求key是按顺序排布的，因为key再内存中就已经被组织好了。</p>
<img src="/2022/09/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-10/pic1.jpg" class="">
<p>由于MemTable需要是按照键值对存储，且必须是有序的，所以就不能使用哈希表。对于SortedMap的实现，一般会采用红黑树，不过LevelDB采用的是Skiplist。Skiplist是一种概率性的数据结构，支持SortedMap的所有功能，性能和红黑树相当。</p>
<h3 id="skiplist">Skiplist</h3>
<p>我们先来说一下跳跃表这种数据结构，跳跃表的本体其实就是一个链表，这个链表是有序的。但是链表的查找非常慢，需要从头开始一个一个遍历，考虑到链表本身也是有序的，我们可以为其增加一些索引。</p>
<img src="/2022/09/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-10/pic2.jpg" class="">
<p>每次查找时，先从最上层的索引开始查找，并且由于链表有序，其实这些索引相当于了二分查找，效率很高。不过这些索引其实是在插入key-value时有一定概率创建出来的，所以不是严格的二分查找。</p>
<p>另外，由于键是不重复的，所以不能保存相同的键。</p>
<p>跳跃表比红黑树的实现简单太多了，所以我们就看一下这部分的源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkipList</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>; <span class="comment">// 结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    {</span><br><span class="line">        kMaxHeight = <span class="number">12</span> <span class="comment">// 跳跃表的最大索引高度</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的最大高度，宽松内存序</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetMaxHeight</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> max_height_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在高度height处创建新的key</span></span><br><span class="line">    <span class="function">Node *<span class="title">NewNode</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">RandomHeight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Equal</span><span class="params">(<span class="type">const</span> Key &amp;a, <span class="type">const</span> Key &amp;b)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> (<span class="built_in">compare_</span>(a, b) == <span class="number">0</span>); }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果档key在结点后面就返回true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">KeyIsAfterNode</span><span class="params">(<span class="type">const</span> Key &amp;key, Node *n)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回在key后面最小的结点</span></span><br><span class="line">    <span class="function">Node *<span class="title">FindGreaterOrEqual</span><span class="params">(<span class="type">const</span> Key &amp;key, Node **prev)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回比key小的最大结点</span></span><br><span class="line">    <span class="function">Node *<span class="title">FindLessThan</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最后一个结点</span></span><br><span class="line">    <span class="function">Node *<span class="title">FindLast</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    Comparator <span class="type">const</span> compare_; <span class="comment">// 比较用比较器</span></span><br><span class="line">    Arena *<span class="type">const</span> arena_;       <span class="comment">// 使用Arena类来为结点分配内存</span></span><br><span class="line"></span><br><span class="line">    Node *<span class="type">const</span> head_; <span class="comment">// 头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大索引高度</span></span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; max_height_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read/written only by Insert(). ？</span></span><br><span class="line">    Random rnd_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 跳表使用cmp来进行比较key，使用arena来进行内存管理</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SkipList</span><span class="params">(Comparator cmp, Arena *arena)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SkipList</span>(<span class="type">const</span> SkipList &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SkipList &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SkipList &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入key，需要保证没有重复的key</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果包含就返回true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Contains</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器类，迭代key-value</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span></span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// Initialize an iterator over the specified list.</span></span><br><span class="line">        <span class="comment">// The returned iterator is not valid.</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(<span class="type">const</span> SkipList *list)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Returns the key at the current position.</span></span><br><span class="line">        <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">        <span class="function"><span class="type">const</span> Key &amp;<span class="title">key</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Advances to the next position.</span></span><br><span class="line">        <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Advances to the previous position.</span></span><br><span class="line">        <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">const</span> Key &amp;target)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Position at the first entry in list.</span></span><br><span class="line">        <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Position at the last entry in list.</span></span><br><span class="line">        <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">const</span> SkipList *list_;</span><br><span class="line">        Node *node_;</span><br><span class="line">        <span class="comment">// Intentionally copyable</span></span><br><span class="line">    };</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>跳表是一个类模板，可以传递用于比较keys的比较器和结点的内存管理器，另外，其中还存在可以迭代跳表的迭代器，由于迭代器的实现比较简单，此处就不再赘诉了。由于MemTable位于内存中，所以需要考虑到多个线程对其进行读写的情况。</p>
<p>跳表的内部实现全部是内联函数，且涉及到迭代器和Node结点的成员，数目比较多但是相对比较简单。</p>
<p>需要注意的是，在levelDB中，跳表没有删除key-value的接口。</p>
<p>SkipList插入一个键时，需要分配内存给一个节点，malloc是一个比较耗时的系统调用，尤其对于小内存分配来说，而且会产生很多内存碎片。</p>
<p>LevelDB里面的SkipList和一般的Skiplist使用有很大的不同，只会分配内存，而不需要回收小部分内存。SkipList的内存是等待MemTable写满后，转换为Immutable
MemTable，写入SSTable，写入完成后，一起被销毁。也就是内存的回收是针对整个Skiplist的。</p>
<p>可能会觉得传递一个管理内存的类很奇怪，我们来具体看一下调用arena类的部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::<span class="built_in">NewNode</span>(</span><br><span class="line">    <span class="type">const</span> Key&amp; key, <span class="type">int</span> height) {</span><br><span class="line">  <span class="type">char</span>* <span class="type">const</span> node_memory = arena_-&gt;<span class="built_in">AllocateAligned</span>(</span><br><span class="line">      <span class="built_in">sizeof</span>(Node) + <span class="built_in">sizeof</span>(std::atomic&lt;Node*&gt;) * (height - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">new</span> (node_memory) <span class="built_in">Node</span>(key);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到，arena类内部是通过new来分配出一整块内存(4kb)，然后NewNode在进行内存申请时，调用arena类的分配对齐内存的接口，这其实是arena类在内部移动已经申请的内存块的指针，并不涉及到系统调用，所以会节省时间。SkipList类没有定义析构函数，所以在结束时会调用默认的析构函数，默认析构函数又会调用arena类的析构函数，而arena类的析构函数会释放arena类在生存期间申请的所有内存，这样就避免了内存泄漏的问题。</p>
<h3 id="memtable">MemTable</h3>
<p>MemTable其实就是对跳跃表的一层封装，并且其是一个智能指针的形式，采用了引用计数，将对键的查找和插入的请求，代理到相应的SkipList，调用相应的接口。</p>
<p>在实现中有一点值得注意，LevelDB存储的是Kv，而SkipList存储的是键，所以在MemTable里需要做一个转换。</p>
<p>对于插入操作，MemTable会把键和值编码在一个字符串里面，如下图所示，先是键，再是值，使用了字符串的长度前缀编码，然后将这个字符串插入到SkipList里。这里面涉及到了很多的key类型，我们先搁置在一边，大致了解一下就可以了，后面会具体阐述的。</p>
<img src="/2022/09/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-10/pic3.png" class="">
<p>而对于查找操作，只会按照前缀编码键，构造上面图的前半部分，而SkipList::Iterator::Seek的实现，会将迭代器定位到大于等于查找键的第一个键的位置，读出这个键，然后比对里面的键和查找的键是否相同，相同的话，才会读取对应的值，否则就是键不存在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemTable</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">MemTableIterator</span>; <span class="comment">// 友元类，正反迭代器</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">MemTableBackwardIterator</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">KeyComparator</span> <span class="comment">// key比较器，有好多的key，这部分后面具体说</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">const</span> InternalKeyComparator comparator;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">KeyComparator</span><span class="params">(<span class="type">const</span> InternalKeyComparator &amp;c)</span> : comparator(c) {</span>}</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a, <span class="type">const</span> <span class="type">char</span> *b)</span> <span class="type">const</span></span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> SkipList&lt;<span class="type">const</span> <span class="type">char</span> *, KeyComparator&gt; Table; <span class="comment">// Table是跳表的typedef</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有析构函数，因为只有Unref能调用它</span></span><br><span class="line">    ~<span class="built_in">MemTable</span>();</span><br><span class="line"></span><br><span class="line">    KeyComparator comparator_; <span class="comment">// key比较器</span></span><br><span class="line">    <span class="type">int</span> refs_;                 <span class="comment">// 引用次数</span></span><br><span class="line">    Arena arena_;              <span class="comment">// 内存管理类</span></span><br><span class="line">    Table table_;              <span class="comment">// memtable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// MemTables会执行引用计数，初始计数为0，调用者必须主席那个Ref()函数至少一次</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MemTable</span><span class="params">(<span class="type">const</span> InternalKeyComparator &amp;comparator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MemTable</span>(<span class="type">const</span> MemTable &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MemTable &amp;<span class="keyword">operator</span>=(<span class="type">const</span> MemTable &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Ref</span><span class="params">()</span> </span>{ ++refs_; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当没有引用计数时释放内存，就是一个智能指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unref</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        --refs_;</span><br><span class="line">        <span class="built_in">assert</span>(refs_ &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (refs_ &lt;= <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回大约占用了多少内存，因为是多线程的，所以只能估计</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">ApproximateMemoryUsage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个迭代器</span></span><br><span class="line">    <span class="function">Iterator *<span class="title">NewIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add an entry into memtable that maps key to value at the</span></span><br><span class="line">    <span class="comment">// specified sequence number and with the specified type.</span></span><br><span class="line">    <span class="comment">// Typically value will be empty if type==kTypeDeletion.</span></span><br><span class="line">    <span class="comment">// 添加一个key，type可以用来指示删除key，即把对应的value设置为空</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(SequenceNumber seq, ValueType type, <span class="type">const</span> Slice &amp;key,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> Slice &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line">    <span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line">    <span class="comment">// in *status and return true.</span></span><br><span class="line">    <span class="comment">// Else, return false.</span></span><br><span class="line">    <span class="comment">// 查找一个key，如果是被删除的key不会返回success</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(<span class="type">const</span> LookupKey &amp;key, std::string *value, Status *s)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在头文件中，我们可以观察到，如果需要删除一个key，其实就是插入一条k-v，并且标注是删除即可。另外，由于levelDB中不存在相同的key，所以需要保证key-value是唯一的。下面我们来看一下具体的实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 解析levelDB 中Varint32 类型的数据，在levelDB中数据一般先存储数据大小，然后存储真实的数据。</span></span><br><span class="line"><span class="comment">// p ：Varint32数据的起始地址；</span></span><br><span class="line"><span class="comment">// limit : Varint32数据最多用5位，所以limit 为p+5;</span></span><br><span class="line"><span class="comment">// v ：数据的长度；</span></span><br><span class="line"><span class="comment">// return 返回真实数据的起始地址</span></span><br><span class="line"><span class="function"><span class="type">static</span> Slice <span class="title">GetLengthPrefixedSlice</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = data;</span><br><span class="line">    p = <span class="built_in">GetVarint32Ptr</span>(p, p + <span class="number">5</span>, &amp;len); <span class="comment">// +5: we assume "p" is not corrupted</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(p, len);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">MemTable::<span class="built_in">MemTable</span>(<span class="type">const</span> InternalKeyComparator &amp;comparator)</span><br><span class="line">    : <span class="built_in">comparator_</span>(comparator), <span class="built_in">refs_</span>(<span class="number">0</span>), <span class="built_in">table_</span>(comparator_, &amp;arena_) {}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">MemTable::~<span class="built_in">MemTable</span>() { <span class="built_in">assert</span>(refs_ == <span class="number">0</span>); }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回大约占用了多少字节</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">MemTable::ApproximateMemoryUsage</span><span class="params">()</span> </span>{ <span class="keyword">return</span> arena_.<span class="built_in">MemoryUsage</span>(); }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较keys</span></span><br><span class="line"><span class="type">int</span> MemTable::KeyComparator::<span class="built_in">operator</span>()(<span class="type">const</span> <span class="type">char</span> *aptr,</span><br><span class="line">                                        <span class="type">const</span> <span class="type">char</span> *bptr) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Internal keys are encoded as length-prefixed strings.</span></span><br><span class="line">    Slice a = <span class="built_in">GetLengthPrefixedSlice</span>(aptr);</span><br><span class="line">    Slice b = <span class="built_in">GetLengthPrefixedSlice</span>(bptr);</span><br><span class="line">    <span class="keyword">return</span> comparator.<span class="built_in">Compare</span>(a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成数据的编码，前缀码，长度在前，数据在后</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">EncodeKey</span><span class="params">(std::string *scratch, <span class="type">const</span> Slice &amp;target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">PutVarint32</span>(scratch, target.<span class="built_in">size</span>());</span><br><span class="line">    scratch-&gt;<span class="built_in">append</span>(target.<span class="built_in">data</span>(), target.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> scratch-&gt;<span class="built_in">data</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemTableIterator</span> : <span class="keyword">public</span> Iterator</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MemTableIterator</span><span class="params">(MemTable::Table *table)</span> : iter_(table) {</span>}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MemTableIterator</span>(<span class="type">const</span> MemTableIterator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MemTableIterator &amp;<span class="keyword">operator</span>=(<span class="type">const</span> MemTableIterator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MemTableIterator</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>{ <span class="keyword">return</span> iter_.<span class="built_in">Valid</span>(); }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">const</span> Slice &amp;k)</span> <span class="keyword">override</span> </span>{ iter_.<span class="built_in">Seek</span>(<span class="built_in">EncodeKey</span>(&amp;tmp_, k)); }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>{ iter_.<span class="built_in">SeekToFirst</span>(); }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>{ iter_.<span class="built_in">SeekToLast</span>(); }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>{ iter_.<span class="built_in">Next</span>(); }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>{ iter_.<span class="built_in">Prev</span>(); }</span><br><span class="line">    <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>{ <span class="keyword">return</span> <span class="built_in">GetLengthPrefixedSlice</span>(iter_.<span class="built_in">key</span>()); }</span><br><span class="line">    <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Slice key_slice = <span class="built_in">GetLengthPrefixedSlice</span>(iter_.<span class="built_in">key</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetLengthPrefixedSlice</span>(key_slice.<span class="built_in">data</span>() + key_slice.<span class="built_in">size</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>{ <span class="keyword">return</span> Status::<span class="built_in">OK</span>(); }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MemTable::Table::Iterator iter_;</span><br><span class="line">    std::string tmp_; <span class="comment">// For passing to EncodeKey</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator *<span class="title">MemTable::NewIterator</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MemTableIterator</span>(&amp;table_); }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个key-value</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTable::Add</span><span class="params">(SequenceNumber s, ValueType type, <span class="type">const</span> Slice &amp;key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> Slice &amp;value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">    <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">    <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">    <span class="comment">//  tag          : uint64((sequence &lt;&lt; 8) | type)</span></span><br><span class="line">    <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">    <span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line">    <span class="type">size_t</span> key_size = key.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> val_size = value.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> encoded_len = <span class="built_in">VarintLength</span>(internal_key_size) +</span><br><span class="line">                               internal_key_size + <span class="built_in">VarintLength</span>(val_size) +</span><br><span class="line">                               val_size;</span><br><span class="line">    <span class="type">char</span> *buf = arena_.<span class="built_in">Allocate</span>(encoded_len);</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">EncodeVarint32</span>(buf, internal_key_size);</span><br><span class="line">    std::<span class="built_in">memcpy</span>(p, key.<span class="built_in">data</span>(), key_size);</span><br><span class="line">    p += key_size;</span><br><span class="line">    <span class="built_in">EncodeFixed64</span>(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">    p += <span class="number">8</span>;</span><br><span class="line">    p = <span class="built_in">EncodeVarint32</span>(p, val_size);</span><br><span class="line">    std::<span class="built_in">memcpy</span>(p, value.<span class="built_in">data</span>(), val_size);</span><br><span class="line">    <span class="built_in">assert</span>(p + val_size == buf + encoded_len);</span><br><span class="line">    table_.<span class="built_in">Insert</span>(buf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个key</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MemTable::Get</span><span class="params">(<span class="type">const</span> LookupKey &amp;key, std::string *value, Status *s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Slice memkey = key.<span class="built_in">memtable_key</span>();</span><br><span class="line">    <span class="function">Table::Iterator <span class="title">iter</span><span class="params">(&amp;table_)</span></span>;</span><br><span class="line">    iter.<span class="built_in">Seek</span>(memkey.<span class="built_in">data</span>());</span><br><span class="line">    <span class="keyword">if</span> (iter.<span class="built_in">Valid</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// entry format is:</span></span><br><span class="line">        <span class="comment">//    klength  varint32</span></span><br><span class="line">        <span class="comment">//    userkey  char[klength]</span></span><br><span class="line">        <span class="comment">//    tag      uint64</span></span><br><span class="line">        <span class="comment">//    vlength  varint32</span></span><br><span class="line">        <span class="comment">//    value    char[vlength]</span></span><br><span class="line">        <span class="comment">// Check that it belongs to same user key.  We do not check the</span></span><br><span class="line">        <span class="comment">// sequence number since the Seek() call above should have skipped</span></span><br><span class="line">        <span class="comment">// all entries with overly large sequence numbers.</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *entry = iter.<span class="built_in">key</span>();</span><br><span class="line">        <span class="type">uint32_t</span> key_length;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *key_ptr = <span class="built_in">GetVarint32Ptr</span>(entry, entry + <span class="number">5</span>, &amp;key_length);</span><br><span class="line">        <span class="keyword">if</span> (comparator_.comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Compare</span>(</span><br><span class="line">                <span class="built_in">Slice</span>(key_ptr, key_length - <span class="number">8</span>), key.<span class="built_in">user_key</span>()) == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Correct user key</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint64_t</span> tag = <span class="built_in">DecodeFixed64</span>(key_ptr + key_length - <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>))</span><br><span class="line">            {</span><br><span class="line">            <span class="keyword">case</span> kTypeValue:</span><br><span class="line">            {</span><br><span class="line">                Slice v = <span class="built_in">GetLengthPrefixedSlice</span>(key_ptr + key_length);</span><br><span class="line">                value-&gt;<span class="built_in">assign</span>(v.<span class="built_in">data</span>(), v.<span class="built_in">size</span>());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">                *s = Status::<span class="built_in">NotFound</span>(<span class="built_in">Slice</span>());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而对于查找操作，只会按照前缀编码键，构造上面图的前半部分，而SkipList::Iterator::Seek的实现，会将迭代器定位到大于等于查找键的第一个键的位置，读出这个键，然后比对里面的键和查找的键是否相同，相同的话，才会读取对应的值，否则就是键不存在。</p>
<p>总体而言，MemTable结构还是比较简单的。</p>
<h2 id="总结">总结</h2>
<div class="note primary">
            <p><strong>编程技巧</strong></p><ul><li>使用引用计数的类的析构函数可以作为私有成员来使用。</li></ul>
          </div>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(11)--内部的key结构</title>
    <url>/2022/10/01/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-11/</url>
    <content><![CDATA[<h2 id="内部的key结构">内部的key结构</h2>
<span id="more"></span>
<div class="note primary">
            <p>源码位置与说明</p><p>db/dbformat.h db/dbformat.cc: 定义了Internal Key、LookupKey、InternalKeyComparator和InternalFilterPolicy</p>
          </div>
<p>在levelDB中，存在着多种类型的key，而由于levelDB本身又是kv型的数据库，所以弄清楚这些key的结构与作用都是十分重要的。</p>
<p>其中，在levelDB中主要有以下三种类型的key，分别是<code>User Key</code>、<code>Internal Key</code>和<code>Lookup Key</code>，我们后面就针对这三种类型的key进行阐述。</p>
<h3 id="user-key">User Key</h3>
<p>User
Key顾名思义，其实就是用户插入的key-value中的key，是原始的key的形式，这种是最简单的情况，也就是读写键值对时提供的键，只是一个简单的字符串，一般用Slice来表示。</p>
<p>程序与levelDB交互式，使用的key就是Usr Key。</p>
<h3 id="internal-key">Internal Key</h3>
<p>第二种类型的key是Internal
Key，这是SSTable中实际存储的key，也就是这个持久化有序的Map的键。但同时Internal
Key是一个复合概念，是有几个部分组合成的一个key，ParsedInternal
Key就是对Internal Key分拆后的结果，先来看看ParsedInternal
Key的定义，这是一个结构体struct：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ParsedInternalKey</span></span><br><span class="line">{</span><br><span class="line">    Slice user_key;</span><br><span class="line">    SequenceNumber sequence;</span><br><span class="line">    ValueType type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ParsedInternalKey</span>() {} <span class="comment">// Intentionally left uninitialized (for speed)</span></span><br><span class="line">    <span class="built_in">ParsedInternalKey</span>(<span class="type">const</span> Slice &amp;u, <span class="type">const</span> SequenceNumber &amp;seq, ValueType t)</span><br><span class="line">        : <span class="built_in">user_key</span>(u), <span class="built_in">sequence</span>(seq), <span class="built_in">type</span>(t) {}</span><br><span class="line">    <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个结构体说明ParsedInternalKey由三部分组成：user_key、序列号以及类型组成。<strong>而实际上ParsedInternalKey本身就可以看成是Internal
key。</strong></p>
<p>然后我们看一个比较重要的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 把ParsedInternalKey编码成字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppendInternalKey</span><span class="params">(std::string *result, <span class="type">const</span> ParsedInternalKey &amp;key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 先把user key放进去</span></span><br><span class="line">    result-&gt;<span class="built_in">append</span>(key.user_key.<span class="built_in">data</span>(), key.user_key.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 再把序列号和类型编码后放入</span></span><br><span class="line">    <span class="built_in">PutFixed64</span>(result, <span class="built_in">PackSequenceAndType</span>(key.sequence, key.type));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码序列号和类型</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">PackSequenceAndType</span><span class="params">(<span class="type">uint64_t</span> seq, ValueType t)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">assert</span>(seq &lt;= kMaxSequenceNumber);</span><br><span class="line">    <span class="built_in">assert</span>(t &lt;= kValueTypeForSeek);</span><br><span class="line">    <span class="keyword">return</span> (seq &lt;&lt; <span class="number">8</span>) | t;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两个函数是将ParsedInternalKey编码成字符串，也就是把一个结构体编码成字符串，这样就成为了真正的Internal
key。我们接来下看一下Internal key。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InternalKey</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string rep_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数，让rep_为空就说明其为非法的</span></span><br><span class="line">    <span class="built_in">InternalKey</span>() {}</span><br><span class="line">    <span class="comment">// 构造一个Internal Key，由userkey，序列号和类型组成</span></span><br><span class="line">    <span class="comment">// 先把后面的部分存储到结构体中，然后调用AppendInternalKey</span></span><br><span class="line">    <span class="comment">// 将ParsedInternalKey封装进rep_中</span></span><br><span class="line">    <span class="built_in">InternalKey</span>(<span class="type">const</span> Slice &amp;user_key, SequenceNumber s, ValueType t)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">AppendInternalKey</span>(&amp;rep_, <span class="built_in">ParsedInternalKey</span>(user_key, s, t));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码字符串</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DecodeFrom</span><span class="params">(<span class="type">const</span> Slice &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        rep_.<span class="built_in">assign</span>(s.<span class="built_in">data</span>(), s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> !rep_.<span class="built_in">empty</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回编码信息</span></span><br><span class="line">    <span class="function">Slice <span class="title">Encode</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">assert</span>(!rep_.<span class="built_in">empty</span>());</span><br><span class="line">        <span class="keyword">return</span> rep_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回出user key</span></span><br><span class="line">    <span class="function">Slice <span class="title">user_key</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">ExtractUserKey</span>(rep_); }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用p来更新rep_</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetFrom</span><span class="params">(<span class="type">const</span> ParsedInternalKey &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        rep_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">AppendInternalKey</span>(&amp;rep_, p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>{ rep_.<span class="built_in">clear</span>(); }</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>InternalKey类中的私有对象就是存放编码后的Internal
key，通过上面那两个函数，我们已经知道ParsedInternalKey是怎么转换成Internal
key的，所以此处就给出Internal key的编码格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">| User key (string) | sequence number (7 bytes) | value type (1 byte) |</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到Internal Key在User
Key的后面增加了一个64位的整数，并且将这个整数分为两部分，低位的一个字节是一个ValueType，高位的7个字节是一个SequenceNumber。</p>
<p>ValueType是为了区分一个键是插入还是删除，删除其实也是一条数据的插入，但是是一条特殊的插入，通过在User
Key后面附上kTypeDeletion来说明要删除这个键，而kTypeValue说明是插入这个键。</p>
<p>SequenceNumber是一个版本号，是全局的，每次有一个键写入时，都会加一，每一个Internal
Key里面都包含了不同的SequenceNumber。SequenceNumber是单调递增的，SequenceNumber越大，表示这键越新，如果User
Key相同，就会覆盖旧的键。所以就算User Key相同，对应的Internal
Key也是不同的，Internal Key是全局唯一的。当我们更新一个User
Key多次时，数据库里面可能保存了多个User Key，但是它们所在的Internal
Key是不同的，并且SequenceNumber可以决定写入的顺序。</p>
<p>当用户写入时，将User Key封装成Internal
Key，保留版本信息，存储到SSTable里，当需要读取时，将User Key从Internal
Key里提取出来，所有User Key相同的Internal
Key里面SequenceNumber最大的Internal
Key就是当前的键，它对应的值就是当前值。</p>
<p><strong>另外Internal Key的比较方式和User
Key是不一样的，Options提供的是User
Key的比较方式，而LevelDB内部会生成一个根据这个User
Key的比较方式得到的Internal Key的比较方式。</strong></p>
<p>当Internal Key里面包含的User Key不同时，直接用User
Key的比较方式即可。否则，根据SequenceNumber比较，按SequenceNumber倒序排序。这样的好处就是，在全局有序的Map里，根据User
Key排序，User Key相同的会排在一起，SequenceNumber大的Internal
Key排在前面。当Seek一个User Key时，会定位到第一个符合条件的Internal
Key，也就是具有最大的SequenceNumber的Internal Key。</p>
<p>除了比较器，布隆过滤器也会被改造，以适应User Key到Internal
Key的转换。</p>
<p>我们再来分析以下Internal key向user
key和ParsedInternalKey转换的部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 解码出user key，其实就是去掉末尾的8字节</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Slice <span class="title">ExtractUserKey</span><span class="params">(<span class="type">const</span> Slice &amp;internal_key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">assert</span>(internal_key.<span class="built_in">size</span>() &gt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(internal_key.<span class="built_in">data</span>(), internal_key.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把InternalKey转换成ParsedInternalKey</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ParseInternalKey</span><span class="params">(<span class="type">const</span> Slice &amp;internal_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                             ParsedInternalKey *result)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = internal_key.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">uint64_t</span> num = <span class="built_in">DecodeFixed64</span>(internal_key.<span class="built_in">data</span>() + n - <span class="number">8</span>);</span><br><span class="line">    <span class="type">uint8_t</span> c = num &amp; <span class="number">0xff</span>;</span><br><span class="line">    result-&gt;sequence = num &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    result-&gt;type = <span class="built_in">static_cast</span>&lt;ValueType&gt;(c);</span><br><span class="line">    result-&gt;user_key = <span class="built_in">Slice</span>(internal_key.<span class="built_in">data</span>(), n - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> (c &lt;= <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(kTypeValue));</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这部分其实也是很简单的，就是对应关系而已。</p>
<h3 id="lookup-key">Lookup Key</h3>
<p>Lookup Key其实就是简单的在Internal
Key前面加上键的长度，使用varint32编码，主要用在MemTable的查找上。</p>
<img src="/2022/10/01/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-11/pic1.png" class="">
<p>由于MemTable的底层是一个Skiplist，而LevelDB的Skiplist只存储了一个键，而没有值。LevelDB在存储Kv时，又是将键和值编码在一起存储的，使用的就是字符串的长度前缀编码。所以在MemTable里查找Key时，提供的Lookup
Key就是编码值的一个前缀，刚好可以定位MemTable里相应的键。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LookupKey</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// We construct a char array of the form:</span></span><br><span class="line">    <span class="comment">//    klength  varint32               &lt;-- start_</span></span><br><span class="line">    <span class="comment">//    userkey  char[klength]          &lt;-- kstart_</span></span><br><span class="line">    <span class="comment">//    tag      uint64</span></span><br><span class="line">    <span class="comment">//                                    &lt;-- end_</span></span><br><span class="line">    <span class="comment">// The array is a suitable MemTable key.</span></span><br><span class="line">    <span class="comment">// The suffix starting with "userkey" can be used as an InternalKey.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *start_;  <span class="comment">// 指向开头</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *kstart_; <span class="comment">// 指向internal_key</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *end_;    <span class="comment">//指向结尾</span></span><br><span class="line">    <span class="type">char</span> space_[<span class="number">200</span>];    <span class="comment">// Avoid allocation for short keys</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数析构函数</span></span><br><span class="line">    <span class="built_in">LookupKey</span>(<span class="type">const</span> Slice &amp;user_key, SequenceNumber sequence);</span><br><span class="line">    <span class="built_in">LookupKey</span>(<span class="type">const</span> LookupKey &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    LookupKey &amp;<span class="keyword">operator</span>=(<span class="type">const</span> LookupKey &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">LookupKey</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回memtable_key，其实就是全部</span></span><br><span class="line">    <span class="function">Slice <span class="title">memtable_key</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">Slice</span>(start_, end_ - start_); }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回internal_key，从internal_key开始到计数</span></span><br><span class="line">    <span class="function">Slice <span class="title">internal_key</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">Slice</span>(kstart_, end_ - kstart_); }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回user_key，就是internal_key的前面</span></span><br><span class="line">    <span class="function">Slice <span class="title">user_key</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">Slice</span>(kstart_, end_ - kstart_ - <span class="number">8</span>); }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，使用userkey和序列号来构造looupkey</span></span><br><span class="line">LookupKey::<span class="built_in">LookupKey</span>(<span class="type">const</span> Slice &amp;user_key, SequenceNumber s)</span><br><span class="line">{</span><br><span class="line">    <span class="type">size_t</span> usize = user_key.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> needed = usize + <span class="number">13</span>; <span class="comment">// 7(序列号) + 1(类型) + 5(最长5字节可变整数编码)</span></span><br><span class="line">    <span class="type">char</span> *dst;</span><br><span class="line">    <span class="keyword">if</span> (needed &lt;= <span class="built_in">sizeof</span>(space_))</span><br><span class="line">    {</span><br><span class="line">        dst = space_;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        dst = <span class="keyword">new</span> <span class="type">char</span>[needed];</span><br><span class="line">    }</span><br><span class="line">    start_ = dst;</span><br><span class="line">    dst = <span class="built_in">EncodeVarint32</span>(dst, usize + <span class="number">8</span>);</span><br><span class="line">    kstart_ = dst;</span><br><span class="line">    std::<span class="built_in">memcpy</span>(dst, user_key.<span class="built_in">data</span>(), usize);</span><br><span class="line">    dst += usize;</span><br><span class="line">    <span class="built_in">EncodeFixed64</span>(dst, <span class="built_in">PackSequenceAndType</span>(s, kValueTypeForSeek));</span><br><span class="line">    dst += <span class="number">8</span>;</span><br><span class="line">    end_ = dst;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到LookupKey类中的接口可以返回memtable_key、internal_key和user_key。为了理解这一点，我们先来看一下LookupKey的构造。</p>
<img src="/2022/10/01/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-11/pic2.png" class="">
<p>其内部成员作为指针分别指向了memtable_key开头、internal_key开头和结束位置。通过这几个特殊位置的指针就可以解析出所有的三种类型key。</p>
<p>从memtable_key()可知MemtableKey就是LookupKey，即：memtableKey ==
lookupKey，而不是internalKey，是klength+internalKey。</p>
<p><strong>有一个部分感觉需要重点说一下</strong>，就是虽然跳表说是不存储值，只存储键(key)，但是MemTable的Add方法会把需要保存的key-value编码成长度前缀码，即相当于将key-value编码成一个'key'放入跳表中存储。</p>
<img src="/2022/10/01/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-11/pic3.png" class="">
<p>而对于查找操作，只会按照前缀编码键，构造上面图的前半部分(lookupkey)，而SkipList::Iterator::Seek的实现，会将迭代器定位到大于等于查找键的第一个键的位置，读出这个键，然后比对里面的键和查找的键是否相同，相同的话，才会读取对应的值，否则就是键不存在。</p>
<h3 id="几种key的联系与区别">几种key的联系与区别</h3>
<p>首先，用户直接插入的key就是user
key，这个key没有经过任何的变化和编码。</p>
<p>然后在levelDB中，会将user key的后面添加上序列号和类型，编程Internal
key，这个key是用于SSTable的存储的。序列号是一个单调递增的数字，类型分为插入类型和删除类型。因为levelDB中不存在删除数据的说法，想要实现删除就需要插入一条类型为删除的数据。由于越大的序列号数据越新，所以读取时会返回序列号最大的数据。</p>
<p>在Internal key前面插入Internal key的长度，就形成了lookup
key。这个lookup
key用于MemTable，因为MemTable内部是跳表，只存储键(<strong>注意这句话该如何理解，按照上面的说法，其实是键和值都被编码成键了</strong>)。构造出lookupkey后就可以用于查找，迭代器会被定位到大于等于lookupkey的第一个键的位置，读出这个键，然后比对里面的键和查找的键是否相同，相同的话，才会读取对应的值，否则就是键不存在。</p>
<img src="/2022/10/01/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-11/pic4.jpg" class="">
<h2 id="总结">总结</h2>
<p>以上就是LevelDB的三种键，是包含的关系：</p>
<ul>
<li>User Key是用户提供的键，是我们看到的键</li>
<li>Internal Key是实际存储的键，支持版本号和Tag的功能</li>
<li>Lookup Key则是为了查找MemTable而构造的键</li>
</ul>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(12)--迭代器的实现</title>
    <url>/2022/10/19/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-12/</url>
    <content><![CDATA[<h2 id="迭代器的实现">迭代器的实现</h2>
<span id="more"></span>
<div class="note primary">
            <p>源码位置与说明</p><p>include/leveldb/iterator.h：定义Iterator的接口<br>table/iterator.cc: 实现CleanUp的功能以及Empty Iterator<br>table/block.h table/block.cc: 实现了Block Iterator<br>db/skiplist.h: 实现了skiplist的Iterator<br>table/two_level_iterator.h table/two_level_iterator.cc： 实现了Two LevelIterator<br>table/merger.h table/merger.cc: 实现了Merger Iterator<br>table/iterator_wrapper.cc:实现一个Iterator包装器，缓存valid()和key()的结果，避免虚函数调用和更好的cachelocality<br>db/db_iter.h db/db_iter.h：实现对整个数据库的迭代器</p>
          </div>
<p>迭代器在levelDB中，或者说在任何类型中的数据库的作用都是十分显著的。在C++的标准库中，也存在迭代器，两者在概念上是类似的，只是levelDB中的迭代器数目更多，作用也更加明确。主要有以下的作用：</p>
<ul>
<li>按顺序对所有的元素进行迭代</li>
<li>处理某一范围内的元素，正序或者逆序</li>
<li>定位到某一个特定的元素进行处理。</li>
</ul>
<p>LevelDB在以下部分使用了迭代器：</p>
<ul>
<li>对MemTable进行迭代</li>
<li>对于SSTable的Block进行迭代</li>
<li>对整个SSTable进行迭代</li>
<li>Level File Num
Iterator，因为LevelDB的SSTable是分层的，这个Iterator对某一个版本的某一层的SSTable的文件信息进行迭代</li>
<li>Concatenating Iterator，Level &gt; 0的SSTable是有序的，Concatenating
Iterator可以对这些有序的SSTable同时迭代</li>
<li>对MemTable、Immutable MemTable和所有的SSTable同时迭代</li>
<li>DB Iterator对整个数据库进行迭代</li>
</ul>
<p>以上迭代器的实现，有些是从零开始实现的，有些是组合其它迭代器实现的。为了组合其它迭代器，LevelDB实现了两种迭代器的组合方式：</p>
<ul>
<li>Two Level
Iterator，可以组合两个迭代器A和B，其中A里面的每个元素可以产生一个迭代器B，可以迭代A，取出一个元素产生迭代器B，然后迭代B，然后再产生A的下一个元素，再产生一个迭代器B，如此往复</li>
<li>Merger
Iterator可以组合多个迭代器，同时对多个迭代器进行迭代，就好像对这些迭代器做了一次归并排序，产生结果</li>
</ul>
<p>虽然有很多的迭代器(如之前Block中出现的Iter)，但是这些迭代器基本上都是继承自一个虚基类--<code>Iterator</code>。所以重点先看一下这个虚基类。</p>
<h2 id="虚基类iterator">虚基类Iterator</h2>
<p>先来看一下其头文件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> Iterator</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这与注册函数有关，至于什么是注册函数，可以先看一下这个类中公有区域的最后一个函数</span></span><br><span class="line">    <span class="comment">// 注册的清理函数会被存储在一个单向链表中，链表的头节点被内联在迭代器中</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CleanupNode</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 每个结点存储一个清理函数，会被逐个调用</span></span><br><span class="line">        <span class="comment">// 链表中存储的节点是否被使用，只有头节点可能是未使用的</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> function == <span class="literal">nullptr</span>; }</span><br><span class="line">        <span class="comment">// 运行一个清理函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="built_in">assert</span>(function != <span class="literal">nullptr</span>);</span><br><span class="line">            (*function)(arg1, arg2);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 头节点如果被使用的话，则其函数指针不为空</span></span><br><span class="line">        CleanupFunction function;</span><br><span class="line">        <span class="type">void</span> *arg1;</span><br><span class="line">        <span class="type">void</span> *arg2;</span><br><span class="line">        CleanupNode *next;</span><br><span class="line">    };</span><br><span class="line">    CleanupNode cleanup_head_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 构造析构函数相关</span></span><br><span class="line">    <span class="built_in">Iterator</span>();</span><br><span class="line">    <span class="built_in">Iterator</span>(<span class="type">const</span> Iterator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Iterator &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Iterator &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果iterator是可用的，就返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将iterator定位到源的第一个key。如果源不为空，iterator就是有效的。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将iterator定位到源的最后一个key。如果源不为空，iterator就是有效的。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SeekToLast</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到某个键，当键不存在时，定位到比这个键大的第一个键</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">const</span> Slice &amp;target)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到下一项</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到上一项</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Prev</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前项的key。返回的slice的底层存储只在下一次修改iterator之前有效。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Slice <span class="title">key</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前项的value。返回的slice的底层存储只在下一次修改iterator之前有效。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Slice <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发生了错误，返回错误信息。否则返回ok状态。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Status <span class="title">status</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器被销毁时的回调函数，注册后可在销毁时调用</span></span><br><span class="line">    <span class="comment">// 这不是一个纯虚函数，所以不需要重写</span></span><br><span class="line">    <span class="comment">// function(void* arg1, void* arg2)，即一个函数指针</span></span><br><span class="line">    <span class="keyword">using</span> CleanupFunction = <span class="built_in">void</span> (*)(<span class="type">void</span> *arg1, <span class="type">void</span> *arg2);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RegisterCleanup</span><span class="params">(CleanupFunction function, <span class="type">void</span> *arg1, <span class="type">void</span> *arg2)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>Iterator</code>被设置成了纯虚基类，定义了其他种类的迭代器的接口。需要注意的是，<code>Iterator</code>存在清理函数，即在<code>Iterator</code>被销毁时调用这些函数。清理函数需要被注册，保存在一个单项链表中，最后会被统一调用。</p>
<p>然后我们来看一下其具体的实现，由于大部分是纯虚函数，所以实现部分比较少。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，将清理函数链表的头部指针置为NULL</span></span><br><span class="line">Iterator::<span class="built_in">Iterator</span>()</span><br><span class="line">{</span><br><span class="line">    cleanup_head_.function = <span class="literal">nullptr</span>;</span><br><span class="line">    cleanup_head_.next = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="comment">// 需要逐个调用链表中的清理函数</span></span><br><span class="line">Iterator::~<span class="built_in">Iterator</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!cleanup_head_.<span class="built_in">IsEmpty</span>())</span><br><span class="line">    {</span><br><span class="line">        cleanup_head_.<span class="built_in">Run</span>();</span><br><span class="line">        <span class="keyword">for</span> (CleanupNode *node = cleanup_head_.next; node != <span class="literal">nullptr</span>;)</span><br><span class="line">        {</span><br><span class="line">            node-&gt;<span class="built_in">Run</span>();</span><br><span class="line">            CleanupNode *next_node = node-&gt;next;</span><br><span class="line">            <span class="comment">// 释放内存</span></span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            node = next_node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将清理函数加入到清理函数链表中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Iterator::RegisterCleanup</span><span class="params">(CleanupFunction func, <span class="type">void</span> *arg1, <span class="type">void</span> *arg2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">assert</span>(func != <span class="literal">nullptr</span>);</span><br><span class="line">    CleanupNode *node;</span><br><span class="line">    <span class="keyword">if</span> (cleanup_head_.<span class="built_in">IsEmpty</span>())</span><br><span class="line">    {</span><br><span class="line">        node = &amp;cleanup_head_;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">CleanupNode</span>();</span><br><span class="line">        node-&gt;next = cleanup_head_.next;</span><br><span class="line">        cleanup_head_.next = node;</span><br><span class="line">    }</span><br><span class="line">    node-&gt;function = func;</span><br><span class="line">    node-&gt;arg1 = arg1;</span><br><span class="line">    node-&gt;arg2 = arg2;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>迭代器由于受限于本身的逻辑，所以实现还是非常简单的。唯一需要注意的就是关于清理函数的链表结构。</p>
<h3 id="空迭代器emptyiterator">空迭代器EmptyIterator</h3>
<p>这里还有一个很有意思的东西，就是其还定义了<code>EmptyIterator</code>这个类，而这个类实际上位于一个匿名名称空间中，<strong>名称的作用域被限制在当前文件中</strong>，所以外部文件想要创建这个类必须通过<code>NewEmptyIterator</code>这个函数。</p>
<p>我们来具体看一下这部分代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 注意这个匿名名称空间</span></span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承自Iterator</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">EmptyIterator</span> : <span class="keyword">public</span> Iterator</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">EmptyIterator</span>(<span class="type">const</span> Status &amp;s) : <span class="built_in">status_</span>(s) {}</span><br><span class="line">        ~<span class="built_in">EmptyIterator</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>{ <span class="keyword">return</span> <span class="literal">false</span>; }</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">const</span> Slice &amp;target)</span> <span class="keyword">override</span> </span>{}</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>{}</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>{}</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>{ <span class="built_in">assert</span>(<span class="literal">false</span>); }</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>{ <span class="built_in">assert</span>(<span class="literal">false</span>); }</span><br><span class="line">        <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Slice</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Slice</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>{ <span class="keyword">return</span> status_; }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Status status_;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">} <span class="comment">// anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建EmptyIterator</span></span><br><span class="line"><span class="function">Iterator *<span class="title">NewEmptyIterator</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EmptyIterator</span>(Status::<span class="built_in">OK</span>()); }</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator *<span class="title">NewErrorIterator</span><span class="params">(<span class="type">const</span> Status &amp;status)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EmptyIterator</span>(status);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总体而言没有啥难度。</p>
<h3 id="其他继承自iterator的迭代器">其他继承自Iterator的迭代器</h3>
<p>有很多迭代器都是继承自Iterator，我们下面来逐一分析。</p>
<h4 id="memtable-iterator">MemTable Iterator</h4>
<div class="note primary">
            <p>源码位于 db/memtable.h db/memtable.cc</p>
          </div>
<p>这个迭代器直接继承自Iterator，用于MemTable内部的迭代，即对Skiplist进行迭代操作。</p>
<ul>
<li>对于Seek操作，其实只需要调用Skiplist的查找操作即可</li>
<li>对于Next操作，因为Skiplist的最低层是一个单链表，所以只需要取这个链表的Next即可定位到下一个元素</li>
<li>对于Prev操作，稍微复杂一点，需要用查找函数找到当前元素的前一个元素</li>
</ul>
<h4 id="block-iterator">Block Iterator</h4>
<div class="note primary">
            <p>源码位于 table/block.h table/block.cc</p>
          </div>
<p>同样，这个迭代器也是继承自Iterator，用于Block内部的迭代，Block的数据部分是按照键的顺序排列的，所以Next的实现非常简单，只需要解析下一个Kv即可。</p>
<p>不过因为每个Kv的长度是不同的，没法直接定位到具体的某一个Kv，但是对于Seek操作，可以使用restart
point来进行快速定位。之前说过restart
point指向了某一个键，是一个稀疏索引。可以先对restart
point进行二分搜索，找到restart point
对应的键小于等于target最大的那个restart
point，如果键存在，则必在这个restart
point开始的16个键中，再从这个位置开始搜索，就可以找到对应的键。</p>
<h2 id="二级迭代器two-level-iterator">二级迭代器Two Level Iterator</h2>
<div class="note primary">
            <p>源码位于 table/two_level_iterator.h table/two_level_iterator.cc</p>
          </div>
<p>Two Level
Iterator其实就是使用两个Iterator，第一个Iterator是第二个Iterator的索引。先在第一层的Iterator做迭代，每次拿出一个元素后，根据这个元素调用回调函数，生成第二层的一个Iterator，然后第二层的Iterator迭代完成后，再在第一层取下一个元素。</p>
<img src="/2022/10/19/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-12/pic1.jpg" class="">
<p>对使用Two Level Iterator有两个要求:
第一层的Iterator的元素是有序排序的；
根据第一层的Iterator生成的第二层的Iterator也是全局有序的，也就是第一层第n个元素生成的第二层Iterator的最大元素小于第一层第n
+
1个元素生成的第二层Iterator的最小元素，并且第二层的每个Iterator内部也是有序的。</p>
<p>这个两级Iterator在设计的时候，是设计得非常通用的。但是本质上来说，却是只为Table::Iterator服务。</p>
<p>这个是由于Table的SST文件的格式带来的。因为SST文件关于key/value的内容分为两部分：</p>
<ul>
<li>data block</li>
<li>data block index</li>
</ul>
<p>前者data block里面存放了所有的数据，而data block
index里面存放了检索信息。</p>
<p>所以，data block index是作为第一级iterator，而data
block里面的key/value作为第二级iterator。</p>
<p><strong>实际上Two Level
Iterator也是继承自Iterator，但是由于其形式特殊，所以单独拿出来说</strong></p>
<p>另外，由于篇幅原因，就不详细剖析其源码了。</p>
<h3 id="其他使用two-level-iterator的迭代器">其他使用Two Level
Iterator的迭代器</h3>
<h4 id="sstable-iterator">SSTable Iterator</h4>
<div class="note primary">
            <p>源码位于 include/leveldb/table.h table/table.cc</p>
          </div>
<p>很明显Two Level Iterator就是为SSTable这种结构设计的。</p>
<p>生成迭代器用的这句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">Table::NewIterator</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options)</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewTwoLevelIterator</span>(</span><br><span class="line">        rep_-&gt;index_block-&gt;<span class="built_in">NewIterator</span>(rep_-&gt;options.comparator),</span><br><span class="line">        &amp;Table::BlockReader, <span class="built_in">const_cast</span>&lt;Table*&gt;(<span class="keyword">this</span>), options);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="concatenating-iterator">Concatenating Iterator</h4>
<div class="note primary">
            <p>源码位置: db/version_set.cc</p>
          </div>
<p>除了Table的迭代，Two Level Iterator还用在Concatenating
Iterator，这个迭代器可以对某一层（除了level
0）的SSTable进行迭代。第一层是一个Level File Num
Iterator，可以返回这一层的SSTable文件信息，而第二层则是SSTable
Iterator，使用GetFileIterator可以获取第二层的SSTable
Iterator。这样就可以对这一层的所有SSTable里的键从小到大迭代。</p>
<h2 id="合并迭代器merging-iterator">合并迭代器Merging Iterator</h2>
<div class="note primary">
            <p>源码位置: table/merger.h table/merger.cc</p>
          </div>
<p>Merger
Iterator可以用来组合多个Iterator，只需要保证每一个Iterator内部是有序，而不需要每一个Iterator都是全局有序的。Merger
Iterator会对所有Iterator进行迭代，就好像归并排序一样。找到每个Iterator头部最小的元素，next时，将最小的元素所在的Iterator
next，然后再次找到最小的元素。</p>
<p><strong>看成一个用于归并的迭代器即可</strong></p>
<p>由于这个和归并的过程很类似，也不详细叙述了。当然这个迭代器也是继承自Iterator的，毕竟接口都是一样的嘛。</p>
<h2 id="iteator整体结构概览">Iteator整体结构概览</h2>
<img src="/2022/10/19/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-12/pic2.jpg" class="">
<p>从上图可以看到：</p>
<ul>
<li>Two Level Iterator可以将Index Block Iterator和Data Block
Iterator组合成一个Table Iterator</li>
<li>Two Level Iterator可以将Level File Num Iterator和Table
Iterator组合成一个Concatenating
Iterator，这个Iterator迭代某一Level（Level &gt; 0）的所有SSTable</li>
<li>Merger Iteator可以组成一个Internal
Iterator，对整个数据库里的数据进行迭代，包括MemTable Iterator、Table
Iterator（Level 0）和Concatenating Iterator（Level &gt;
0)，注意这个Iterator是不会区分版本的，所有版本的数据都能看到</li>
<li>Internal Iterator做一定的处理后可以生成DBIter迭代整个数据库</li>
<li>Merger Iterator也可以组成一个Compaction Iterator，包括Table
Iterator（Level 0）和Concatenating Iterator（Level &gt;
0)，这主要是Compaction时使用。</li>
</ul>
<p>Internal
Iterator是会看到所有数据的，比如一个键覆盖了之前的值，这两个键值对都会看到。所以LevelDB里面还有一个DBIter，封装了对Internal
Iterator的访问，根据当前的SequenceNumber，只会看到可见的那个键。DBIter会对Internal
Iterator作封装，查找一个Key时会找到可见的SequenceNumber最大的那个Key，Next的话，会跳过所有User
Key相同的Internal Key直到一个User Key不同的并且可见的Internal
Key，这样迭代整个数据库不会出现重复的User Key。</p>
<p>这里面有些迭代器之前没有涉及到，不过看名字就指导是干什么的了。</p>
<h2 id="总结">总结</h2>
<ul>
<li>当想要在一个类中设置析构时的回调函数，可以使用函数指针并设置一个注册函数。<code>using CleanupFunction = void (*)(void *arg1, void *arg2);</code>这种别名的方式也很有效。且如果需要注册多个回调函数时，可以用单向链表来存储。</li>
<li>使用匿名名称空间来对外部文件隐藏类。</li>
</ul>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(16)--Compaction</title>
    <url>/2022/12/21/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-16/</url>
    <content><![CDATA[<h2 id="compaction">Compaction</h2>
<span id="more"></span>
<p>Compaction的功能无非是删除冗余的数据，精简SSTable文件的数量，再就是给Key排序，新生成的SSTable文件中的key是有序排列的。<strong>又因为等待Compaction的数据量和文件必然是庞大的，不可能通过一次Compaction就能搞定</strong>，这不现实，而且还会有不断地写操作进来，因此Compaction的时机也很有讲究。这些都是需要考虑的点。<br>
Compaction其实就是一个归并排序的过程，对多个输入的SSTable，多路归并，输出多个连续的SSTable，代替原来的文件。根据Level
0的特殊性，可以分为两种类型。</p>
<ul>
<li>level0 -&gt; level1</li>
<li>level(n) -&gt; level(n+1)</li>
</ul>
<p>其中level0 -&gt;
level1相对比较复杂，因为第0层存在不少key范围重叠的sstable，因此如果需要压缩时，先从第0层选择出几个重叠的sstable，然后从第1层选择一些同样重叠的sstable，然后多路归并即可。</p>
<img src="/2022/12/21/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-16/pic1.jpg" class="">
<p>而level(n) -&gt;
level(n+1)就比较简单，只需要在level(n)层选择一个块，然后再在level(n+1)层选择与上述块重叠的块一起参与多路归并即可。</p>
<img src="/2022/12/21/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-16/pic2.jpg" class="">
<p>LevelDB里有三种方式选择Compaction，分别是：</p>
<ul>
<li>Manual Compaction</li>
<li>Size Compaction</li>
<li>Seek Compaction</li>
</ul>
<p>其中Manual
Compaction就是手动触发一次Compaction，通过DBImpl::TEST_CompactRange触发，为了测试而存在。</p>
<p>Size Compaction的思想是比较简单直观的，对于Level
0的SSTable，因为键范围可能有重叠，所以需要控制文对件不超过4个，而于Level
n（n &gt;
0）的SSTable，总大小不能超过10^nMB，一旦这些条件不满足了，需要Compaction，将文件推向更高的Level，使得条件继续满足。</p>
<p>Size
Compaction就是根据这个思想触发的，计算每一Level实际大小相对于最大大小的比率，优先Compaction比率最大的Level。</p>
<p>SSTable文件的增减，只会在版本变更的时候出现，所以只需要在版本变更完成时，计算比率最大的Level，这个计算过程由VersionSet::LogAndApply里面的void
VersionSet::Finalize(Version*
v)来完成（打开数据库的时候也会计算一次）。</p>
<p>Size
Compaction是对一整个Level进行的，一个Level的SSTable可能会很多，无法在一次Compaction中完成，需要分多次完成。第一次完成最小键到某个键的范围内的Compaction，下一次再从某个键继续完成，以此类推。那么，需要记录下一次这个Level的Compaction从哪个键开始，这个信息会记录在compact_pointer_中。</p>
<p>对于Seek
Compaction而言，在搜索SSTable时，会找到键范围包含待搜索键的SSTable，从Level
0开始搜索，如果一个SSTable没有找到，会搜索下一个SSTable，直到找到或者确定无法找到为止。假设一次搜索，搜索了超过一个SSTable，那么标记第一个SSTable搜索了一次，假设这种情况出现了多次，说明这个文件和多个其它的文件键范围有重叠，影响了搜索的效率，需要Compaction这个文件，使得这种重叠减少，进而提高读取的效率。</p>
<p>Seek
Compaction就是基于这个原理实现的Compaction，是精确到每个SSTable的，一个FileMetaData里面包含一个字段allowed_seeks，会被设定为一个初始值，每当搜索SSTable时，如果第一个文件没有搜到，就会对第一个SSTable的allowed_seeks减1，当某个SSTable的allowed_seeks变为0时，那么这个SSTable就需要被Compaction。</p>
<p>allowed_seeks的减小发生在两个地方：</p>
<ul>
<li>DB::GET接口</li>
<li>DBIter数据库迭代过程中</li>
</ul>
<p>每次调用DB::GET时，如果需要搜索超过1个SSTable，就会对第一个SSTable的allowed_seeks减一。</p>
<p>而DBIter更特别一点，因为是迭代SSTable的，所以不会存在搜索一个键读取多个SSTable的情况，这边为了将Seek
Compaction考虑进去，采用了抽样的方式，每读取2MB的数据，会抽样一个键，模拟读取的情况，更新相应的allowed_seeks。</p>
<p>当某个文件的allowed_seeks减小到0了，就会将当前Version的file_to_compact_和file_to_compact_level设置为这个文件以及它的Level，后台线程就会来处理。</p>
<p>allowed_seeks的初始值设置就非常关键，它决定了一个文件多少次Seek后，才会被Compaction，LevelDB将这个值设为：static_cast<int>((f-&gt;file_size
/ 16384U))</int></p>
<p>这是有依据的，首先假设：</p>
<ul>
<li>一次Seek花费10ms</li>
<li>读写1MB的花费10ms （100MB/s）</li>
</ul>
<p>而Compaction
1MB的数据花费25MB左右的IO：当前Level读取1MB，上一个Level读取10-12MB，上一个Level写入10-12MB。<br>
所以25次Seek的开销和Compaction
1MB数据的开销一样，也就是1次Seek和40KB数据Compaction的开销一样，我们比较保守，假设1次Seek和16KB的数据的开销一样。那么设置为上面的值后，Seek的操作和Compaction操作的开销相同，那么Compaction不会过于频繁，影响性能。</p>
<h3 id="compaction实现">Compaction实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// A Compaction encapsulates information about a compaction.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compaction</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Version</span>; <span class="comment">// 友元类和私有的构造函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">VersionSet</span>;</span><br><span class="line">    <span class="built_in">Compaction</span>(<span class="type">const</span> Options *options, <span class="type">int</span> level);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> level_;                     <span class="comment">// Compaction文件所在的Level</span></span><br><span class="line">    <span class="type">uint64_t</span> max_output_file_size_; <span class="comment">// 生成文件最大值</span></span><br><span class="line">    Version *input_version_;        <span class="comment">// 输入的版本号</span></span><br><span class="line">    VersionEdit edit_;              <span class="comment">// Compaction结果保存的VersionEdit</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Each compaction reads inputs from "level_" and "level_+1"</span></span><br><span class="line">    <span class="comment">// 两个元素分别对应两层的sstable</span></span><br><span class="line">    std::vector&lt;FileMetaData *&gt; inputs_[<span class="number">2</span>]; <span class="comment">// The two sets of inputs</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// State used to check for number of overlapping grandparent files</span></span><br><span class="line">    <span class="comment">// (parent == level_ + 1, grandparent == level_ + 2)</span></span><br><span class="line">    <span class="comment">// 一些状态，用来检查是否存在重叠现象</span></span><br><span class="line">    std::vector&lt;FileMetaData *&gt; grandparents_;</span><br><span class="line">    <span class="type">size_t</span> grandparent_index_; <span class="comment">// Index in grandparent_starts_</span></span><br><span class="line">    <span class="type">bool</span> seen_key_;            <span class="comment">// Some output key has been seen</span></span><br><span class="line">    <span class="type">int64_t</span> overlapped_bytes_; <span class="comment">// Bytes of overlap between current output</span></span><br><span class="line">                               <span class="comment">// and grandparent files</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// State for implementing IsBaseLevelForKey</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// level_ptrs_ holds indices into input_version_-&gt;levels_: our state</span></span><br><span class="line">    <span class="comment">// is that we are positioned at one of the file ranges for each</span></span><br><span class="line">    <span class="comment">// higher level than the ones involved in this compaction (i.e. for</span></span><br><span class="line">    <span class="comment">// all L &gt;= level_ + 2).</span></span><br><span class="line">    <span class="type">size_t</span> level_ptrs_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Compaction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the level that is being compacted.  Inputs from "level"</span></span><br><span class="line">    <span class="comment">// and "level+1" will be merged to produce a set of "level+1" files.</span></span><br><span class="line">    <span class="comment">// 返回正在压缩的level</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">level</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> level_; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the object that holds the edits to the descriptor done</span></span><br><span class="line">    <span class="comment">// by this compaction.</span></span><br><span class="line">    <span class="comment">// 返回压缩完成后的VersionEdit</span></span><br><span class="line">    <span class="function">VersionEdit *<span class="title">edit</span><span class="params">()</span> </span>{ <span class="keyword">return</span> &amp;edit_; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "which" must be either 0 or 1</span></span><br><span class="line">    <span class="comment">// 输入的文件个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num_input_files</span><span class="params">(<span class="type">int</span> which)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> inputs_[which].<span class="built_in">size</span>(); }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the ith input file at "level()+which" ("which" must be 0 or 1).</span></span><br><span class="line">    <span class="comment">// 返回输入的文件</span></span><br><span class="line">    <span class="function">FileMetaData *<span class="title">input</span><span class="params">(<span class="type">int</span> which, <span class="type">int</span> i)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> inputs_[which][i]; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maximum size of files to build during this compaction.</span></span><br><span class="line">    <span class="comment">// 压缩中最大的文件数目</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">MaxOutputFileSize</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> max_output_file_size_; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is this a trivial compaction that can be implemented by just</span></span><br><span class="line">    <span class="comment">// moving a single input file to the next level (no merging or splitting)</span></span><br><span class="line">    <span class="comment">// 是否是平凡移动，即不经过任何归并直接移动到下一层</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsTrivialMove</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add all inputs to this compaction as delete operations to *edit.</span></span><br><span class="line">    <span class="comment">// 把所有的输入文件在一个VersionEdit中删掉</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddInputDeletions</span><span class="params">(VersionEdit *edit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true if the information we have available guarantees that</span></span><br><span class="line">    <span class="comment">// the compaction is producing data in "level+1" for which no data exists</span></span><br><span class="line">    <span class="comment">// in levels greater than "level+1".</span></span><br><span class="line">    <span class="comment">// 函数返回true表示user_key不存在于高层中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsBaseLevelForKey</span><span class="params">(<span class="type">const</span> Slice &amp;user_key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true iff we should stop building the current output</span></span><br><span class="line">    <span class="comment">// before processing "internal_key".</span></span><br><span class="line">    <span class="comment">// 在处理内部key之前需要停止构建当前输出的时候返回true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ShouldStopBefore</span><span class="params">(<span class="type">const</span> Slice &amp;internal_key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the input version for the compaction, once the compaction</span></span><br><span class="line">    <span class="comment">// is successful.</span></span><br><span class="line">    <span class="comment">// 压缩完成，释放输入版本</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReleaseInputs</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Compaction的文件在两个Level，假设为level_ 和level_ +
1，选定一个或几个SSTable Compaction时，就是选定了level_
的文件，然后调用void VersionSet::SetupOtherInputs(Compaction*
c)可以获取到level_ +
1中与level_中选定的文件有重叠的文件，这样输入的SSTable就选好了，一次Compactdoin要做的工作也就确定了。</p>
<p>void
DBImpl::BackgroundCompaction()首先会选定构造一个Compaction类的实例，也就是选定Compaction的任务。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">CompactMemTable</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Compaction *c;</span><br><span class="line">    <span class="type">bool</span> is_manual = (manual_compaction_ != <span class="literal">nullptr</span>);</span><br><span class="line">    InternalKey manual_end;</span><br><span class="line">    <span class="comment">// 先处理手动触发的压缩</span></span><br><span class="line">    <span class="keyword">if</span> (is_manual)</span><br><span class="line">    {</span><br><span class="line">        ManualCompaction *m = manual_compaction_;</span><br><span class="line">        c = versions_-&gt;<span class="built_in">CompactRange</span>(m-&gt;level, m-&gt;begin, m-&gt;end);</span><br><span class="line">        m-&gt;done = (c == <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            manual_end = c-&gt;<span class="built_in">input</span>(<span class="number">0</span>, c-&gt;<span class="built_in">num_input_files</span>(<span class="number">0</span>) - <span class="number">1</span>)-&gt;largest;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">Log</span>(options_.info_log,</span><br><span class="line">            <span class="string">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,</span><br><span class="line">            m-&gt;level, (m-&gt;begin ? m-&gt;begin-&gt;<span class="built_in">DebugString</span>().<span class="built_in">c_str</span>() : <span class="string">"(begin)"</span>),</span><br><span class="line">            (m-&gt;end ? m-&gt;end-&gt;<span class="built_in">DebugString</span>().<span class="built_in">c_str</span>() : <span class="string">"(end)"</span>),</span><br><span class="line">            (m-&gt;done ? <span class="string">"(end)"</span> : manual_end.<span class="built_in">DebugString</span>().<span class="built_in">c_str</span>()));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 选择一部分文件做压缩</span></span><br><span class="line">        c = versions_-&gt;<span class="built_in">PickCompaction</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Status status;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="comment">// 没有合并的文件</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Nothing to do</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;<span class="built_in">IsTrivialMove</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 处理一种特殊情况，也就是参与Compaction的文件，level_有一个文件，而level_ + 1 没有</span></span><br><span class="line">        <span class="comment">// 这时候只需要直接更改元数据，然后文件移动到level_ + 1即可，不需要多路归并</span></span><br><span class="line">        <span class="built_in">assert</span>(c-&gt;<span class="built_in">num_input_files</span>(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">        FileMetaData *f = c-&gt;<span class="built_in">input</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        c-&gt;<span class="built_in">edit</span>()-&gt;<span class="built_in">RemoveFile</span>(c-&gt;<span class="built_in">level</span>(), f-&gt;number);</span><br><span class="line">        c-&gt;<span class="built_in">edit</span>()-&gt;<span class="built_in">AddFile</span>(c-&gt;<span class="built_in">level</span>() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                           f-&gt;largest);</span><br><span class="line">        status = versions_-&gt;<span class="built_in">LogAndApply</span>(c-&gt;<span class="built_in">edit</span>(), &amp;mutex_);</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">RecordBackgroundError</span>(status);</span><br><span class="line">        }</span><br><span class="line">        VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">        <span class="built_in">Log</span>(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(f-&gt;number), c-&gt;<span class="built_in">level</span>() + <span class="number">1</span>,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">            status.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>(), versions_-&gt;<span class="built_in">LevelSummary</span>(&amp;tmp));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        CompactionState *compact = <span class="keyword">new</span> <span class="built_in">CompactionState</span>(c);</span><br><span class="line">        <span class="comment">// 调用DBImpl::DoCompactionWork做实际的Compaction</span></span><br><span class="line">        status = <span class="built_in">DoCompactionWork</span>(compact);</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">RecordBackgroundError</span>(status);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">CleanupCompaction</span>(compact);</span><br><span class="line">        c-&gt;<span class="built_in">ReleaseInputs</span>();</span><br><span class="line">        <span class="built_in">RemoveObsoleteFiles</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Done</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Ignore compaction errors found during shutting down</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">Log</span>(options_.info_log, <span class="string">"Compaction error: %s"</span>, status.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_manual)</span><br><span class="line">    {</span><br><span class="line">        ManualCompaction *m = manual_compaction_;</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            m-&gt;done = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!m-&gt;done)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// We only compacted part of the requested range.  Update *m</span></span><br><span class="line">            <span class="comment">// to the range that is left to be compacted.</span></span><br><span class="line">            m-&gt;tmp_storage = manual_end;</span><br><span class="line">            m-&gt;begin = &amp;m-&gt;tmp_storage;</span><br><span class="line">        }</span><br><span class="line">        manual_compaction_ = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Compaction *<span class="title">VersionSet::PickCompaction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Compaction *c;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">    <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (size_compaction)</span><br><span class="line">    {</span><br><span class="line">        level = current_-&gt;compaction_level_;</span><br><span class="line">        <span class="built_in">assert</span>(level &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert</span>(level + <span class="number">1</span> &lt; config::kNumLevels);</span><br><span class="line">        c = <span class="keyword">new</span> <span class="built_in">Compaction</span>(options_, level);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++)</span><br><span class="line">        {</span><br><span class="line">            FileMetaData *f = current_-&gt;files_[level][i];</span><br><span class="line">            <span class="keyword">if</span> (compact_pointer_[level].<span class="built_in">empty</span>() ||</span><br><span class="line">                icmp_.<span class="built_in">Compare</span>(f-&gt;largest.<span class="built_in">Encode</span>(), compact_pointer_[level]) &gt; <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">push_back</span>(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">            c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">push_back</span>(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction)</span><br><span class="line">    {</span><br><span class="line">        level = current_-&gt;file_to_compact_level_;</span><br><span class="line">        c = <span class="keyword">new</span> <span class="built_in">Compaction</span>(options_, level);</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">push_back</span>(current_-&gt;file_to_compact_);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    c-&gt;input_version_ = current_;</span><br><span class="line">    c-&gt;input_version_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        InternalKey smallest, largest;</span><br><span class="line">        <span class="built_in">GetRange</span>(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">        <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">        <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">        <span class="comment">// which will include the picked file.</span></span><br><span class="line">        current_-&gt;<span class="built_in">GetOverlappingInputs</span>(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">assert</span>(!c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">empty</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetupOtherInputs</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中DBImpl::DoCompactionWork是真正处理多路归并的函数，会考虑以下几点：</p>
<ul>
<li>迭代按照Internal Key的顺序进行，多个连续的Internal
Key里面可能包含相同的User Key，按照SequenceNumber降序排列</li>
<li>相同的User Key里只有第一个User
Key是有效的，因为它的SequenceNumber是最大的，覆盖了旧的User
Key，但是无法只保留第一个User Key，因为LevelDB支持多版本，旧的User
Key可能依然有线程可以引用，但是不再引用的User Key可以安全的删除</li>
<li>碰到一个删除时，并且它的SequenceNumber &lt;=
最新的Snapshot，会判断更高Level是否有这个User
Key存在。如果存在，那么无法丢弃这个删除操作，因为一旦丢弃了，更高Level原被删除的User
Key又可见了。如果不存在，那么可以安全的丢弃这个删除操作，这个键就找不到了</li>
<li>对于生成的SSTable文件，设置两个上限，哪个先达到，都会开始新的SSTable。一个就是2MB，另外一个就是判断上一Level和这个文件的重叠的文件数量，不超过10个，这是为了控制这个生成的文件Compaction的时候，不会和太多的上层文件重叠</li>
</ul>
<p>最后通过DBImpl::InstallCompactionResults安装Compaction的结果，将改删除的文件和改添加的文件更新到VersionEdit里，然后应用版本更新。</p>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(17)--Recover</title>
    <url>/2022/12/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-17/</url>
    <content><![CDATA[<h2 id="recover">Recover</h2>
<span id="more"></span>
<p>LevelDB打开需要做以下事情：</p>
<ul>
<li>如果数据库目录不存在，创建目录</li>
<li>加文件锁，锁住整个数据库</li>
<li>读取MANIFEST文件，恢复系统关闭时的元数据，也就是版本信息，或者新建MAINFEST文件</li>
<li>如果上一次关闭时，MemTable里有数据，或者Immutable
MemTable写入到SSTable未完成，那么需要做数据恢复，从WAL恢复数据</li>
<li>创建数据库相关的内存数据结构，如Version、VersionSet等</li>
</ul>
<img src="/2022/12/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-17/pic1.jpg" class="">
<p>打开数据库的接口是DB::Open，在其中调用DBImpl::Recover来完成主要的工作，如果调用成功，则创建MemTable和WAL相关的数据结构，重写MANIFEST文件。</p>
<p>而DBImpl::Recover做了以下事情：</p>
<ul>
<li>创建数据库目录</li>
<li>对这个数据库里面的LOCK文件加文件锁，LevelDB是单进程多线程的，需要保证每次只有一个进程能够打开数据库，方式就是使用了文件锁，如果有其它进程打开了数据库，那么加锁就会失败</li>
<li>如果数据库不存在，那么调用DBImpl::NewDB创建新的数据库</li>
<li>调用VersionSet::Recover来读取MANIFEST，恢复版本信息</li>
<li>根据版本信息，搜索数据库目录，找到关闭时没有写入到SSTable的日志，按日志写入顺序逐个恢复日志数据。DBImpl::RecoverLogFile会创建一个MemTable，开始读取日志信息，将日志的数据插入到MemTable，并根据需要调用DBImpl::WriteLevel0Table将MemTable写入到SSTable中，这里不过多介绍</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DB::Open</span><span class="params">(<span class="type">const</span> Options &amp;options, <span class="type">const</span> std::string &amp;dbname, DB **dbptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    *dbptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    DBImpl *impl = <span class="keyword">new</span> <span class="built_in">DBImpl</span>(options, dbname);</span><br><span class="line">    impl-&gt;mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    VersionEdit edit;</span><br><span class="line">    <span class="comment">// Recover handles create_if_missing, error_if_exists</span></span><br><span class="line">    <span class="type">bool</span> save_manifest = <span class="literal">false</span>;</span><br><span class="line">    Status s = impl-&gt;<span class="built_in">Recover</span>(&amp;edit, &amp;save_manifest);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; impl-&gt;mem_ == <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Create new log and a corresponding memtable.</span></span><br><span class="line">        <span class="comment">// 如果需要重写MANIFEST文件，那么做一个版本变更，这里面会创建一个新的MANIFEST</span></span><br><span class="line">        <span class="comment">// 将当前的版本信息写入，然后将edit的内容写入。</span></span><br><span class="line">        <span class="type">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">        WritableFile *lfile;</span><br><span class="line">        s = options.env-&gt;<span class="built_in">NewWritableFile</span>(<span class="built_in">LogFileName</span>(dbname, new_log_number),</span><br><span class="line">                                         &amp;lfile);</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            edit.<span class="built_in">SetLogNumber</span>(new_log_number);</span><br><span class="line">            impl-&gt;logfile_ = lfile;</span><br><span class="line">            impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">            impl-&gt;log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(lfile);</span><br><span class="line">            impl-&gt;mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(impl-&gt;internal_comparator_);</span><br><span class="line">            impl-&gt;mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; save_manifest)</span><br><span class="line">    {</span><br><span class="line">        edit.<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>); <span class="comment">// No older logs needed after recovery.</span></span><br><span class="line">        edit.<span class="built_in">SetLogNumber</span>(impl-&gt;logfile_number_);</span><br><span class="line">        s = impl-&gt;versions_-&gt;<span class="built_in">LogAndApply</span>(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        impl-&gt;<span class="built_in">RemoveObsoleteFiles</span>();</span><br><span class="line">        impl-&gt;<span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">    }</span><br><span class="line">    impl-&gt;mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">assert</span>(impl-&gt;mem_ != <span class="literal">nullptr</span>);</span><br><span class="line">        *dbptr = impl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">delete</span> impl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::Recover</span><span class="params">(VersionEdit *edit, <span class="type">bool</span> *save_manifest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore error from CreateDir since the creation of the DB is</span></span><br><span class="line">    <span class="comment">// committed only when the descriptor is created, and this directory</span></span><br><span class="line">    <span class="comment">// may already exist from a previous failed creation attempt.</span></span><br><span class="line">    env_-&gt;<span class="built_in">CreateDir</span>(dbname_); <span class="comment">// 创建数据库目录</span></span><br><span class="line">    <span class="built_in">assert</span>(db_lock_ == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 加文件锁，防止其他进程进入</span></span><br><span class="line">    Status s = env_-&gt;<span class="built_in">LockFile</span>(<span class="built_in">LockFileName</span>(dbname_), &amp;db_lock_);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果CURRENT文件不存在，说明需要新创建数据库</span></span><br><span class="line">    <span class="keyword">if</span> (!env_-&gt;<span class="built_in">FileExists</span>(<span class="built_in">CurrentFileName</span>(dbname_)))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (options_.create_if_missing)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">Log</span>(options_.info_log, <span class="string">"Creating DB %s since it was missing."</span>,</span><br><span class="line">                dbname_.<span class="built_in">c_str</span>());</span><br><span class="line">            s = <span class="built_in">NewDB</span>();</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">ok</span>())</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> Status::<span class="built_in">InvalidArgument</span>(</span><br><span class="line">                dbname_, <span class="string">"does not exist (create_if_missing is false)"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (options_.error_if_exists)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> Status::<span class="built_in">InvalidArgument</span>(dbname_,</span><br><span class="line">                                           <span class="string">"exists (error_if_exists is true)"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 读取MANIFEST文件进行版本信息的恢复</span></span><br><span class="line">    s = versions_-&gt;<span class="built_in">Recover</span>(save_manifest);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">SequenceNumber <span class="title">max_sequence</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recover from all newer log files than the ones named in the</span></span><br><span class="line">    <span class="comment">// descriptor (new log files may have been added by the previous</span></span><br><span class="line">    <span class="comment">// incarnation without registering them in the descriptor).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note that PrevLogNumber() is no longer used, but we pay</span></span><br><span class="line">    <span class="comment">// attention to it in case we are recovering a database</span></span><br><span class="line">    <span class="comment">// produced by an older version of leveldb.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> min_log = versions_-&gt;<span class="built_in">LogNumber</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> prev_log = versions_-&gt;<span class="built_in">PrevLogNumber</span>();</span><br><span class="line">    std::vector&lt;std::string&gt; filenames;</span><br><span class="line">    s = env_-&gt;<span class="built_in">GetChildren</span>(dbname_, &amp;filenames);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    std::set&lt;<span class="type">uint64_t</span>&gt; expected;</span><br><span class="line">    versions_-&gt;<span class="built_in">AddLiveFiles</span>(&amp;expected);</span><br><span class="line">    <span class="type">uint64_t</span> number;</span><br><span class="line">    FileType type;</span><br><span class="line">    std::vector&lt;<span class="type">uint64_t</span>&gt; logs;</span><br><span class="line">    <span class="comment">// 之前的MANIFEST恢复，会得到版本信息，里面包含了之前的log number</span></span><br><span class="line">    <span class="comment">// 搜索文件系统里的log，如果这些日志的编号 &gt;= 这个log number，那么这些</span></span><br><span class="line">    <span class="comment">// 日志都是关闭时丢失的数据，需要恢复，这里将日志按顺序存储在logs里面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个恢复日志的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; filenames.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ParseFileName</span>(filenames[i], &amp;number, &amp;type))</span><br><span class="line">        {</span><br><span class="line">            expected.<span class="built_in">erase</span>(number);</span><br><span class="line">            <span class="keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</span><br><span class="line">                logs.<span class="built_in">push_back</span>(number);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!expected.<span class="built_in">empty</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">        std::<span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">"%d missing files; e.g."</span>,</span><br><span class="line">                      <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(expected.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(buf, <span class="built_in">TableFileName</span>(dbname_, *(expected.<span class="built_in">begin</span>())));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recover in the order in which the logs were generated</span></span><br><span class="line">    std::<span class="built_in">sort</span>(logs.<span class="built_in">begin</span>(), logs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; logs.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        s = <span class="built_in">RecoverLogFile</span>(logs[i], (i == logs.<span class="built_in">size</span>() - <span class="number">1</span>), save_manifest, edit,</span><br><span class="line">                           &amp;max_sequence);</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The previous incarnation may not have written any MANIFEST</span></span><br><span class="line">        <span class="comment">// records after allocating this log number.  So we manually</span></span><br><span class="line">        <span class="comment">// update the file number allocation counter in VersionSet.</span></span><br><span class="line">        versions_-&gt;<span class="built_in">MarkFileNumberUsed</span>(logs[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (versions_-&gt;<span class="built_in">LastSequence</span>() &lt; max_sequence)</span><br><span class="line">    {</span><br><span class="line">        versions_-&gt;<span class="built_in">SetLastSequence</span>(max_sequence);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而新建数据库时，会调用DBImpl::NewDB，一个新的数据库没有任何数据，所以不需要日志和SSTable，只需要有一个MANIFEST文件，包含一些元数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::NewDB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    VersionEdit new_db;</span><br><span class="line">    <span class="comment">// 保存比较器的名称，下次打开时需要用相同的名称打开</span></span><br><span class="line">    new_db.<span class="built_in">SetComparatorName</span>(<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Name</span>());</span><br><span class="line">    new_db.<span class="built_in">SetLogNumber</span>(<span class="number">0</span>); <span class="comment">// 分配日志文件的编号为0</span></span><br><span class="line">    new_db.<span class="built_in">SetNextFile</span>(<span class="number">2</span>);  <span class="comment">// 下一个待分配的文件编号是2，因为1分配给了MANIFEST文件</span></span><br><span class="line">    new_db.<span class="built_in">SetLastSequence</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建MANIFEST文件，将VersionEdit写入</span></span><br><span class="line">    <span class="type">const</span> std::string manifest = <span class="built_in">DescriptorFileName</span>(dbname_, <span class="number">1</span>);</span><br><span class="line">    WritableFile *file;</span><br><span class="line">    Status s = env_-&gt;<span class="built_in">NewWritableFile</span>(manifest, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    {</span><br><span class="line">        <span class="function">log::Writer <span class="title">log</span><span class="params">(file)</span></span>;</span><br><span class="line">        std::string record;</span><br><span class="line">        new_db.<span class="built_in">EncodeTo</span>(&amp;record);</span><br><span class="line">        s = log.<span class="built_in">AddRecord</span>(record);</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            s = file-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            s = file-&gt;<span class="built_in">Close</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">delete</span> file;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Make "CURRENT" file that points to the new manifest file.</span></span><br><span class="line">        <span class="comment">// 让CURRENT文件指向这个MANIFEST文件</span></span><br><span class="line">        s = <span class="built_in">SetCurrentFile</span>(env_, dbname_, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        env_-&gt;<span class="built_in">RemoveFile</span>(manifest);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到DBImpl::NewDB非常简单，就是创建一个MANIFEST文件，将以下信息写入到MANIFEST文件：</p>
<ul>
<li>比较器名称</li>
<li>当前日志的编号</li>
<li>下一个使用的文件编号</li>
<li>上一个使用的SequenceNumber</li>
<li>最后CURRENT指向新创建的MANIFEST文件</li>
</ul>
<p>而VersionSet::Recover完成MANIFEST文件的读取和版本的构造，需要知道数据库里有哪些SSTable文件，每个文件处于哪个Level，当前日志的编号等等信息。</p>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(2)--分析levelDB的架构</title>
    <url>/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-2/</url>
    <content><![CDATA[<h2 id="分析leveldb的架构">分析levelDB的架构</h2>
<span id="more"></span>
<hr>
<h3 id="leveldb的组件">levelDB的组件</h3>
<p>levelDB由以下几个组件组成：<code>MemTable</code>，<code>Immutable MemTable</code>，<code>WAL</code>，<code>SSTable</code>，<code>Manifest</code>，<code>Current</code>，<code>Compaction</code></p>
<img src="/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-2/pic1.jpg" class="">
<div class="note primary">
            <p><strong><em>MemTable</em></strong>：这个组件是操作的入口，是常驻内存的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>树，所有的写入操作都将被直接写入到此树中。另外这棵树是有序的，可以对其进行快速查找和遍历，也支持数据库的操作。</p><p>它本身就可以看成是一个数据库，相当于levelDB内置的redis。</p><p>当其占用空间到达一个阈值时，就转换成一个<code>Immutable MemTable</code>供后续合并，同时生成一个新的<code>MemTable</code>来继续执行下去。</p>
          </div>
<div class="note primary">
            <p><strong><em>ImmutableMemTable</em></strong>：这个组件是内存与磁盘的交互组件。它与<code>MemTable</code>完全一样，仅仅在于其是只读结构。</p><p>当生成<code>Immutable MemTable</code>后，后台线程会将其创建出一个<code>SSTable</code>，并归并到磁盘中。</p>
          </div>
<div class="note primary">
            <p><strong><em>WAL</em></strong>：即write aheadlog，在写入到数据库之前，先写入到日志文件。</p><p>这样做的目的是为了不丢失数据，由于<code>MemTable</code>位于内存中，写入一些数据后，其不能立刻同步到磁盘中，如果突然掉电，这样写入的数据就丢失了。而<code>WAL</code>位于磁盘中，不过由于日志结构是顺序写，因此其写入效率也是很高的。</p><p>每次数据库重启时都需要读取日志并进行恢复，如果日志结构太大，启动数据库的速度就会很慢。</p>
          </div>
<div class="note primary">
            <p><strong><em>SSTable</em></strong>：即Sorted StringTable。这是比较重要的结构，虽然数据库的读写是基于<code>MemTable</code>的，但是其位于内存中，内存不是无限大的，需要被持久化到磁盘中。当创建出<code>Immutable MemTable</code>后，就会对其创建出一个<code>SSTable</code>来保存数据到磁盘上。</p><p>其有序体现在键是有序的，同时各级的<code>SSTable</code>文件之间也是有序的，即键不重叠。这样做的目的是为了保持良好的读速度。由于levelDB不需要更新磁盘数据结构，因此不需要使用B+树。当数据存储在磁盘上键有序，这样就可以使用高效的二分查找；而键不重叠则避免二分查找读多个磁盘块。</p><p>同时，将<code>MemTable</code>写入到磁盘上的<code>SSTable</code>后就可以释放掉这部分的日志空间，减少下次启动时的恢复速度。</p><p>但是当<code>SSTable</code>数目变多时，可能会导致键的范围出现重叠，这时候可以进行合并，将多个小的<code>SSTable</code>合并成一个大的，由于<code>SSTable</code>是有序的，其合并速度也是十分的快。</p>
          </div>
<div class="note primary">
            <p><strong><em>Manifest</em></strong>：LevelDB中有版本Version的概念，一个版本Version主要记录了每一层Level中所有文件的元数据。随着Compaction的进行，元数据会改变，所以每次还需要将改变的元数据写到MANIFEST中。</p>
          </div>
<div class="note primary">
            <p><strong><em>Current</em></strong>：本文件指向当前的<code>Manifest</code>文件，由于可能存在多个<code>Manifest</code>文件，<code>Current</code>文件指向我们当前需要用到的<code>Manifest</code>文件。</p>
          </div>
<div class="note primary">
            <p><strong><em>Compaction</em></strong>：作用是将多个小的<code>SSTable</code>合并成一个大的<code>SSTable</code>。这样可以解决查找的效率问题。</p><p>每个大的<code>SSTable</code>是键有序的，可以将其再次分成多个小的键不重叠的<code>SSTable</code>，这样每次合并时只需要合并小的<code>SSTable</code>即可，而不需要去读取一个很大的<code>SSTable</code>。</p><p>另外，由于<code>level-0</code>是直接由内存写入的，其多个<code>SSTable</code>可能存在键重叠现象，但是更高层的<code>level</code>是不存在键重叠现象的。</p>
          </div>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(3)--levelDB的内存管理策略</title>
    <url>/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-3/</url>
    <content><![CDATA[<h2 id="leveldb的内存管理策略">levelDB的内存管理策略</h2>
<span id="more"></span>
<hr>
<h3 id="leveldb的内存管理类arena">levelDB的内存管理类Arena</h3>
<div class="note primary">
            <p>源代码位置：utils/arena.cc utils/arena.h</p>
          </div>
<p>对于数据库而言，内存管理策略是十分重要的，因为其正是需要为存入的数据分配内存，倘若直接使用new/delete这样每次插入数据都单独去分配内存，效率是很低的，同时由于每条插入的数据的大小并不一致，导致会出现许多的内存碎片。</p>
<p>对于levelDB这样一个billion级别的数据库，显然其不能采取这样的策略。</p>
<p>在levelDB中，由于只有<code>MemTable</code>位于内存且需要频繁的插入，所以它最需要内存管理，levelDB中用于内存管理的类为<code>Arena</code>，每个<code>MemTable</code>都绑定一个<code>Arena</code>。而其余的部分则直接使用new/delete，因为这些部分要么是不频繁，要么是块本身就很大。</p>
<h4 id="arena类">Arena类</h4>
<div class="note info">
            <p><strong>基本思想</strong>：先分配出一大块内存，然后当需要用到内存时，就在这一大块内存中移动指针，这样就能解决小块内存频繁调用new和内存碎片的问题，不过缺点是有一部分内存被浪费掉。</p>
          </div>
<p>我们可以先来看一下arena类的头文件捏。从头文件中可以很明显的看到其用于内存分配的方法就是公有函数<code>Allocate</code>和<code>AllocateAligned</code>，区别是后者提供内存对齐，这对效率也有提升。</p>
<h5 id="头文件">头文件</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils/arena.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Arena</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Arena</span>();                                  <span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">Arena</span>(<span class="type">const</span> Arena &amp;) = <span class="keyword">delete</span>;            <span class="comment">//关闭复制构造函数</span></span><br><span class="line">    Arena &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Arena &amp;) = <span class="keyword">delete</span>; <span class="comment">//关闭使用=的拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">Arena</span>();                                 <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个指针指向新分配的内存区域，即内部的分配内存的方法</span></span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同Allocate，但是提供了内存对齐策略</span></span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回目前从内存中申请的内存大小，由于memory_usage_是原子操作</span></span><br><span class="line">    <span class="comment">//此处的memory_order_relaxed表示宽松内存序，即任何一个线程可以任意更新</span></span><br><span class="line">    <span class="comment">//不用同步到其他线程中，下一个访问该元素的线程获取到更新之后的值</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">MemoryUsage</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> memory_usage_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes)</span></span>;       <span class="comment">//获取新分配的内存，被AllocateAligned和Allocate调用</span></span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span></span>; <span class="comment">//new函数的包装，被AllocateFallback调用</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *alloc_ptr_;                  <span class="comment">//当前内存块未使用内存的首地址</span></span><br><span class="line">    <span class="type">size_t</span> alloc_bytes_remaining_;     <span class="comment">//当前内存块中未使用空间的大小</span></span><br><span class="line">    std::vector&lt;<span class="type">char</span> *&gt; blocks_;       <span class="comment">//存储每一次向系统请求分配的内存块的指针</span></span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; memory_usage_; <span class="comment">//记录已申请全部内存使用的数目，注意此操作是原子的</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>头文件定义了Arena这个类，在类中只有3个公有方法，分别用于返回小内存、对齐的小内存、当前类占用的空间。</p>
<h5 id="实现文件">实现文件</h5>
<p>分析完了头文件，我们接下来看一下它的cpp实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*=============类的构造析构等基础函数=============*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kBlockSize = <span class="number">4096</span>; <span class="comment">//一个内存块的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，默认的构造函数直接对内部的几个元素进行初始化</span></span><br><span class="line">Arena::<span class="built_in">Arena</span>()</span><br><span class="line">    : <span class="built_in">alloc_ptr_</span>(<span class="literal">nullptr</span>), <span class="built_in">alloc_bytes_remaining_</span>(<span class="number">0</span>), <span class="built_in">memory_usage_</span>(<span class="number">0</span>) {}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数，注意，由于类中存在一个vector数组存储了每次分配的内存的块的指针</span></span><br><span class="line"><span class="comment">// 所以析构的时候遍历这个数组然后逐个delete</span></span><br><span class="line">Arena::~<span class="built_in">Arena</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; blocks_.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">delete</span>[] blocks_[i];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============公有接口=============*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配小内存的函数，这个函数是此类对外的接口，被写成内联函数效率更高</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> *<span class="title">Arena::Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 首先，断言申请的内存数目是否合法</span></span><br><span class="line">    <span class="built_in">assert</span>(bytes &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当从内存申请的整块中仍然存在空间时，就直接从这个块中分配</span></span><br><span class="line">    <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">char</span> *result = alloc_ptr_;</span><br><span class="line">        alloc_ptr_ += bytes;</span><br><span class="line">        alloc_bytes_remaining_ -= bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 否则调用AllocateFallback进行分配（从内存中申请空间去分配）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用对齐的方式去分配内存，只比Allocate多出计算需要分配内存的步骤</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">Arena::AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 首先设置对齐的字节数，(sizeof(void *)可以计算出当前机器的每个指针的字节数</span></span><br><span class="line">    <span class="comment">// 最多8字节对齐，当当前机器指针的字节数不足8字节时，会使用当前机器的字节数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> align = (<span class="built_in">sizeof</span>(<span class="type">void</span> *) &gt; <span class="number">8</span>) ? <span class="built_in">sizeof</span>(<span class="type">void</span> *) : <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态断言，在编译时执行断言</span></span><br><span class="line">    <span class="comment">// a&amp;(a-1)的功能是去掉右边的1(二进制)，所以当不是2的幂次方时，去掉1后就非0</span></span><br><span class="line">    <span class="built_in">static_assert</span>((align &amp; (align - <span class="number">1</span>)) == <span class="number">0</span>,</span><br><span class="line">                  <span class="string">"Pointer size should be a power of 2"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这里的位运算等价于求余运算</span></span><br><span class="line">    <span class="comment">// 因为上面这个断言已经确保了align是2个幂次方，因此align-1是一个右侧均为1的掩模</span></span><br><span class="line">    <span class="comment">// 两者相与的结果就可以快速求出alloc_ptr_%align</span></span><br><span class="line">    <span class="comment">// 但注意，此时两者能够等价的重要原因是align是2的幂次方</span></span><br><span class="line">    <span class="comment">// 此处还有强制类型转换，也就是把取模结果转换成uintptr_t</span></span><br><span class="line">    <span class="type">size_t</span> current_mod = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当取模结果不是0就表示需要分配的内存是2的整数幂，所以需要额外分配一些内存</span></span><br><span class="line">    <span class="type">size_t</span> slop = (current_mod == <span class="number">0</span> ? <span class="number">0</span> : align - current_mod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出总的需要的内存</span></span><br><span class="line">    <span class="type">size_t</span> needed = bytes + slop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-------- 至此，计算出需要对齐时分配的内存后，就与Allocate无异 --------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当从内存申请的整块中仍然存在空间时，就直接从这个块中分配</span></span><br><span class="line">    <span class="keyword">if</span> (needed &lt;= alloc_bytes_remaining_)</span><br><span class="line">    {</span><br><span class="line">        result = alloc_ptr_ + slop;</span><br><span class="line">        alloc_ptr_ += needed;</span><br><span class="line">        alloc_bytes_remaining_ -= needed;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 此处存在一点点区别，AllocateFallback申请的参数时bytes而不是对齐后的need</span></span><br><span class="line">        <span class="comment">// 这是因为AllocateFallback调用的是new/delete，总是内存对齐的</span></span><br><span class="line">        result = <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里再做一下断言，保证对齐</span></span><br><span class="line">    <span class="built_in">assert</span>((<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(result) &amp; (align - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============私有接口=============*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有方法：回调函数，用于当当前块内内存不足时申请内存的策略</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">Arena::AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 当需要的内存超过kBlockSize的1/4，（默认1kb时），申请和bytes相同大小的内存</span></span><br><span class="line">    <span class="comment">// 这样做是因为当需要用到的内存已经超过块大小的1/4了，那么之前剩余的块可能还有不少</span></span><br><span class="line">    <span class="comment">// 如果新分配一个块那么就可能会浪费比较多的内存</span></span><br><span class="line">    <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">char</span> *result = <span class="built_in">AllocateNewBlock</span>(bytes);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当需要的内存不足kBlockSize的1/4，（默认1kb时），就申请一个整个的块（默认4kb）</span></span><br><span class="line">    <span class="comment">// 然后从这里面分配内存</span></span><br><span class="line">    <span class="comment">// 但注意，进入到此函数里只说明原来的块不足以分配现在需要的内存，但其可能仍然剩余内存</span></span><br><span class="line">    <span class="comment">// 此处的策略是直接把原来的内存块中可能剩余的内存给浪费掉</span></span><br><span class="line">    <span class="comment">// 毕竟此时需要分配的内存不到1/4个块，说明原来的块也剩下不了多少内存了</span></span><br><span class="line">    alloc_ptr_ = <span class="built_in">AllocateNewBlock</span>(kBlockSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这几部就是分配了一个块后做块内的内存分配</span></span><br><span class="line">    alloc_bytes_remaining_ = kBlockSize;</span><br><span class="line">    <span class="type">char</span> *result = alloc_ptr_;</span><br><span class="line">    alloc_ptr_ += bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有方法：向系统申请内存</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 就是对new的一层包装，同时更新一下类内的参数</span></span><br><span class="line">    <span class="type">char</span> *result = <span class="keyword">new</span> <span class="type">char</span>[block_bytes];</span><br><span class="line">    blocks_.<span class="built_in">push_back</span>(result);</span><br><span class="line">    memory_usage_.<span class="built_in">fetch_add</span>(block_bytes + <span class="built_in">sizeof</span>(<span class="type">char</span> *),</span><br><span class="line">                            std::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<img src="/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-3/pic1.jpg" class="">
<p>实际上总体来说思路如下:</p>
<p>1、当调用<code>AllocateAligned</code>或<code>Allocate</code>时，先判断当前分配内存块中剩余的内存是否有足够的内存去分配新的内存（以及计算内存对齐）；如果足以容纳，则直接从当前内存块中提取内存作为所需内存使用。若是不足以容纳则调用<code>AllocateFallback</code>去申请内存并分配。</p>
<p>2、在<code>AllocateFallback</code>中，先判断需要申请的内存是否大于1K，若是大于1K，直接<code>AllocateNewBlock</code>向系统申请足够的内存以供使用。若是小于1K，则调用<code>AllocateNewBlock</code>分配一个块，并在这个块中分配需要的内存。</p>
<p>3、<code>AllocateNewBlock</code>使用系统new操作符向系统申请内存，并更新类内参数。当所分配的内存为4kb时，会将这个申请的内存作为新的内存块(此时旧的内存块中即使还有内存未使用，也不会再拿来使用，因为alloc_ptr_会指向新申请的内存块)。然后再向新申请的内存块提取内存以供使用。</p>
<p>这里Level对于小于1K的内存申请才向内存池提取内存，主要是连续多次申请小的内存会容易导致内存碎片，影响系统的性能。并且多次的new和delete比较耗时(不断的构造和析构)，会付出额外的空间和时间。</p>
<hr>
<h2 id="总结部分">总结部分</h2>
<table>
<colgroup>
<col style="width: 38%">
<col style="width: 61%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">方法/变量</th>
<th style="text-align: center;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Arena()</td>
<td style="text-align: center;">构造函数</td>
</tr>
<tr class="even">
<td style="text-align: center;">~Arena()</td>
<td style="text-align: center;">析构函数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">char* Allocate(size_t bytes)</td>
<td style="text-align: center;">提供bytes大小的内存</td>
</tr>
<tr class="even">
<td style="text-align: center;">char* AllocateAligned(size_t bytes)</td>
<td style="text-align: center;">提供内存对齐的bytes大小的内存</td>
</tr>
<tr class="odd">
<td style="text-align: center;">size_t MemoryUsage() const</td>
<td style="text-align: center;">返回当前申请的内存大小</td>
</tr>
<tr class="even">
<td style="text-align: center;">char* AllocateFallback(size_t
bytes)</td>
<td style="text-align: center;">当块中内存不够时向系统申请内存接口，由Allocate或AllocateAligned调用</td>
</tr>
<tr class="odd">
<td style="text-align: center;">char* AllocateNewBlock(size_t
block_bytes)</td>
<td style="text-align: center;">系统new的包装函数，由AllocateFallback调用</td>
</tr>
<tr class="even">
<td style="text-align: center;">alloc_ptr_</td>
<td style="text-align: center;">当前内存块中未使用空间的首地址</td>
</tr>
<tr class="odd">
<td style="text-align: center;">alloc_bytes_remaining_</td>
<td style="text-align: center;">当前内存块中剩余的空间</td>
</tr>
<tr class="even">
<td style="text-align: center;">blocks_</td>
<td style="text-align: center;">new出来的内存的首地址组成的vector数组</td>
</tr>
<tr class="odd">
<td style="text-align: center;">memory_usage_</td>
<td style="text-align: center;">向系统已申请的内存大小</td>
</tr>
</tbody>
</table>
<div class="note primary">
            <h3 id="编程小技巧">编程小技巧</h3><p><code>a &amp; (a - 1)</code>：去掉a在二进制表示中最右边的1</p><p><code>A &amp; (B - 1) = A % B</code>：此公式仅在B是2的幂次方时成立</p>
          </div>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(5)--字符串Slice</title>
    <url>/2022/09/20/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-5/</url>
    <content><![CDATA[<h2 id="leveldb的字符串slice">levelDB的字符串Slice</h2>
<span id="more"></span>
<hr>
<p>上次我们分析编码解码的时候，注意到其中使用的参数有些是<code>Slice</code>类型，这个类型就是levelDB中自己封装的一个轻量级字符串类，其只包含了指向字符串的指针和字符串的长度。</p>
<div class="note primary">
            <p>Slice可以理解成切片，因为其指向底层字符串的首地址，并且标定出长度。</p><p>但是需要注意的是，Slice中不涉及对字符串的销毁和创建，它只是<strong>指向</strong>。因此调用Slice对象时<strong>必须确保底层的字符串没有被销毁</strong>。</p>
          </div>
<h3 id="源码解析部分">源码解析部分</h3>
<div class="note primary">
            <p>源码位置： <code>utils/slice.h</code></p>
          </div>
<p>没错，Slice对象只有一个头文件，全部方法都是内联的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> Slice</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:               <span class="comment">//只有两个私有成员</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data_; <span class="comment">// 指向位于底层的字符串</span></span><br><span class="line">    <span class="type">size_t</span> size_;      <span class="comment">// 标识出字符串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/****start一些构造函数start****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空的构造函数</span></span><br><span class="line">    <span class="built_in">Slice</span>() : <span class="built_in">data_</span>(<span class="string">""</span>), <span class="built_in">size_</span>(<span class="number">0</span>) {}</span><br><span class="line">    <span class="comment">// 对字符串d进行0:n的切片，即d[:n]</span></span><br><span class="line">    <span class="built_in">Slice</span>(<span class="type">const</span> <span class="type">char</span> *d, <span class="type">size_t</span> n) : <span class="built_in">data_</span>(d), <span class="built_in">size_</span>(n) {}</span><br><span class="line">    <span class="comment">// 对string类型s进行0:n的切片，即s[:n]</span></span><br><span class="line">    <span class="built_in">Slice</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">data_</span>(s.<span class="built_in">data</span>()), <span class="built_in">size_</span>(s.<span class="built_in">size</span>()) {}</span><br><span class="line">    <span class="comment">// 指向字符串s</span></span><br><span class="line">    <span class="built_in">Slice</span>(<span class="type">const</span> <span class="type">char</span> *s) : <span class="built_in">data_</span>(s), <span class="built_in">size_</span>(<span class="built_in">strlen</span>(s)) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数和'='运算符使用的默认的即可</span></span><br><span class="line">    <span class="built_in">Slice</span>(<span class="type">const</span> Slice &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Slice &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Slice &amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****end一些构造函数end****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*下面是一些公有接口*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向切片字符串的起始位置</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">data</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> data_; }</span><br><span class="line">    <span class="comment">// 返回长度</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> size_; }</span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> size_ == <span class="number">0</span>; }</span><br><span class="line">    <span class="comment">// 执行类似字符串的str[i]的访问</span></span><br><span class="line">    <span class="type">char</span> <span class="keyword">operator</span>[](<span class="type">size_t</span> n) <span class="type">const</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">assert</span>(n &lt; <span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> data_[n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除切片</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        data_ = <span class="string">""</span>;</span><br><span class="line">        size_ = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除切片前n个字节</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">assert</span>(n &lt;= <span class="built_in">size</span>());</span><br><span class="line">        data_ += n;</span><br><span class="line">        size_ -= n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将切片创建成string类</span></span><br><span class="line">    <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> std::<span class="built_in">string</span>(data_, size_); }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与另一个切片比较</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> Slice &amp;b)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此切片是否以切片x开头</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">starts_with</span><span class="params">(<span class="type">const</span> Slice &amp;x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> ((size_ &gt;= x.size_) &amp;&amp; (<span class="built_in">memcmp</span>(data_, x.data_, x.size_) == <span class="number">0</span>));</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断x与y是否相等</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Slice &amp;x, <span class="type">const</span> Slice &amp;y)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">return</span> ((x.<span class="built_in">size</span>() == y.<span class="built_in">size</span>()) &amp;&amp;</span><br><span class="line">            (<span class="built_in">memcmp</span>(x.<span class="built_in">data</span>(), y.<span class="built_in">data</span>(), x.<span class="built_in">size</span>()) == <span class="number">0</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Slice &amp;x, <span class="type">const</span> Slice &amp;y) { <span class="keyword">return</span> !(x == y); }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较字符串的函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Slice::compare</span><span class="params">(<span class="type">const</span> Slice &amp;b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> min_len = (size_ &lt; b.size_) ? size_ : b.size_;</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">memcmp</span>(data_, b.data_, min_len);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (size_ &lt; b.size_)</span><br><span class="line">            r = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size_ &gt; b.size_)</span><br><span class="line">            r = +<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Slice的实现还是非常简单的，而且它提供了非常丰富的接口。</p>
<p>但是Slice的实现我们也能看到一些问题：</p>
<ul>
<li>由于Slice类不涉及内存的分配和销毁，也不检查内存是否合法，因此在调用的时候需要特别注意。</li>
<li>Slice类不涉及原子操作，虽然大部分都是const的读取，但是在多线程中将某一个Slice对象进行修改，则所有线程都需要执行同步。</li>
</ul>
<p>关于第二点，源文件中也有说明</p>
<div class="note info">
            <p>Multiple threads can invoke const methods on a Slice without externalsynchronization, but if any of the threads may call a non-const method,all threads accessing the same Slice must use externalsynchronization.</p><p>多线程在调用const方法后可以不同步，但是如果调用非const方法，所有访问被修改的Slice的线程必须执行同步。</p>
          </div>
<h2 id="总结部分">总结部分</h2>
<div class="note primary">
            <h3 id="编程小技巧">编程小技巧</h3><ul><li>C++可以在类内或类外重载运算符，而在类内重载又可以分为'类内隐式重载'和在'类外显示重载'，这几种方式区别如下。当然，此处不考虑友元。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">x</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>==(x&amp; other){}; <span class="comment">// 类内隐式</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="keyword">inline</span> x::<span class="keyword">operator</span>==(x&amp; other){};<span class="comment">// 类外显示</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="keyword">inline</span> <span class="keyword">operator</span>==(x&amp; <span class="keyword">this</span>, x&amp; other){};<span class="comment">//类外重载</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
          </div>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(6)--levelDB组件</title>
    <url>/2022/09/22/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-6/</url>
    <content><![CDATA[<h2 id="leveldb的组件comparatorstatusenvoptions">levelDB的组件Comparator、Status、Env、Options</h2>
<span id="more"></span>
<p>levelDB中有很多常用的组件，下面我们来对其进行介绍。</p>
<ul>
<li>Comparator : 定义了比较的规则，是一个虚基类。</li>
<li>Status : 定义函数执行的结果信息。</li>
<li>Env : 封装系统相关的调用，比如文件操作，线程操作。</li>
<li>Options : 指定数据库选项。</li>
</ul>
<h3 id="comparator">Comparator</h3>
<div class="note primary">
            <p>源码位置与说明：</p><p><code>utils/comparator.h</code> <code>utils/comparator.cc</code> :虚基类与BytewiseComparatorImpl类头文件与实现</p><p><code>db/dbformat.h</code> <code>db/format.cc</code> :InternalKeyComparator类头文件与实现</p>
          </div>
<p>Comparator定义了比较规则，这个是一个虚基类，所以如果想要实现自定义的接口需要实现自己的类。</p>
<p>其中levelDB基于Comparator实现了一些内置比较类：<code>BytewiseComparatorImpl</code>和<code>InternalKeyComparator</code>，两者的作用是不同的。</p>
<ul>
<li>BytewiseComparatorImpl : 实现key的按二进制来进行比较。</li>
<li>InternalKeyComparator :
用于内部的key比较器，基于BytewiseComparatorImpl。</li>
</ul>
<div class="note primary">
            <p>由于levelDB是key-value的结构，其中key就是Slice对象。所以BytewiseComparatorImpl用于key之间的比较，这个key称为usr-key。</p><p>但是levelDB内部的存储的key结构并不是usr-key，所以需要默认定义两种比较类。</p>
          </div>
<h4 id="comparator源码剖析">Comparator源码剖析</h4>
<p>首先我们来看一下虚基类的定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> Comparator</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Comparator</span>();</span><br><span class="line">    <span class="comment">// 进行比较的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Compare</span><span class="params">(<span class="type">const</span> Slice &amp;a, <span class="type">const</span> Slice &amp;b)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回comparator的名字，用于确认</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将start更改为一个位于[start, limit)里的最短的字符串。</span></span><br><span class="line">    <span class="comment">// 也就是找到start和limit中的公共字符字串，并把这个字串最后一个字符ascii+1</span></span><br><span class="line">    <span class="comment">// 这主要是为了优化SSTable里的Index Block里的索引项的长度，使得索引更短。</span></span><br><span class="line">    <span class="comment">// 因为每一个Data Block对应的索引项大于等于这个Data Block的最后一个项，</span></span><br><span class="line">    <span class="comment">// 而小于下一个Data Block的第一个项，通过这个函数可以减小索引项的长度；</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">FindShortestSeparator</span><span class="params">(std::string *start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> Slice &amp;limit)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将key更改为大于key的最短的key</span></span><br><span class="line">    <span class="comment">// 也就是取出key的第一个字节，然后+1</span></span><br><span class="line">    <span class="comment">// 这也是为了减小索引项的长度</span></span><br><span class="line">    <span class="comment">// 不过这是优化一个SSTable里最后一个索引项的。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">FindShortSuccessor</span><span class="params">(std::string *key)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中FindShortestSeparator和FindShortSuccessor可能会令人感到疑惑，这两个方法的作用是缩短索引。因为levelDB内部是有序的，假如有这样的两个索引"Aaaaa"和"Acccc"，其实我们只需要"Ab"就能将两者分开了；另外，假如一个表中的最后一项是"Yaaaa"，我们只需要"Z"就能确定这个项的上界了。这就是这两个函数能减短索引的原理。</p>
<p>接下来我们来看一下BytewiseComparatorImpl类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BytewiseComparatorImpl</span> : <span class="keyword">public</span> Comparator</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BytewiseComparatorImpl</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">Name</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>{ <span class="keyword">return</span> <span class="string">"leveldb.BytewiseComparator"</span>; }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Compare</span><span class="params">(<span class="type">const</span> Slice &amp;a, <span class="type">const</span> Slice &amp;b)</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">compare</span>(b);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindShortestSeparator</span><span class="params">(std::string *start,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Slice &amp;limit)</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 先找到两者之间的最长子串</span></span><br><span class="line">        <span class="type">size_t</span> min_length = std::<span class="built_in">min</span>(start-&gt;<span class="built_in">size</span>(), limit.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">size_t</span> diff_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((diff_index &lt; min_length) &amp;&amp;</span><br><span class="line">               ((*start)[diff_index] == limit[diff_index]))</span><br><span class="line">        {</span><br><span class="line">            diff_index++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff_index &gt;= min_length)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 如果一个串是另一个串的前缀就什么也不做</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 否则把start的最后一个字节+1(如果没超过255的话)</span></span><br><span class="line">            <span class="type">uint8_t</span> diff_byte = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;((*start)[diff_index]);</span><br><span class="line">            <span class="keyword">if</span> (diff_byte &lt; <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(<span class="number">0xff</span>) &amp;&amp;</span><br><span class="line">                diff_byte + <span class="number">1</span> &lt; <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(limit[diff_index]))</span><br><span class="line">            {</span><br><span class="line">                (*start)[diff_index]++;</span><br><span class="line">                start-&gt;<span class="built_in">resize</span>(diff_index + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">assert</span>(<span class="built_in">Compare</span>(*start, limit) &lt; <span class="number">0</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindShortSuccessor</span><span class="params">(std::string *key)</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 找到第一个能够+1的字节</span></span><br><span class="line">        <span class="type">size_t</span> n = key-&gt;<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">const</span> <span class="type">uint8_t</span> byte = (*key)[i];</span><br><span class="line">            <span class="keyword">if</span> (byte != <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(<span class="number">0xff</span>))</span><br><span class="line">            {</span><br><span class="line">                (*key)[i] = byte + <span class="number">1</span>;</span><br><span class="line">                key-&gt;<span class="built_in">resize</span>(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果全是0xff，就不管了</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数返回一个BytewiseComparatorImpl实例</span></span><br><span class="line"><span class="comment">// 之所以存在这个函数是为了保证线程安全</span></span><br><span class="line"><span class="comment">// 可以看https://www.zhihu.com/question/267013757</span></span><br><span class="line"><span class="function"><span class="type">const</span> Comparator *<span class="title">BytewiseComparator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">    <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这部分比较的规则其实就是我们前面看到的虚基类的具体化。需要注意它存在一个为了保证线程安全的方法，进一步了解可以看<a href="https://www.zhihu.com/question/267013757">此处</a>。</p>
<p>接下来我们来看一下InternalKeyComparator的头文件和实现文件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InternalKeyComparator</span> : <span class="keyword">public</span> Comparator</span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 多了一个私有成员，存放usr-key的比较函数</span></span><br><span class="line">    <span class="type">const</span> Comparator *user_comparator_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 前面这些接口都非常简单</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">InternalKeyComparator</span><span class="params">(<span class="type">const</span> Comparator *c)</span> : user_comparator_(c) {</span>}</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">Name</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Compare</span><span class="params">(<span class="type">const</span> Slice &amp;a, <span class="type">const</span> Slice &amp;b)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindShortestSeparator</span><span class="params">(std::string *start,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Slice &amp;limit)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindShortSuccessor</span><span class="params">(std::string *key)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回usr-key的比较器，应该是用于判断</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Comparator *<span class="title">user_comparator</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> user_comparator_; }</span><br><span class="line">    <span class="comment">// 这个也是比较的，InternalKey就是内部的key类型</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Compare</span><span class="params">(<span class="type">const</span> InternalKey &amp;a, <span class="type">const</span> InternalKey &amp;b)</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 实现文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">InternalKeyComparator::Name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"leveldb.InternalKeyComparator"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较key的类，调用的是usr-key的比较</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InternalKeyComparator::Compare</span><span class="params">(<span class="type">const</span> Slice &amp;akey, <span class="type">const</span> Slice &amp;bkey)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> r = user_comparator_-&gt;<span class="built_in">Compare</span>(<span class="built_in">ExtractUserKey</span>(akey), <span class="built_in">ExtractUserKey</span>(bkey));</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">const</span> <span class="type">uint64_t</span> anum = <span class="built_in">DecodeFixed64</span>(akey.<span class="built_in">data</span>() + akey.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">        <span class="type">const</span> <span class="type">uint64_t</span> bnum = <span class="built_in">DecodeFixed64</span>(bkey.<span class="built_in">data</span>() + bkey.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (anum &gt; bnum)</span><br><span class="line">        {</span><br><span class="line">            r = <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum)</span><br><span class="line">        {</span><br><span class="line">            r = +<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到最短的分割函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InternalKeyComparator::FindShortestSeparator</span><span class="params">(std::string *start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">const</span> Slice &amp;limit)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Slice user_start = <span class="built_in">ExtractUserKey</span>(*start);</span><br><span class="line">    Slice user_limit = <span class="built_in">ExtractUserKey</span>(limit);</span><br><span class="line">    <span class="function">std::string <span class="title">tmp</span><span class="params">(user_start.data(), user_start.size())</span></span>;</span><br><span class="line">    user_comparator_-&gt;<span class="built_in">FindShortestSeparator</span>(&amp;tmp, user_limit);</span><br><span class="line">    <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() &lt; user_start.<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">        user_comparator_-&gt;<span class="built_in">Compare</span>(user_start, tmp) &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">PutFixed64</span>(&amp;tmp,</span><br><span class="line">                   <span class="built_in">PackSequenceAndType</span>(kMaxSequenceNumber, kValueTypeForSeek));</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;<span class="built_in">Compare</span>(*start, tmp) &lt; <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;<span class="built_in">Compare</span>(tmp, limit) &lt; <span class="number">0</span>);</span><br><span class="line">        start-&gt;<span class="built_in">swap</span>(tmp);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InternalKeyComparator::FindShortSuccessor</span><span class="params">(std::string *key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Slice user_key = <span class="built_in">ExtractUserKey</span>(*key);</span><br><span class="line">    <span class="function">std::string <span class="title">tmp</span><span class="params">(user_key.data(), user_key.size())</span></span>;</span><br><span class="line">    user_comparator_-&gt;<span class="built_in">FindShortSuccessor</span>(&amp;tmp);</span><br><span class="line">    <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() &lt; user_key.<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">        user_comparator_-&gt;<span class="built_in">Compare</span>(user_key, tmp) &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">PutFixed64</span>(&amp;tmp,</span><br><span class="line">                   <span class="built_in">PackSequenceAndType</span>(kMaxSequenceNumber, kValueTypeForSeek));</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;<span class="built_in">Compare</span>(*key, tmp) &lt; <span class="number">0</span>);</span><br><span class="line">        key-&gt;<span class="built_in">swap</span>(tmp);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较内部key的函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">InternalKeyComparator::Compare</span><span class="params">(<span class="type">const</span> InternalKey &amp;a,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> InternalKey &amp;b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Compare</span>(a.<span class="built_in">Encode</span>(), b.<span class="built_in">Encode</span>());</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到InternalKeyComparator的比较其实也是基于usr-key的，不过由于内部key与usr-key存在差异，剩余的代码主要是处理差异的，具体我们先不展开。</p>
<h3 id="status">Status</h3>
<div class="note primary">
            <p>源码位置： <code>leveldb/include/status.h</code><code>util/status.cc</code></p>
          </div>
<p>这个类主要定义了很多操作的返回码，很多操作需要通过返回的status来判断下一步的行为。</p>
<h4 id="status源码剖析">Status源码剖析</h4>
<p>我们接下来来看一下它的头文件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> Status</span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//返回码</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Code</span></span><br><span class="line">    {</span><br><span class="line">        kOk = <span class="number">0</span>,</span><br><span class="line">        kNotFound = <span class="number">1</span>,</span><br><span class="line">        kCorruption = <span class="number">2</span>,</span><br><span class="line">        kNotSupported = <span class="number">3</span>,</span><br><span class="line">        kInvalidArgument = <span class="number">4</span>,</span><br><span class="line">        kIOError = <span class="number">5</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="function">Code <span class="title">code</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> (state_ == <span class="literal">nullptr</span>) ? kOk : <span class="built_in">static_cast</span>&lt;Code&gt;(state_[<span class="number">4</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Status</span>(Code code, <span class="type">const</span> Slice &amp;msg, <span class="type">const</span> Slice &amp;msg2);</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">CopyState</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功的时候state_为空指针，否则指向一个由new[]分配的数组</span></span><br><span class="line">    <span class="comment">// 其中[0:3]为信息的长度</span></span><br><span class="line">    <span class="comment">// [4]为错误码</span></span><br><span class="line">    <span class="comment">// [5:]为信息</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *state_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造与析构函数等等一个类的必须的函数</span></span><br><span class="line">    <span class="built_in">Status</span>() <span class="keyword">noexcept</span> : <span class="built_in">state_</span>(<span class="literal">nullptr</span>) {}</span><br><span class="line">    ~<span class="built_in">Status</span>() { <span class="keyword">delete</span>[] state_; }</span><br><span class="line">    <span class="built_in">Status</span>(<span class="type">const</span> Status &amp;rhs);</span><br><span class="line">    Status &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Status &amp;rhs);</span><br><span class="line">    <span class="built_in">Status</span>(Status &amp;&amp;rhs) <span class="keyword">noexcept</span> : <span class="built_in">state_</span>(rhs.state_) { rhs.state_ = <span class="literal">nullptr</span>; }</span><br><span class="line">    Status &amp;<span class="keyword">operator</span>=(Status &amp;&amp;rhs) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回成功或错误类型</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Status <span class="title">OK</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">Status</span>(); }</span><br><span class="line">    <span class="function"><span class="type">static</span> Status <span class="title">NotFound</span><span class="params">(<span class="type">const</span> Slice &amp;msg, <span class="type">const</span> Slice &amp;msg2 = Slice())</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Status</span>(kNotFound, msg, msg2);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">static</span> Status <span class="title">Corruption</span><span class="params">(<span class="type">const</span> Slice &amp;msg, <span class="type">const</span> Slice &amp;msg2 = Slice())</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Status</span>(kCorruption, msg, msg2);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">static</span> Status <span class="title">NotSupported</span><span class="params">(<span class="type">const</span> Slice &amp;msg, <span class="type">const</span> Slice &amp;msg2 = Slice())</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Status</span>(kNotSupported, msg, msg2);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">static</span> Status <span class="title">InvalidArgument</span><span class="params">(<span class="type">const</span> Slice &amp;msg, <span class="type">const</span> Slice &amp;msg2 = Slice())</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Status</span>(kInvalidArgument, msg, msg2);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">static</span> Status <span class="title">IOError</span><span class="params">(<span class="type">const</span> Slice &amp;msg, <span class="type">const</span> Slice &amp;msg2 = Slice())</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Status</span>(kIOError, msg, msg2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state_为空就是成功</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> (state_ == <span class="literal">nullptr</span>); }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则根据code()返回值来判断错误类型</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsNotFound</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">code</span>() == kNotFound; }</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsCorruption</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">code</span>() == kCorruption; }</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsIOError</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">code</span>() == kIOError; }</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsNotSupportedError</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">code</span>() == kNotSupported; }</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsInvalidArgument</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">code</span>() == kInvalidArgument; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据错误类型返回一个字符串用于打印</span></span><br><span class="line">    <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于这个类主要就是处理错误类型的，所以其实现也是非常简单的，此处就不展开了。</p>
<p>不过实现内部有一个小技巧：<strong>用memcpy去进行赋值</strong>。这个似乎会更快一些，不过我觉得这个还是用于大数组会比较好吧，毕竟针对内存块有SIMD之类的优化。</p>
<h3 id="env">Env</h3>
<div class="note primary">
            <p>源码位置：</p><p><code>include/leveldb/env.h</code> : env相关的接口定义</p><p><code>util/env_posix.cc</code> <code>util/posix_logger.h</code> :Posix系统相关的封装，包括文件操作，文件锁，后台线程创建,Posix写日志</p><p><code>util/env_windows.cc</code> <code>util/windows_logger.h</code> :Windows相关的实现</p>
          </div>
<p>LevelDB是一个数据库函数库，数据库总是需要操作文件和线程，这就需要做很多系统调用。各个操作系统的系统调用方式不一样，为了跨平台支持，LevelDB对这些系统调用做了一层封装，提供了统一的接口来操作，并且提供了Posix和Windows两种实现，如果需要实现其他的系统，只需要根据系统实现相应的Env即可。</p>
<p>不过由于这些代码实在是太多，而且也就是一些系统调用，所以此处不展开了。</p>
<p>里面感觉有用的就是关于多线程的一个锁的问题，但是也相对比较简单。</p>
<h3 id="options">Options</h3>
<div class="note primary">
            <p>源码位置：<code>leveldb/include/options.h</code><code>util/options.cc</code></p>
          </div>
<p>Options定义了操作数据库的选项，定义了3个struct来操作：</p>
<ul>
<li>Options定义打开数据库的选项</li>
<li>ReadOptions定义读操作相关的选项</li>
<li>WriteOptions定义写操作相关的选项</li>
</ul>
<p>同样的，这部分源码也非常简单，也不展开了</p>
<h2 id="总结">总结</h2>
<h3 id="编程小技巧">编程小技巧</h3>
<ul>
<li>可以定义虚基类来规定接口。</li>
<li>需要处理线程安全问题。</li>
<li>memcpy进行数组赋值会更快。</li>
</ul>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(9)--WAL日志</title>
    <url>/2022/09/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-9/</url>
    <content><![CDATA[<h2 id="wal日志的格式与构建">WAL日志的格式与构建</h2>
<span id="more"></span>
<div class="note primary">
            <p>源码位置与说明</p><p>db/log_format.h : 定义了RecordType和一些常量<br>db/log_writer.h db/log_writer.cc :主要实现Writer::AddRecord，写一条记录到日志中<br>db/log_reader.h db/log_reader.cc :主要实现Reader::ReadRecord，读取一条日志记录</p>
          </div>
<p>LevelDB写入一个kv时，都会先向日志里写入一条记录，这种日志一般称为WAL，也就是Write
Ahead
Log。这种日志最大的作用就是将对磁盘的随机写转换成了顺序写。当故障宕机时，可以通过WAL进行故障恢复。控制每次WAL写入磁盘的方式，可以控制最多可能丢失的数据量。</p>
<p>WAL里的内容实际就是内存里MemTable内容的持久化，当一个MemTable写满后，开启一个新的MemTable时，也同时会开启一个新的WAL，当MemTable被Dump到磁盘后，相应的WAL可以被删除。</p>
<p>WAL的格式很简单，由一系列32KB的Block组成，当然最后一个块可能是不满的，正在写入中。</p>
<img src="/2022/09/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-9/pic1.jpg" class="">
<p>而每个Block包含连续的Record，其中每个Record的格式为crc+长度+类型+value。一条记录可能全部写到一个块上，也可能跨几个块。且其中每个Record可以是不同的类型的，有以下几种类型。</p>
<ul>
<li>kZeroType：为预分配的文件保留。</li>
<li>kFullType：表示一条记录完整地写到了一个块上。</li>
<li>kFirstType：表示该条记录的第一部分。</li>
<li>kMiddleType：表示该条记录的中间部分。</li>
<li>kLastType：表示该条记录的最后一部分。</li>
</ul>
<p>可能感觉为什么需要设置这么多Record类型，原因很简单。因为WAL是由Block组成的，<strong>注意这个Block不是前面SSTable中的Block类，这里的Block指的是一种逻辑上的结构</strong>，为了便于读取，WAL中的Block大小都是固定的，为<code>kBlockSize = 32768</code>。而每条Record的大小不是固定的，因此可能会出现当前Block中放不下插入的Record，所以需要将Record进行分块插入到不同的Block中，这个类型就是为了标识出这条Record是不是被拆分之后的结果，如果是的话，那么这条Record位于未被拆分的Record中的哪部分。</p>
<img src="/2022/09/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-9/pic2.png" class="">
<div class="note info">
            <p>这部分可以在<code>doc/log_format.md</code>中找到</p>
          </div>
<h4 id="源码部分">源码部分</h4>
<p>我们先来看一下头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Writer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 执行的操作就是构造Header，</span></span><br><span class="line">    <span class="comment">// 调用WritableFile的append和flush，将record刷到物理磁盘上</span></span><br><span class="line">    <span class="function">Status <span class="title">EmitPhysicalRecord</span><span class="params">(RecordType type, <span class="type">const</span> <span class="type">char</span> *ptr, <span class="type">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">    WritableFile *dest_;                    <span class="comment">// 可写入的WAL文件</span></span><br><span class="line">    <span class="type">int</span> block_offset_;                      <span class="comment">// 当前的偏移值</span></span><br><span class="line">    <span class="type">uint32_t</span> type_crc_[kMaxRecordType + <span class="number">1</span>]; <span class="comment">// CRC校验</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，此时要求dest是空的或存在dest_length长度的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(WritableFile *dest)</span></span>;</span><br><span class="line">    <span class="built_in">Writer</span>(WritableFile *dest, <span class="type">uint64_t</span> dest_length);</span><br><span class="line">    <span class="built_in">Writer</span>(<span class="type">const</span> Writer &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Writer &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Writer &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Writer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一条记录</span></span><br><span class="line">    <span class="function">Status <span class="title">AddRecord</span><span class="params">(<span class="type">const</span> Slice &amp;slice)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实这个Writer接口还是非常简单的，只有一个AddRecord函数可以用来添加日志。我们来看一下它的具体实现是什么样的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 初始化CRC，每个构造函数都调用这个函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">InitTypeCrc</span><span class="params">(<span class="type">uint32_t</span> *type_crc)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= kMaxRecordType; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">char</span> t = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(i);</span><br><span class="line">        type_crc[i] = crc32c::<span class="built_in">Value</span>(&amp;t, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Writer::<span class="built_in">Writer</span>(WritableFile *dest) : <span class="built_in">dest_</span>(dest), <span class="built_in">block_offset_</span>(<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">InitTypeCrc</span>(type_crc_);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数2</span></span><br><span class="line">Writer::<span class="built_in">Writer</span>(WritableFile *dest, <span class="type">uint64_t</span> dest_length)</span><br><span class="line">    : <span class="built_in">dest_</span>(dest), <span class="built_in">block_offset_</span>(dest_length % kBlockSize)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">InitTypeCrc</span>(type_crc_);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Writer::~<span class="built_in">Writer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口，添加一个Record</span></span><br><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="type">const</span> Slice &amp;slice)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ptr = slice.<span class="built_in">data</span>(); <span class="comment">// 获取record的数据和长度</span></span><br><span class="line">    <span class="type">size_t</span> left = slice.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    Status s;</span><br><span class="line">    <span class="comment">// begin表明本条记录是第一次写入，即当前块中第一条记录</span></span><br><span class="line">    <span class="type">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 当前块剩余空间，用于判断头部能否完整写入</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> leftover = kBlockSize - block_offset_;</span><br><span class="line">        <span class="built_in">assert</span>(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (leftover &lt; kHeaderSize)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 如果块剩余空间小于七个字节且不等于0，说明当前无法完整写入数据</span></span><br><span class="line">            <span class="comment">// 此时填充\x00，从下一个块写入</span></span><br><span class="line">            <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">static_assert</span>(kHeaderSize == <span class="number">7</span>, <span class="string">""</span>);</span><br><span class="line">                dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(<span class="string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 此时块正好写满，将block_offset_置为0，表明开始写入新的块</span></span><br><span class="line">            block_offset_ = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line">        <span class="built_in">assert</span>(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算块剩余空间</span></span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">        <span class="comment">// 计算当前块能够写入的数据大小（块剩余空间和记录剩余内容中最小的）</span></span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line"></span><br><span class="line">        RecordType type;</span><br><span class="line">        <span class="comment">// end表明该记录是否已经完整写入，即最后一条记录</span></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> end = (left == fragment_length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面判断是哪一种类型</span></span><br><span class="line">        <span class="keyword">if</span> (begin &amp;&amp; end)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 记录为第一条且同时又是最后一条，说明当前是完整的记录，状态为kFullType</span></span><br><span class="line">            type = kFullType;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (begin)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 只有头部</span></span><br><span class="line">            type = kFirstType;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (end)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 只有结尾</span></span><br><span class="line">            type = kLastType;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 既不是头也不是结尾</span></span><br><span class="line">            type = kMiddleType;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把已经写入的Record部分发射到物理磁盘中</span></span><br><span class="line">        s = <span class="built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length);</span><br><span class="line">        ptr += fragment_length;</span><br><span class="line">        left -= fragment_length;</span><br><span class="line">        begin = <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">while</span> (s.<span class="built_in">ok</span>() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一条Record发射保存到物理磁盘中</span></span><br><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="type">const</span> <span class="type">char</span> *ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">assert</span>(length &lt;= <span class="number">0xffff</span>); <span class="comment">// Must fit in two bytes</span></span><br><span class="line">    <span class="built_in">assert</span>(block_offset_ + kHeaderSize + length &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存header并计算出crc</span></span><br><span class="line">    <span class="type">char</span> buf[kHeaderSize];</span><br><span class="line">    buf[<span class="number">4</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(length &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[<span class="number">5</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    buf[<span class="number">6</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算crc</span></span><br><span class="line">    <span class="type">uint32_t</span> crc = crc32c::<span class="built_in">Extend</span>(type_crc_[t], ptr, length);</span><br><span class="line">    crc = crc32c::<span class="built_in">Mask</span>(crc);</span><br><span class="line">    <span class="built_in">EncodeFixed32</span>(buf, crc); <span class="comment">// 编码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用文件的相关方法来把header写入磁盘，然后把剩余部分也写入文件</span></span><br><span class="line">    Status s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(buf, kHeaderSize));</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(ptr, length));</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            s = dest_-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    block_offset_ += kHeaderSize + length; <span class="comment">// 更新block的偏移位置</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实写入逻辑也是很简单的，就是看一下当前的Block够不够，如果够的话就直接把Record写入并将类型设置为kFullType。如果当前块剩余空间小于7字节(小于header需要的字节数目)就新开一个块，并重复执行上述操作。如果当前块能够写下一部分，就把Record的一部分写入到这个块中，并设置类型为kFirstType，剩余的部分继续执行上述操作，可能会被设置为kMiddleType、kLastType这些类型，直到一条Record写完。</p>
<h2 id="总结">总结</h2>
<p>WAL日志部分的写入还是很简单的，这个类的设计的接口其实只有一个，使用起来非常方便。</p>
<p>另外AddRecord这个函数中的循环写入部分也是非常有意思的。</p>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中更新python版本</title>
    <url>/2022/09/21/linux%E4%B8%AD%E6%9B%B4%E6%96%B0python%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="在linux中更新python3的版本">在linux中更新python3的版本。</h2>
<span id="more"></span>
<p>之前搞到一块rk3288的开发板，装好ubuntu
server后下一步打算配置一下环境，于是就有了这篇踩坑记录。</p>
<p>我这块板子上装的系统是ubuntu server
14.04，版本比较老。里面的python3的版本是3.4，所以我想将其升级到3.8.1，不然nonebot2没法跑。</p>
<h3 id="下载工具与python源码">下载工具与python源码</h3>
<p>首先我们先安装好<code>gcc</code>, <code>make</code>, <code>git</code>
这些基础工具以做好准备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt install gcc make git</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们把python3.8.1的源码下载下来并解压，因为我们需要从源码来编译python3。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wget https://www.python.org/ftp/python/3.8.1/Python-3.8.1.tgz</span><br><span class="line">tar -zxvf Python-3.8.1.tgz</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="编译前准备">编译前准备</h3>
<p>但是此时我们是不能直接去python的源码下构建然后编译的，原因有以下几点</p>
<ul>
<li>openssl
1.0.1是不安全的，所以python3需要1.0.2及以上版本，但是我们系统中的openssl版本为1.0.1。</li>
<li>还有一些前置的包没有安装。</li>
</ul>
<p>由于第二个好解决我们先来解决第二个。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt install libffi-devel -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也许还需要其他的包，但是我不记得了，所以如果有其他错误再安装吧</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面我们来解决第一个问题，openssl也需要从源码构建。</p>
<h4 id="编译安装openssl">编译安装openssl</h4>
<p>这里参考的一篇<a href="https://stackoverflow.com/questions/53543477/building-python-3-7-1-ssl-module-failed">博客</a></p>
<p>首先，我们也需要安装一些前置的包并下载下来源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get install build-essential checkinstall libreadline-gplv2-dev libncursesw5-dev libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev</span><br><span class="line"></span><br><span class="line">wget https://www.openssl.org/source/openssl-1.0.2o.tar.gz</span><br><span class="line">tar -zxvf openssl-1.0.2o.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后开始构建编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">./config shared --prefix=/usr/local/</span><br><span class="line"></span><br><span class="line">make -j4</span><br><span class="line"></span><br><span class="line">sudo make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，openssl应该安装完成了。我们输入<code>openssl version</code>可以查看版本。</p>
<h3 id="编译python3">编译python3</h3>
<p>然后我们就可以正式来构建编译python3了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> Python3.8.1</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/python3 \--with-ssl \--enable-optimizations</span><br><span class="line"></span><br><span class="line">make -j4</span><br><span class="line"></span><br><span class="line">sudo make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="替换软链接">替换软链接</h3>
<p>编译安装完成python3后我们需要更改软链接，不然还是没法用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line">sudo <span class="built_in">mv</span> python3 python3.bak</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/python3/bin/python3 /usr/bin/python3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们输入<code>python3 --version</code>来查看python3版本是不是正确。</p>
<p>到这里我们虽然完成了pyhton3的安装，但是，pip3是不能使用的。</p>
<p>所以下一步我们是更改pip3的软链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo <span class="built_in">rm</span> -rf /usr/local/bin/pip3</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/Python3/bin/pip3 /usr/local/bin/pip3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们来试试安装一个包，如果能安装，则说明没有问题了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip3 install requests</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具杂谈</category>
      </categories>
      <tags>
        <tag>开发板使用</tag>
        <tag>RK3288</tag>
      </tags>
  </entry>
  <entry>
    <title>python中使用yield将一个递归保持形式不变下转换成非递归</title>
    <url>/2022/11/28/python%E4%B8%AD%E4%BD%BF%E7%94%A8yield%E5%B0%86%E4%B8%80%E4%B8%AA%E9%80%92%E5%BD%92%E4%BF%9D%E6%8C%81%E5%BD%A2%E5%BC%8F%E4%B8%8D%E5%8F%98%E4%B8%8B%E8%BD%AC%E6%8D%A2%E6%88%90%E9%9D%9E%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="使用yield将一个递归保持形式不变下转换成非递归">使用yield将一个递归保持形式不变下转换成非递归</h2>
<span id="more"></span>
<p>递归函数的可读性高，但是效率不高；非递归函数的效率高，但是可读性会略逊一筹。不过在python中借助yield这个工具我们可以做到鱼和熊掌得兼。</p>
<h3 id="yield的一些技巧">yield的一些技巧</h3>
<p>函数内有yield的函数将被作为生成器，当函数执行到yield这里时会将生成器挂起，直到下一次调用。</p>
<p>yield当然还有其他的很多用处和技巧，可以说是python中最重要的概念之一。我们此处用到的技巧主要还是<code>send()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    x = <span class="keyword">yield</span> </span><br><span class="line">    <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line">b = a()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(b)) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(b)) <span class="comment"># 空</span></span><br><span class="line"><span class="built_in">print</span>(b.send(<span class="number">2</span>)) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    x = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line">d = c()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(d)) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(d)) <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(d.send(<span class="number">3</span>)) <span class="comment"># 空</span></span><br><span class="line"><span class="built_in">print</span>(d.send(<span class="number">4</span>)) <span class="comment"># 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>send()</code>函数可以向生成器中发送数据，但是在调用send前需要保证生成器处于yield的位置上(<strong>即保证在send前调用next，当然send本身也是会有一次next调用的，因此send也会返回值</strong>)</p>
<p>关于send的细节此处就不展开了。</p>
<p>在上面代码中的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">x = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>等效于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">x = <span class="keyword">yield</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中<code>x = yield</code>为send的接受点，即send进生成器中的数据会被发送给x。</p>
<h3 id="一个递归函数">一个递归函数</h3>
<p>此处我们就以一个树的访问者模式遍历为例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data, left = <span class="literal">None</span>, right = <span class="literal">None</span></span>):</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">        self.data = data</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visit</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="comment"># 前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.visit(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.visit(node.right)</span><br><span class="line">        <span class="built_in">print</span>(node.data)</span><br><span class="line"></span><br><span class="line">t5 = Node(<span class="number">5</span>)</span><br><span class="line">t4 = Node(<span class="number">4</span>)</span><br><span class="line">t3 = Node(<span class="number">3</span>, t4, t5)</span><br><span class="line">t2 = Node(<span class="number">2</span>, t3)</span><br><span class="line">t1 = Node(<span class="number">1</span>)</span><br><span class="line">t0 = Node(<span class="number">0</span>, t1, t2) <span class="comment"># 前序遍历结果为 1 4 5 3 2 0</span></span><br><span class="line"></span><br><span class="line">v = Visitor</span><br><span class="line">v.visit(t0) <span class="comment"># 1 4 5 3 2 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时的前序遍历是一个递归的操作，但是递归效率不高且会爆栈。递归爆栈的原因也很简单，即它会不断保留当前的状态，直到进入到递归的最内层，并逐层向外解开求值。</p>
<img src="/2022/11/28/python%E4%B8%AD%E4%BD%BF%E7%94%A8yield%E5%B0%86%E4%B8%80%E4%B8%AA%E9%80%92%E5%BD%92%E4%BF%9D%E6%8C%81%E5%BD%A2%E5%BC%8F%E4%B8%8D%E5%8F%98%E4%B8%8B%E8%BD%AC%E6%8D%A2%E6%88%90%E9%9D%9E%E9%80%92%E5%BD%92/pic1.png" class="">
<p>每次压入栈中时会把函数涉及到的变量一起压入，这就导致了内存占用过高而爆栈。假如存在一个栈，把结果(数据、起始结点甚至是生成器)全部压进去，然后每次从中pop一个出来根据类型处理，这样就能解决爆栈问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> GeneratorType</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visit</span>(<span class="params">self, node</span>):</span><br><span class="line">        stack = [node]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                last = stack[-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 根据类型来进行处理</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(last, GeneratorType):</span><br><span class="line">                    <span class="comment"># 生成器的话就生成一个值出来</span></span><br><span class="line">                    stack.append(<span class="built_in">next</span>(last))</span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">isinstance</span>(last, Node):</span><br><span class="line">                    <span class="comment"># 结点的话就转换成生成器压入栈</span></span><br><span class="line">                    stack.append(self._visit(stack.pop()))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 其他（数据类型）就打印出来</span></span><br><span class="line">                    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">                <span class="comment"># 这个异常需要注意一下哦</span></span><br><span class="line">                <span class="comment"># 此处目的是捕获生成器异常，从而把没用的生成器扔掉</span></span><br><span class="line">                stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_visit</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 注意此处，还保留了递归的形式（调用自身）</span></span><br><span class="line">            <span class="keyword">yield</span> self._visit(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> self._visit(node.right)</span><br><span class="line">        <span class="keyword">yield</span> node.data</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，关键的部分还是保持了递归的形式（即自身函数调用自身），但是由于生成器函数并不会直接执行函数内部代码，所以给了可以操作的空间。</p>
<img src="/2022/11/28/python%E4%B8%AD%E4%BD%BF%E7%94%A8yield%E5%B0%86%E4%B8%80%E4%B8%AA%E9%80%92%E5%BD%92%E4%BF%9D%E6%8C%81%E5%BD%A2%E5%BC%8F%E4%B8%8D%E5%8F%98%E4%B8%8B%E8%BD%AC%E6%8D%A2%E6%88%90%E9%9D%9E%E9%80%92%E5%BD%92/pic2.png" class="">
<p>可以看成是一个状态机。</p>
<h3 id="一个更高级的例子">一个更高级的例子</h3>
<p>当然，上面的例子比较简单，简单的原因是：<strong>每个生成器之间不涉及到数据交换，是独立的</strong>。我们接下来看一下需要交换数据的例子，此处我们改写一下斐波那契。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> GeneratorType</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">self, x=<span class="number">1</span></span>):</span><br><span class="line">        <span class="keyword">return</span> Number(self.n-x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>:</span><br><span class="line">    <span class="comment"># 这个函数是yield改写递归的接口</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, number</span>):</span><br><span class="line">        stack = [number]</span><br><span class="line">        last_result = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                last = stack[-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(last, GeneratorType):</span><br><span class="line">                    <span class="comment"># 是生成器的话就send，要把last_result设置为none</span></span><br><span class="line">                    <span class="comment"># 如果生成出来的还是生成器的话，表示递归继续，</span></span><br><span class="line">                    <span class="comment"># 此时就send(None)让新生成的迭代器进入send位置</span></span><br><span class="line">                    <span class="comment"># 如果生成出来的是值，那么下次循环会把这个值设置成last_result</span></span><br><span class="line">                    <span class="comment"># last_result负责保存上一次值的结果，从而实现传递数据</span></span><br><span class="line">                    t = last.send(last_result)</span><br><span class="line">                    stack.append(t)</span><br><span class="line">                    last_result = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">isinstance</span>(last, Number):</span><br><span class="line">                    <span class="comment"># 是Number类的话就把生成器加入</span></span><br><span class="line">                    stack.append(self._fib(stack.pop()))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果是值的话，就保存进last_result</span></span><br><span class="line">                    <span class="comment"># 后续会被送入生成器的send中</span></span><br><span class="line">                    last_result = stack.pop()</span><br><span class="line">            <span class="keyword">except</span> StopAsyncIteration <span class="keyword">as</span> e:</span><br><span class="line">                <span class="comment"># 目的还是丢弃终止迭代器</span></span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> last_result</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这个是使用yield改写的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_fib</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">if</span> n.n == <span class="number">1</span> <span class="keyword">or</span> n.n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 保持了递归形式上的不变（还是在调用自身，但是实际上已经不是递归了）</span></span><br><span class="line">            <span class="keyword">yield</span> (<span class="keyword">yield</span> self._fib(n.dec())) + (<span class="keyword">yield</span> self._fib(n.dec(<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这个是原始的递归</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib_raw</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.fib_raw(n-<span class="number">1</span>) + self.fib_raw(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = Fib()</span><br><span class="line"><span class="built_in">print</span>(f.fib(Number(<span class="number">6</span>)))</span><br><span class="line"><span class="built_in">print</span>(f.fib_raw(<span class="number">6</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每次遇到生成器后都要把last_result设置为None，需要注意<code>last_result</code>的作用有两个：</p>
<ul>
<li>如果生成出来的还是生成器的话，表示递归继续，此时就send(None)让新生成的迭代器进入send位置</li>
<li>如果生成出来的是值，那么下次循环会把这个值设置成last_result，这个值会被send进最近的一个生成器中，<strong>这就完成了递归产生数据的注入</strong></li>
</ul>
<p><strong>不过这种方式似乎需要保证中间过程值与结果输出值类型不一致呢。</strong></p>
<p>其中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">yield</span> (<span class="keyword">yield</span> n.dec()) + (<span class="keyword">yield</span> n.dec(<span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>等效于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">x = <span class="keyword">yield</span> n.dec()</span><br><span class="line">y = <span class="keyword">yield</span> n.dec(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">yield</span> x + y</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意，这种方式本质上只改善了递归的爆栈问题，它的实际运行过程跟递归是一样的。（即，不能当作递归--&gt;非递归的优化方法）</strong></p>
<p>其实就是把递归的整个过程用yield和一个栈来全部模拟一遍啦，且在模拟的时候不改变递归函数形式(即仍然是自身调用自身，但是用生成器惰性求值+挂起的特性来防止不断申请栈空间)</p>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python协程</tag>
      </tags>
  </entry>
  <entry>
    <title>python中装饰器与类</title>
    <url>/2023/02/17/python%E4%B8%AD%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>如何在类中使用装饰器(类方法装饰器、类装饰器)</strong></p>
<span id="more"></span>
<h2 id="基本装饰器写法">基本装饰器写法</h2>
<p>python中装饰器语法非常常见，一般有以下几种：</p>
<ul>
<li>函数装饰器（带参数的、不带参数的、装饰类的、装饰类方法的）</li>
<li>类装饰器（重载类<code>__call__</code>方法的、方法装饰器、类方法装饰器、静态类方法装饰器）</li>
</ul>
<p>简单来看一下函数装饰器：</p>
<ol type="1">
<li><strong>最外层接受参数的装饰器</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## 带参数的函数装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最外层接受参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec1</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="comment"># 第二层接受函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec2</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="comment"># 第三层接受函数的参数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line">    <span class="keyword">return</span> dec2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>不带参数的函数装饰器</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## 不带参数的函数装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最外层接受函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec2</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="comment"># 第二层接受函数的参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">        func(*args)</span><br><span class="line">    <span class="keyword">return</span> warp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>装饰类的函数装饰器</strong>，由于装饰类的时候也有带参数和不带参数的区分，简单起见，这里还是以不带参数为例(带参数也就是多写一层包装函数即可)</li>
</ol>
<p>装饰类的时候的时候目的是管理类的功能，此时装饰器类似于元类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## 装饰类的函数装饰器(假设不带额外参数)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最外层用来接受类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec2</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="comment"># 对cls做一些处理并返回一个class</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NewClass</span>(<span class="title class_ inherited__">cls</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">super</span>().__init__()</span><br><span class="line">            self.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> NewClass</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><strong>装饰类方法的函数装饰器</strong>，由于装饰类方法的时候也有带参数和不带参数的区分，这里还是以不带参数为例</li>
</ol>
<p>其实就是多管理一个self对象而已，值得一提的是，warp和func里的self可以没有。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## 装饰类方法的函数装饰器(假设不带额外参数)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec2</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="comment"># 第二层接受函数的参数，就多一个self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">        func(self, *args)</span><br><span class="line">    <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或下面这种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec2</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="comment"># 第二层接受函数的参数，就多一个self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">        func(*args)</span><br><span class="line">    <span class="keyword">return</span> warp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面是基本的函数装饰器的一些写法，下面来看看类装饰器</p>
<ol type="1">
<li><strong>重载类<code>__call__</code>方法的类装饰器</strong></li>
</ol>
<p>此时使用装饰器时需要创建实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## 重载类__call__方法的类装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dec1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arg</span>):</span><br><span class="line">        self.arg = arg</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 重载__call__方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用时需要创建实例</span></span><br><span class="line">d = Dec1(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@d</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"world"</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>方法装饰器</strong>与<strong>类方法装饰器</strong></li>
</ol>
<p>使用类的一个方法作为装饰器时，需要创建实例；使用类的一个类方法作为装饰器时，不需要创建实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## 方法装饰器与类方法装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec1</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec1"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec2</span>(<span class="params">cls, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec2"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法装饰器需要创建实例</span></span><br><span class="line">a = A()</span><br><span class="line"><span class="meta">@a.dec1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类方法装饰器不需要创建实例</span></span><br><span class="line"><span class="meta">@A.dec2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>静态类方法装饰器</strong></li>
</ol>
<p>静态类方法装饰器不需要处理cls或self对象，速度更快</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dec</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="comment"># 注意这里少传入了cls或self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec1</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="meta">@Dec.dec1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"world"</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于上述提到的装饰器非常简单，所以就一带而过了。下面我们来看看一些比较实际的应用。</p>
<h2 id="将装饰器封装到类里">将装饰器封装到类里</h2>
<p>加入在项目的构建中有很多装饰器，这些装饰器的功能相似(比如都是用来做一些预处理的)，那么我们可以将<strong>这些装饰器封装到一个类里</strong>，这样就可以方便的管理这些装饰器了。</p>
<p>这些封装在类的装饰器装饰的目标不同时，写法也会有差异</p>
<h3 id="去装饰普通函数">去装饰普通函数</h3>
<p>如果一个封装在类的装饰器只是用来装饰普通函数，那么写起来还是比较随意的：用<strong>普通的方法封装</strong>、用<strong>类方法封装</strong>还是用<strong>静态类方法封装</strong>都可以。</p>
<p>区别是普通方法封装需要处理self对象，且要通过实例调用；而类方法封装需要处理cls对象，不需要通过实例调用；静态类方法封装不需要处理cls或self对象，速度更快，也不需要实例。</p>
<p><strong>因此，如果封装在类里面的装饰器只用来装饰普通函数，那么用静态类方法是不错的选择。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dec</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec1</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec1"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec2</span>(<span class="params">cls, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec2"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec3</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec3"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通方法封装要使用实例</span></span><br><span class="line">dec = Dec()</span><br><span class="line"><span class="meta">@dec.dec1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类方法封装不需要使用实例</span></span><br><span class="line"><span class="meta">@Dec.dec2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态类方法封装不需要使用实例</span></span><br><span class="line"><span class="meta">@Dec.dec3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="去装饰其他类的方法">去装饰其他类的方法</h3>
<p>如果在A类里封装了一些装饰器，用来装饰B类的方法，这个时候只需要仿照之前提到的装饰类的方法的写法即可。</p>
<p>同样，装饰器中的self可写可不写。<strong>其实和处理普通函数的装饰器是一样的</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec1</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec1"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec2</span>(<span class="params">cls, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec2"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec3</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params"> *args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec3"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="comment"># 创建实例，以使用实例的方法</span></span><br><span class="line">    a = A()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用实例的方法装饰</span></span><br><span class="line"><span class="meta">    @a.dec1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用类方法装饰</span></span><br><span class="line"><span class="meta">    @A.dec2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用静态类方法装饰</span></span><br><span class="line"><span class="meta">    @A.dec3</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f3</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="去装饰本类的其他方法">去装饰本类的其他方法</h3>
<p>这种场景也很容易出现，比如在A类里给出了一个只用于本类的装饰器。而这种场景的问题也是最多的。</p>
<p>首先，先给出一些常见的<strong>错误写法</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec1</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec1"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec2</span>(<span class="params">cls, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec2"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec3</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec3"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 错误写法1</span></span><br><span class="line"><span class="meta">    @dec1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 错误写法2</span></span><br><span class="line"><span class="meta">    @A.dec2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 错误写法3</span></span><br><span class="line"><span class="meta">    @A.dec3</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f3</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们来分析一下这些错误：</p>
<ul>
<li>错误写法1：此处是<strong>用类普通方法去装饰类普通方法</strong>，但是类普通方法必须通过实例调用，此处没有实例，因此会报错。(加self也是不行的，self仅仅是指向实例的，而不创建实例)</li>
<li>错误写法2：此处是<strong>用类方法去装饰类普通方法</strong>，但是此时A类本身还没有创建出来。<strong>即想要定义A类，需要用到一个A类的类方法</strong>，陷入了一种循环依赖的情况，因此会报错。</li>
<li>错误写法3：同2</li>
</ul>
<p>其实正确的写法也很简单，<strong>就是在类里面实现一个闭包函数</strong>，而这个闭包函数就是我们的装饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="comment"># 注意这里没有self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec1</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec1"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="meta">    @dec1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>由于类创建的时候会形成一个命名空间，所以这个闭包函数可以通过命名空间来在类外获取。</p><p>由于其本身不是方法，所以不能用实例调用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line"><span class="meta">@a.dec1 </span><span class="comment">#报错</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@A.dec1 </span><span class="comment"># 可以使用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果想要实例和类都可以调用，按如下写法即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="comment"># 注意这里没有self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec1</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">warp</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"dec1"</span>)</span><br><span class="line">            func(*args)</span><br><span class="line">        <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="meta">    @dec1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在这里使用装饰器的等价调用形式，覆盖掉上面的闭包</span></span><br><span class="line">    dec1 = <span class="built_in">staticmethod</span>(dec1)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line"><span class="meta">@a.dec </span><span class="comment"># 可以使用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@A.dec </span><span class="comment"># 可以使用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
          </div>
<h2 id="总结">总结</h2>
<ul>
<li>用来装饰类方法的装饰器写法可以与用来装饰普通方法装饰写法一样，忽略掉cls或self</li>
<li>当A类中的装饰器dec需要装饰A类中的某个方法时，dec应该以闭包形式实现。若dec需要被实例和类方式调用，需要在A类最后以staticmethod形式覆盖掉dec</li>
</ul>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>python协程与asyncio</title>
    <url>/2023/02/17/python%E5%8D%8F%E7%A8%8B%E4%B8%8Easyncio/</url>
    <content><![CDATA[<p><strong>Python中的协程使用</strong></p>
<span id="more"></span>
<h2 id="协程">协程</h2>
<h3 id="yield与线程">yield与线程</h3>
<p>Python中的线程是系统级线程，会被操作系统调度；而协程则可以理解成用户级线程，不会被系统调度。</p>
<p>由于协程(用户级线程)需要用户自己去管理线程的状态(就绪、等待、阻塞)，并执行就绪线程，这需要线程能实现主动挂起的机制(不然就变成线程顺序执行了)。python中的<strong>协程其实是通过yield关键字</strong>来实现的。</p>
<p>当执行到yield处程序会主动交出控制权，然后等待下一次调用时再继续执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"world"</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">task1 = work1()</span><br><span class="line">task2 = work2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">next</span>(task1)</span><br><span class="line">    <span class="built_in">next</span>(task2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就形成了简单的<strong>循环</strong>，每次next都会执行到yield处，然后交出控制权，等待下一次调用。而循环则依次执行两个任务。</p>
<p><strong>但是上述代码只体现了yield放权，没有体现出异步</strong>，异步需要通过<code>send()</code>函数配合使用</p>
<div class="note info">
            <p>一般都是<code>n = yield m</code>这种形式，m是协程传出去的值，n是协程被唤醒时接受到的值。</p><p>如果协程<strong>处理计算任务</strong>，比如m是需要计算的东西，n是计算完成的东西，那么这个过程就类似函数调用</p><p>如果协程是<strong>事件驱动</strong>的，那么m就是请求事件的信息，n是响应事件</p>
          </div>
<p>因为yield想必已经很熟了，上面就简单提一下不再赘述。</p>
<h3 id="asyncio库">asyncio库</h3>
<p>Python对于协程后续引入了asyncio库，这个库提供了对协程的支持，本着学新不学旧的原则，所以后续主要是针对此库来学习下协程。</p>
<p>先来一个简单的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个协程函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 协程函数返回协程协程对象</span></span><br><span class="line">task = work1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行协程，需要在一个循环里运行</span></span><br><span class="line">asyncio.run(task)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要说明几点：</p>
<ul>
<li><code>async def</code>定义的函数是协程函数，可以使用<code>await</code>关键字。<strong>所有async函数返回的都是协程对象，就像所有的yield函数返回的都是迭代器对象一样</strong>。</li>
<li><code>asyncio.run()</code>其实建立了一个<strong>循环</strong>，这个循环会不断寻找哪个协程可以运行，知道所有协程运行完毕。(协程在运行时会主动挂起放权)</li>
<li><code>await</code>后只能接<code>async def</code>定义的函数，这个await会做这几件事情：
<ul>
<li>运行<code>async def</code>定义的函数(<strong>不加await的运行时会返回协程对象，不会真正进入协程中</strong>)，直到运行不下去为止(比如yield主动放权、新建了一个task然后本函数运行完了)</li>
<li>yield出控制权</li>
<li>再次被唤醒的时候，会把<code>async def</code>定义的函数的返回值返回</li>
</ul></li>
</ul>
<p><strong>await之于asyncio类似与yield from之于生成器</strong></p>
<div class="note primary">
            <p><strong>Task和futures</strong></p><ul><li>循环最小的调度单位是Task，Task是对协程的封装，因此循环每次只能调度一个Task</li><li>futures其实是更加底层的东西(Task其实是Future的子类)，futures主要用于接受异步执行的结果</li></ul><p><strong>两者都是可以直接放在await后面</strong></p>
          </div>
<div class="note info">
            <p>对于如下两种形式的代码，结果是一样的，但是过程不一样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.creat_task(asyncio.sleep(<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，<code>f1()</code>函数会直接进入<code>asyncio.sleep()</code>函数，不会为其创建任务，在这个函数内某个地方放权。</p><p>而<code>f2()</code>函数会为<code>asyncio.sleep()</code>创建一个任务，然后<code>f2()</code>函数等待这个任务完成自己阻塞，<strong>在下一次task调度的时候，会去调度就绪的延时任务</strong>，直到该延时任务完成才回过头来执行<code>f2()</code></p>
          </div>
<p>由于await的时候不会新建一个task，所以可能无法很好的利用协程异步，就拿python官方文档这个例子来说：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"started at <span class="subst">{time.strftime(<span class="string">'%X'</span>)}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 两个任务顺序执行，都被阻塞了</span></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"finished at <span class="subst">{time.strftime(<span class="string">'%X'</span>)}</span>"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>await say_after(1, 'hello')</code>时，需要阻塞当前协程，进入到<code>asyncio.sleep(1)</code>里，此时没有其他协程可以运行，故空等；同样，<code>await say_after(2, 'world')</code>时也是空等。<strong>故两个任务顺序执行，总共耗时3s</strong></p>
<img src="/2023/02/17/python%E5%8D%8F%E7%A8%8B%E4%B8%8Easyncio/pic1.png" class="">
<p>上述问题的原因就是在执行第一个<code>await</code>的时候，不知道后面还有一个可以同时等待的任务，所以就阻塞了。</p>
<p>解决的方法也很简单，就是提前在循环里注册所有需要等待的任务，这样就可以同时等待，从而实现异步。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 先创建task</span></span><br><span class="line">    task1 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">1</span>, <span class="string">'hello'</span>))</span><br><span class="line"></span><br><span class="line">    task2 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">2</span>, <span class="string">'world'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"started at <span class="subst">{time.strftime(<span class="string">'%X'</span>)}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait until both tasks are completed (should take</span></span><br><span class="line">    <span class="comment"># around 2 seconds.)</span></span><br><span class="line">    <span class="comment"># 然后等待task完成</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"finished at <span class="subst">{time.strftime(<span class="string">'%X'</span>)}</span>"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码事先创建了任务，从而实现了异步，总共耗时2s</p>
<img src="/2023/02/17/python%E5%8D%8F%E7%A8%8B%E4%B8%8Easyncio/pic2.png" class="">
<h3 id="协程与多线程">协程与多线程</h3>
<p>由于Python中GIL的存在，python的多线程其实比较假，而协程本质上也是单线程异步，所以很容易将两者比较起来。我来浅浅说一下两者区别和应用。</p>
<p>由于线程是系统调度的，不同线程的任务都能运行，因此不同的任务不会产生饥饿。但是协程需要手动放权，所以如果写不好就容易出现只有一个任务一直在运行，其他任务得不到运行的结果。</p>
<p>但是呢，协程相比于线程，更加轻量级，所以性能上有优势，协程在网络上优势大。且协程是单线程，没有竞争冒险。</p>
<p>另外，假设一个这个场景：</p>
<ul>
<li>有一个计算密集型任务，需要占用大量CPU资源</li>
<li>不时会出现临时借用小量CPU资源的任务</li>
</ul>
<p>这个时候使用协程就很麻烦，因为对大任务做拆分需要设置很多放权点，而且放权点位置和数目都要根据大任务而改变。且大任务如果调用了第三方函数计算，那么就很难控制放权点。</p>
<p>这个时候使用多线程就比较好。</p>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python协程</tag>
      </tags>
  </entry>
  <entry>
    <title>从ucore来总结操作系统(6)----线程调度算法</title>
    <url>/2023/01/23/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6/</url>
    <content><![CDATA[<h2 id="线程调度算法">线程调度算法</h2>
<span id="more"></span>
<h3 id="x00-环境准备">0X00 环境准备</h3>
<p>本lab基于前所有lab，但是需要对其进行一些扩展：</p>
<p>lab6的proc_struct结构体发生了变化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>                      <span class="comment">// Process state</span></span><br><span class="line">    <span class="type">int</span> pid;                                    <span class="comment">// Process ID</span></span><br><span class="line">    <span class="type">int</span> runs;                                   <span class="comment">// the running times of Proces</span></span><br><span class="line">    <span class="type">uintptr_t</span> kstack;                           <span class="comment">// Process kernel stack</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">bool</span> need_resched;                 <span class="comment">// bool value: need to be rescheduled to release CPU?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span>                 <span class="comment">// the parent process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>                       <span class="comment">// Process's memory management field</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>                     <span class="comment">// Switch here to run process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>                       <span class="comment">// Trap frame for current interrupt</span></span><br><span class="line">    <span class="type">uintptr_t</span> cr3;                              <span class="comment">// CR3 register: the base addr of Page Directroy Table(PDT)</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;                             <span class="comment">// Process flag</span></span><br><span class="line">    <span class="type">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];               <span class="comment">// Process name</span></span><br><span class="line">    <span class="type">list_entry_t</span> list_link;                     <span class="comment">// Process link list </span></span><br><span class="line">    <span class="type">list_entry_t</span> hash_link;                     <span class="comment">// Process hash list</span></span><br><span class="line">    <span class="type">int</span> exit_code;                              <span class="comment">// exit code (be sent to parent proc)</span></span><br><span class="line">    <span class="type">uint32_t</span> wait_state;                        <span class="comment">// waiting state</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">cptr</span>, *<span class="title">yptr</span>, *<span class="title">optr</span>;</span>     <span class="comment">// relations between processes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*以下为新增*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包含该线程的就绪队列(多级多列调度时，系统中存在多个就绪队列)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>;</span>                       <span class="comment">// running queue contains Process</span></span><br><span class="line">    <span class="comment">// 就绪队列节点</span></span><br><span class="line">    <span class="type">list_entry_t</span> run_link;                      <span class="comment">// the entry linked in run queue</span></span><br><span class="line">    <span class="comment">// 时间片</span></span><br><span class="line">    <span class="type">int</span> time_slice;                             <span class="comment">// time slice for occupying the CPU</span></span><br><span class="line">    <span class="comment">// lab6中支持stride算法的斜堆节点</span></span><br><span class="line">    <span class="type">skew_heap_entry_t</span> lab6_run_pool;            <span class="comment">// FOR LAB6 ONLY: the entry in the run pool</span></span><br><span class="line">    <span class="comment">// lab6中支持stride算法的当前线程stride步长</span></span><br><span class="line">    <span class="type">uint32_t</span> lab6_stride;                       <span class="comment">// FOR LAB6 ONLY: the current stride of the process </span></span><br><span class="line">    <span class="comment">// 优先级</span></span><br><span class="line">    <span class="type">uint32_t</span> lab6_priority;                     <span class="comment">// FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note primary">
            <p><strong>这里说一下这里的rq和run_link</strong></p><p>struct run_queue *rq :process_struct中的rq指针指向的是包含该线程的就绪队列，这样就可以通<strong>过该指针找到该线程所在的就绪队列</strong>，从而可以对该就绪队列进行操作。同时，<strong>全局还会包含一个或者多个rq，这些rq可能对应不同的优先级，其内部都是可运行线程组成的链表。</strong></p><p>list_entry_t run_link :运行队列通过链表的形式进行组织。链表的每一个节点是一个list_entry_t,每个list_entry_t 又对应到了 struct proc_struct *,这其间的转换是通过宏le2proc 来完成 的。具体来说，我们知道在 struct proc_struct 中有一个叫run_link 的 list_entry_t，因此可以通过偏移量逆向找到对应某个 run_list的struct proc_struct。即进程结构指针 proc = le2proc(链表节点指针,run_link)。</p><p><img src="/2023/01/23/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6/pic1.png" class=""></p>
          </div>
<p>为了能够支持不同的线程调度算法，lab6中引入了就绪队列的概念。就绪队列（run_queue）是一个包含了所有就绪态线程集合的队列结构，能够在有就绪线程出现时令其高效的入队，当线程脱离就绪态时高效的将其从就绪队列中移除。</p>
<p>就绪队列是一个抽象的队列，其底层实现可以是双向链表，平衡二叉树或是堆等等。由于堆结构中的元素只需要满足堆序性，而不像平衡二叉树一样需要满足全局的有序性，因此其整体效率还要略高于平衡二叉树，很适合用来实现优先级队列。这也是lab6中引入斜堆skew_heap作为stride调度算法中就绪队列的底层实现的原因。</p>
<p>由于结构体发生改变，所以初始化函数也要改变:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct * <span class="title function_">alloc_proc</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) </span><br><span class="line">    {</span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">        <span class="comment">// Lab5 code</span></span><br><span class="line">        proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// Lab6 新增code</span></span><br><span class="line">        proc-&gt;rq = <span class="literal">NULL</span>;</span><br><span class="line">        list_init(&amp;(proc-&gt;run_link));</span><br><span class="line">        proc-&gt;time_slice = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;lab6_run_pool.left = proc-&gt;lab6_run_pool.right = proc-&gt;lab6_run_pool.parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;lab6_stride = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;lab6_priority = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于调度时机由中断控制，所以还需要在中断函数里增加对应的调度:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">    ticks++;</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    sched_class_proc_tick(current);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="x01-round-robin-调度算法">0X01 Round Robin 调度算法</h3>
<p>这就是轮询调度，在ucore中，调度器引入run-queue链表，用于存储所有的可运行(就绪)的进程。当调度发生时，会从run-queue中挑选一个进程，将其标记为运行中，并切换到对应上下文中。</p>
<p>RR调度算法是默认的调度算法，<strong>但在认识调度算法之前，我们得先知道什么时候会进行调度</strong>。在ucore中，以下几种情况发生时会进行调度:</p>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 90%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">proc.c::do_exit</td>
<td style="text-align: center;">用户线程结束，主动放弃CPU</td>
</tr>
<tr class="even">
<td style="text-align: center;">proc.c::do_wait</td>
<td style="text-align: center;">用户线程等待子线程结束，主动放弃CPU</td>
</tr>
<tr class="odd">
<td style="text-align: center;">proc.c::init_main</td>
<td style="text-align: center;">1.
initproc内核线程等待所有用户进程结束，如果没有结束，就主动放弃CPU控制权;
2.
initproc内核线程在所有用户进程结束后，让kswapd内核线程执行10次，用于回收空闲内存资源</td>
</tr>
<tr class="even">
<td style="text-align: center;">proc.c::cpu_idle</td>
<td style="text-align: center;">idleproc内核线程的工作就是等待有处于就绪态的进程或线程，如果有就调用schedule函数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">sync.h::lock</td>
<td style="text-align: center;">在获取锁的过程中，如果无法得到锁，则主动放弃CPU控制权</td>
</tr>
<tr class="even">
<td style="text-align: center;">trap.c::trap</td>
<td style="text-align: center;">如果在当前进程在用户态被打断(时钟调度)，且当前进程控制块的成员变量need_resched设置为1，则当前线程会放弃CPU控制权</td>
</tr>
</tbody>
</table>
<div class="note primary">
            <p><strong>为什么将need_resched设置为1就会执行调度</strong></p><p>这是因为时间片中断发生时，trap并不是直接执行trap_dispatch，而是有所改变</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * trap - handles or dispatches an exception/interrupt. if and when trap() returns,</span></span><br><span class="line"><span class="comment"> * the code in kern/trap/trapentry.S restores the old CPU state saved in the</span></span><br><span class="line"><span class="comment"> * trapframe and then uses the iret instruction to return from the exception.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span> {</span><br><span class="line">    <span class="comment">// dispatch based on what type of trap occurred</span></span><br><span class="line">    <span class="comment">// used for previous projects</span></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>) {</span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// keep a trapframe chain in stack</span></span><br><span class="line">        <span class="comment">// 保持中断链</span></span><br><span class="line">        <span class="keyword">struct</span> trapframe *otf = current-&gt;tf;</span><br><span class="line">        current-&gt;tf = tf;</span><br><span class="line">    </span><br><span class="line">        <span class="type">bool</span> in_kernel = trap_in_kernel(tf);</span><br><span class="line">    </span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">    </span><br><span class="line">        current-&gt;tf = otf;</span><br><span class="line">        <span class="keyword">if</span> (!in_kernel) {</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;flags &amp; PF_EXITING) {</span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;need_resched) {</span><br><span class="line">                <span class="comment">// 调度发生</span></span><br><span class="line">                schedule();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
          </div>
<p>RR调度算法的调度思想是让所有runnable态的进程分时轮流使用CPU时间。RR调度器维护当前runnable进程的有序运行队列。当前进程的时间片用完之后，调度器将当前进程放置到运行队列的尾部，再从其头部取出进程进行调度。RR调度算法的就绪队列在组织结构上也是一个双向链表，只是增加了一个成员变量，表明在此就绪进程队列中的最大执行时间片。而且在进程控制块proc_struct中增加了一个成员变量time_slice，用来记录进程当前的可运行时间片段。这是由于RR调度算法需要考虑执行进程的运行时间不能太长。在每个timer到时的时候，操作系统会递减当前执行进程的time_slice，当time_slice为0时，就意味着这个进程运行了一段时间（这个时间片段称为进程的时间片），需要把CPU让给其他进程执行，于是操作系统就需要让此进程重新回到rq的队列尾，且重置此进程的时间片为就绪队列的成员变量最大时间片max_time_slice值，然后再从rq的队列头取出一个新的进程执行。下面来分析一下其调度算法的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 初始化RR调度算法的运行队列rq</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">RR_init</span><span class="params">(<span class="keyword">struct</span> run_queue *rq)</span></span><br><span class="line">{</span><br><span class="line">    list_init(&amp;(rq-&gt;run_list));</span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将进程proc加入到RR调度算法的运行队列rq中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">RR_enqueue</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 因为要把proc加入到rq中，说明proc之前不在rq里</span></span><br><span class="line">    <span class="comment">// 所以proc对应的run_link是空的，不应指向某个rq</span></span><br><span class="line">    <span class="comment">// (因为如果指向某个rq，就说明proc已经在rq里了</span></span><br><span class="line">    <span class="comment">// 既然已经在rq，为什么还要加入呢？说明此时出现了bug)</span></span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    <span class="comment">// 把proc加入到rq-&gt;run_list队列的末尾</span></span><br><span class="line">    <span class="comment">// 其实就是list类的entry，list类所有成员都通过list_entry_t来定位</span></span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 如果是时间片用完，需要重设时间片</span></span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    }</span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将进程proc从RR调度算法的运行队列rq中删除</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">RR_dequeue</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 同样需要保证proc对应的run_link不为空(保证proc在某个rq中)</span></span><br><span class="line">    <span class="comment">// 然后保证proc对应的run_link指向的rq就是当前的rq</span></span><br><span class="line">    <span class="comment">// 这样就确认了proc在当前的rq里</span></span><br><span class="line">    assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删掉对应的proc的entry</span></span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line">    rq-&gt;proc_num--;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择下一个要运行的进程</span></span><br><span class="line"><span class="comment">// 选择进程但不将从队列中移除</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct *<span class="title function_">RR_pick_next</span><span class="params">(<span class="keyword">struct</span> run_queue *rq)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 直接选择rq中的下一个</span></span><br><span class="line">    <span class="type">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数会在时间中断处理例程中被调用，以减小当前运行进程的剩余时间片。</span></span><br><span class="line"><span class="comment">// 若时间片耗尽，则设置当前进程的need_resched为1。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">RR_proc_tick</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        proc-&gt;time_slice--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，在调度时机到达时，先调用<code>schedule</code>函数调度，RR算法调用<code>RR_pick_next</code>函数选出下一个rq中的进程，然后调用<code>proc_run</code>来切换到对应的上下文上运行，当时间片用完或主动挂起就重复此过程。</p>
<h3 id="x02-实现-stride-scheduling-调度算法">0X02 实现 Stride Scheduling
调度算法</h3>
<p>uCore的Round-Robin算法可以保证每个进程得到的CPU资源是相等的，但我们希望调度器能够更加智能的为每个进程分配合理的CPU资源，让每个进程得到的时间资源与它们的优先级成正比关系。而Stride
Scheduling调度算法就是这样的一种典型而简单的算法。</p>
<p>其中，该算法的有如下几个特点：</p>
<ul>
<li>实现简单</li>
<li>可控性：可以证明Stride Scheduling对进程的调度次数正比于其优先级</li>
<li>确定性：在不考虑计时器事件的情况下，整个调度机制都是可预知和重现的。</li>
</ul>
<p>而该算法的基本思想如下：</p>
<ul>
<li>为每个runnable的进程设置一个当前状态stride，表示该进程当前的调度权。另外定义其对应的pass值，表示对应进程在调度后，stride
需要进行的累加值。</li>
<li>每次需要调度时，从当前 runnable 态的进程中选择
stride最小的进程调度。</li>
<li>对于获得调度的进程P，将对应的stride加上其对应的步长pass（只与进程的优先权有关系）。</li>
<li>在一段固定的时间之后，回到 2
步骤，重新调度当前stride最小的进程。</li>
</ul>
<div class="note info">
            <p>不过这里有个点需要注意一下，随着进程的执行，stride属性值会一直在增加，那么就有可能造成整数溢出。当stride溢出后，不当的比较可能会造成错误。那应该怎么做呢？</p><p>这里有一个结论：STRIDE_MAX – STRIDE_MIN &lt;= PASS_MAX == BIG_STRIDE/ 1（注意最小的Priority为1）。所以我们只要将BIG_STRIDE限制在某个范围内，即可保证任意两个stride之差都会在机器整数表示的范围之内。</p>
          </div>
<p>首先，需要实现其初始化函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stride_init</span><span class="params">(<span class="keyword">struct</span> run_queue *rq)</span> </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 注意这里不要使用skew_heap_init(rq-&gt;lab6_run_pool)</span></span><br><span class="line">    <span class="comment">// 因为rq-&gt;lab6_run_pool只是一个指针，而不是一个对象。</span></span><br><span class="line">    list_init(&amp;(rq-&gt;run_list));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 堆初始化为空</span></span><br><span class="line">    rq-&gt;lab6_run_pool = <span class="literal">NULL</span>;</span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>stride_enqueue和stride_dequeue与RR算法相差不大，主要就是通过一个堆来管理进程的调度权。由于堆比较简单，所以不再赘诉。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 插入进程</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stride_enqueue</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span> </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 按照stride的大小插入到堆中</span></span><br><span class="line">    rq-&gt;lab6_run_pool = skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">    <span class="comment">// 如果是超时需要重置时间片</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) {</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    }</span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个进程</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stride_dequeue</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span> </span><br><span class="line">{</span><br><span class="line">    rq-&gt;lab6_run_pool = skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">    rq-&gt;proc_num --;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个进程的优先级，用于调度</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">proc_stride_comp_f</span><span class="params">(<span class="type">void</span> *a, <span class="type">void</span> *b)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(a, lab6_run_pool);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(b, lab6_run_pool);</span><br><span class="line">    <span class="type">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择下一个进程用于调度</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct *<span class="title function_">stride_pick_next</span><span class="params">(<span class="keyword">struct</span> run_queue *rq)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="type">skew_heap_entry_t</span> *she = rq-&gt;lab6_run_pool;</span><br><span class="line">    <span class="keyword">if</span> (she != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(she, lab6_run_pool);</span><br><span class="line">        <span class="comment">// 这里需要防止溢出，就使用之前的公式</span></span><br><span class="line">        p-&gt;lab6_stride += BIG_STRIDE / p-&gt;lab6_priority;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="x03-总结">0X03 总结</h3>
<p>通过这个lab6，我们学习了以下内容:</p>
<ul>
<li>进程调度时机</li>
<li>进程调度具体过程</li>
<li>进程调度算法的实现</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>ucore操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>从ucore来总结操作系统(9)----仿照ucore来实现一个自己的操作系统</title>
    <url>/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-9/</url>
    <content><![CDATA[<h2 id="仿照ucore来实现一个自己的内核">仿照ucore来实现一个自己的内核</h2>
<span id="more"></span>
<h3 id="硬件无关的内核">硬件无关的内核</h3>
<p>之前已经完成了ucore的所有lab，但是很多代码都是实现好的，且有很多细节没有去了解。所以做的时候就想着能不能一边做lab，一边按照自己的想法去实现(抄)一个更简单的玩具级操作系统内核呢？</p>
<p>操作系统本身模块很多，且软件硬件相互依赖，而且还需要对硬件实现各种驱动，还需要对CPU寄存器、架构有比较多的了解。</p>
<p>由于写一个内核本就是一时兴起，且扎入硬件中也非我本意，所以打算直接实现一个与硬件无关的内核。</p>
<p>实现硬件无关的最简单方式就是基于<strong>硬件抽象层</strong>，把内核扔在这上面运行。单片机厂商是会提供硬件抽象层的，所以这个内核可以直接实现在单片机上。且单片机有中断、定时器等丰富的外设，实现一个内核是绰绰有余。</p>
<p>因此，我打算基于stm32f103c8t6来实现一个操作系统内核，它有64KB的FLash和20KB的RAM。</p>
<div class="note primary">
            <p>顺便一提，单片机上有freerots等实时操作系统内核，是可以借鉴的好资源</p>
          </div>
<h3 id="内核的结构与实现手段">内核的结构与实现手段</h3>
<p>内核的结构与实现手段与ucore类似，但是由于是硬件无关的，所以不需要考虑硬件的细节。内核主要由以下几部分组成：</p>
<ul>
<li><strong>中断系统</strong></li>
</ul>
<p>硬件抽象层会提供中断服务函数，因为要仿照ucore，我们把所有的中断都发送到一个trap函数上处理。</p>
<p>同时需要有时间片中断，这个可以用一个定时器来实现。</p>
<p>还可以实现一个伪中断，用于系统调用。这个我是使用一个外部引脚的中断来实现的(先把系统调用编号放入一个环境变量中，然后触发外部中断来实现)。</p>
<ul>
<li><strong>内存管理</strong></li>
</ul>
<p>由于单片机会把外设的寄存器映射到存储器上，这取决于单片机的存储器映像图，且单片机的内存管理都是访问物理地址，没有虚拟地址这一说。</p>
<img src="/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-9/pic1.png" class="">
<p>上图就是存储器映像，可以看到SRAM的地址是0x20000000开始的一段连续的地址，大小为20KB。由于总内存比较小，所以物理页面选择256B，这样就有80个物理页面。但是因为硬件上不支持虚拟内存的功能，所以虚拟内存这一块只能阉割一下了。</p>
<p>但是按照页来管理物理内存的颗粒度太大，很浪费，所以需要实现一个更加精细的内存管理方案。</p>
<p><strong>因为没有虚拟内存，缺页中断、页表、页面置换、页面权限控制都不存在了，这里阉割其实还是挺大的，好在这些也不是很困难，缺就缺吧</strong></p>
<ul>
<li><strong>线程管理</strong></li>
</ul>
<p>类似ucore，这个内核也没有进程，只存在线程。需要为每个线程提供描述结构，同时还需要支持上下文切换等等(涉及到一部分汇编)。</p>
<p>线程可以将自己挂起，或者是因为时间片用完而被挂起。时间片中断则是通过定时器来实现的。</p>
<ul>
<li><strong>同步量、互斥</strong></li>
</ul>
<p>有了线程的管理的内容，这部分还是比较好实现的。</p>
<ul>
<li><strong>文件系统</strong></li>
</ul>
<p>为了实现一个文件系统，决定把20KB的内存，分为16KB+4KB。其中4KB伪装成磁盘，内容将是在内核启动后固定动态生成。同时可以串口读取这部分内容，以检查文件写入读取创建是否正确。</p>
<p>但是由于不支持虚拟内存，所以文件系统的实现也是阉割的，只能实现一个简单的文件系统，只支持文件的读写，不支持动态加载程序。</p>
<p>当然这个文件系统比较简单，没有虚拟文件系统那一坨。</p>
<p><strong>其实我现在基本上写完了，但是跑起来的时候似乎存在非常诡异的bug，还在调试中....</strong></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>ucore操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>双目摄像头标定、视差图与测距的实现--玩具级别</title>
    <url>/2022/10/19/%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%87%E5%AE%9A%E3%80%81%E8%A7%86%E5%B7%AE%E5%9B%BE%E4%B8%8E%E6%B5%8B%E8%B7%9D/</url>
    <content><![CDATA[<h2 id="双目摄像头标定视差图与测距">双目摄像头标定、视差图与测距</h2>
<span id="more"></span>
<p>因为贫穷，所以从海鲜市场捡了俩双目摄像头来进行标定和重建。由于原理部分的笔记还在整理中，所以本篇主要是直接介绍应用，旨在快速完成标定和测距的任务。</p>
<img src="/2022/10/19/%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%87%E5%AE%9A%E3%80%81%E8%A7%86%E5%B7%AE%E5%9B%BE%E4%B8%8E%E6%B5%8B%E8%B7%9D/pic0.jpg" class="">
<p>廉价的相机...还是双帧不同步的，只能希望时差不要太大了捏。</p>
<h3 id="相机标定">相机标定</h3>
<h4 id="拍摄标定板">拍摄标定板</h4>
<p>相机标定主要是用来标定相机内参矩阵的。我们使用张正友标定法。所以需要先拍摄一些标定图片。</p>
<p>由于可能会出现图像中虽然有标定板，但是在标定程序中不能正确检测出角点，所以我们直接在拍摄的时候就显示出检测的角点，这样能保证拍摄下来的图像肯定能用于标定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_chessboard_corners</span>(<span class="params">img</span>):</span><br><span class="line">    h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">assert</span> w == img.shape[<span class="number">1</span>] <span class="keyword">and</span> h == img.shape[<span class="number">0</span>], (<span class="string">"size: %d x %d ... "</span> % (</span><br><span class="line">        img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))</span><br><span class="line">    pattern_size = (<span class="number">9</span>, <span class="number">6</span>)</span><br><span class="line">    found, corners = cv2.findChessboardCorners(img, pattern_size)</span><br><span class="line">    vis = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> found:</span><br><span class="line">        term = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_COUNT, <span class="number">30</span>, <span class="number">0.1</span>)</span><br><span class="line">        cv2.cornerSubPix(img, corners, (<span class="number">5</span>, <span class="number">5</span>), (-<span class="number">1</span>, -<span class="number">1</span>), term)</span><br><span class="line">        vis = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)</span><br><span class="line">        cv2.drawChessboardCorners(vis, pattern_size, corners, found)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found, vis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cap0 = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">cap1 = cv2.VideoCapture(<span class="number">1</span>)</span><br><span class="line">img_path = <span class="string">r"StereoCamera\data\\"</span></span><br><span class="line">firstFrame = <span class="literal">None</span></span><br><span class="line">window_size = <span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">lst = <span class="built_in">open</span>(<span class="string">r'StereoCamera\data\imglst.lst'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    ret, frame1 = cap0.read()</span><br><span class="line">    ret, frame2 = cap1.read()</span><br><span class="line">    frame1 = cv2.resize(frame1, (<span class="number">640</span>, <span class="number">480</span>), interpolation=cv2.CV_8SC1)</span><br><span class="line">    frame2 = cv2.resize(frame2, (<span class="number">640</span>, <span class="number">480</span>), interpolation=cv2.CV_8SC1)</span><br><span class="line">    frame = np.concatenate([frame1, frame2], axis=<span class="number">1</span>)</span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>, frame)</span><br><span class="line"></span><br><span class="line">    frame_left = frame1</span><br><span class="line">    frame_right = frame2</span><br><span class="line">    found1, vis1 = find_chessboard_corners(</span><br><span class="line">        cv2.cvtColor(frame_left, cv2.COLOR_BGR2GRAY))</span><br><span class="line">    found2, vis2 = find_chessboard_corners(</span><br><span class="line">        cv2.cvtColor(frame_right, cv2.COLOR_BGR2GRAY))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> found1 <span class="keyword">and</span> found2:</span><br><span class="line">        image = np.concatenate([vis1, vis2], axis=<span class="number">1</span>)</span><br><span class="line">        image = np.concatenate([frame, image])</span><br><span class="line">        cv2.imshow(<span class="string">'output'</span>, image)</span><br><span class="line"></span><br><span class="line">    key = cv2.waitKey(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> key == <span class="built_in">ord</span>(<span class="string">"s"</span>) <span class="keyword">and</span> found1 <span class="keyword">and</span> found2:</span><br><span class="line"></span><br><span class="line">        cv2.imwrite((<span class="string">f'<span class="subst">{img_path}</span><span class="subst">{i}</span>left.jpg'</span>), frame_left)</span><br><span class="line">        cv2.imwrite((<span class="string">f'<span class="subst">{img_path}</span><span class="subst">{i}</span>right.jpg'</span>), frame_right)</span><br><span class="line"></span><br><span class="line">        lst.write(<span class="string">f"<span class="subst">{img_path}</span><span class="subst">{i}</span>left.jpg\n"</span>)</span><br><span class="line">        lst.write(<span class="string">f"<span class="subst">{img_path}</span><span class="subst">{i}</span>right.jpg\n"</span>)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">20</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> key &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">lst.close()</span><br><span class="line">cap0.release()</span><br><span class="line">cap1.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>注意修改路径和你的标定板的角点数目哦！</p><p>当出现角点的时候，按下s就能截取了，会保存若干图像和一个路径文件，用于标定。</p>
          </div>
<img src="/2022/10/19/%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%87%E5%AE%9A%E3%80%81%E8%A7%86%E5%B7%AE%E5%9B%BE%E4%B8%8E%E6%B5%8B%E8%B7%9D/pic1.png" class="">
<p>一般来说，我们需要拍摄20张左右的标定板，让标定板最好位于各个位置。</p>
<h4 id="调用opencv-samples中标定程序用于标定">调用opencv
samples中标定程序用于标定</h4>
<p>在opencv的samples/cpp文件夹中，有一个现成的给图像进行标定的程序<code>stereo_calib.cpp</code>，我们先把它编译好(在编译它之前，你得先编译opencv这个库哦~)。</p>
<p>不妨假设你已经编译好这个程序了，下一步就是要制作一个xml文件，用于告诉他，哪些图像是用于标定的。</p>
<p>xml形式如下，我们把这个文件命名为<code>stereo_calib.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">opencv_storage</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">imagelist</span>&gt;</span></span><br><span class="line">"data\0left.jpg"</span><br><span class="line">"data\0right.jpg"</span><br><span class="line">...</span><br><span class="line">(这里放你的图像路径哦，一行一个，像上面那样)</span><br><span class="line"><span class="tag">&lt;/<span class="name">imagelist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">opencv_storage</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在命令行中执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// w h分别是角点的横向和纵向的数目，s是面积</span><br><span class="line"></span><br><span class="line">stereo_calib.exe -w=9 -h=6 -s=1 stereo_calib.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后就会生成两个文件<code>intrinsics.yml</code>和<code>extrinsics.yml</code>这就是标定后的参数矩阵哦。</p>
<h3 id="视差图与测距">视差图与测距</h3>
<p>完成相机的标定后，我们使用BM算法进行立体匹配，然后根据空间坐标的公式完成测距。同样此处也不深入这些原理，而是给出应用。</p>
<p>我们首先把之前的<code>intrinsics.yml</code>和<code>extrinsics.yml</code>放在测距文件的同一目录下，这样你复制下来就不用修改路径了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">depthWinTitle = <span class="string">'Depth'</span></span><br><span class="line"></span><br><span class="line">cv.namedWindow(depthWinTitle)</span><br><span class="line">cv.createTrackbar(<span class="string">"num"</span>, depthWinTitle, <span class="number">0</span>, <span class="number">10</span>, <span class="keyword">lambda</span> x: <span class="literal">None</span>)</span><br><span class="line">cv.createTrackbar(<span class="string">"blockSize"</span>, depthWinTitle, <span class="number">5</span>, <span class="number">255</span>, <span class="keyword">lambda</span> x: <span class="literal">None</span>)</span><br><span class="line">cv.namedWindow(<span class="string">"3D Cam"</span>)</span><br><span class="line">cv.moveWindow(<span class="string">"3D Cam"</span>, <span class="number">100</span>, <span class="number">50</span>)</span><br><span class="line">cv.moveWindow(depthWinTitle, <span class="number">800</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callbackfunc</span>(<span class="params">e, x, y, f, p</span>):</span><br><span class="line">    <span class="keyword">if</span> e == cv.EVENT_LBUTTONDOWN:</span><br><span class="line">        <span class="built_in">print</span>(threeD[y][x])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv.setMouseCallback(depthWinTitle, callbackfunc, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">fs = cv.FileStorage(<span class="string">r'intrinsics.yml'</span>, cv.FILE_STORAGE_READ)</span><br><span class="line">M1 = fs.getNode(<span class="string">'M1'</span>).mat()</span><br><span class="line">D1 = fs.getNode(<span class="string">'D1'</span>).mat()</span><br><span class="line">M2 = fs.getNode(<span class="string">'M2'</span>).mat()</span><br><span class="line">D2 = fs.getNode(<span class="string">'D2'</span>).mat()</span><br><span class="line"></span><br><span class="line">fs = cv.FileStorage(<span class="string">r'extrinsics.yml'</span>, cv.FILE_STORAGE_READ)</span><br><span class="line">R = fs.getNode(<span class="string">'R'</span>).mat()</span><br><span class="line">T = fs.getNode(<span class="string">'T'</span>).mat()</span><br><span class="line">R1 = fs.getNode(<span class="string">'R1'</span>).mat()</span><br><span class="line">P1 = fs.getNode(<span class="string">'P1'</span>).mat()</span><br><span class="line">R2 = fs.getNode(<span class="string">'R2'</span>).mat()</span><br><span class="line">P2 = fs.getNode(<span class="string">'P2'</span>).mat()</span><br><span class="line">Q = fs.getNode(<span class="string">'Q'</span>).mat()</span><br><span class="line"></span><br><span class="line">cap0 = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line">cap1 = cv.VideoCapture(<span class="number">1</span>)</span><br><span class="line">size = (<span class="number">640</span>, <span class="number">480</span>)</span><br><span class="line">left_map1, left_map2 = cv.initUndistortRectifyMap(</span><br><span class="line">    M1, D1, R1, P1, size, cv.CV_16SC2)</span><br><span class="line">right_map1, right_map2 = cv.initUndistortRectifyMap(</span><br><span class="line">    M2, D2, R2, P2, size, cv.CV_16SC2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame1 = cap0.read()</span><br><span class="line">    ret, frame2 = cap1.read()</span><br><span class="line">    frame1 = cv.resize(frame1, (<span class="number">640</span>, <span class="number">480</span>), interpolation=cv.CV_8SC1)</span><br><span class="line">    frame2 = cv.resize(frame2, (<span class="number">640</span>, <span class="number">480</span>), interpolation=cv.CV_8SC1)</span><br><span class="line">    frame = np.concatenate([frame1, frame2], axis=<span class="number">1</span>)</span><br><span class="line">    frame_left = frame1</span><br><span class="line">    frame_right = frame2</span><br><span class="line"></span><br><span class="line">    left_rectified = cv.remap(frame_left, left_map1,</span><br><span class="line">                              left_map2, cv.INTER_LINEAR)</span><br><span class="line">    right_rectified = cv.remap(</span><br><span class="line">        frame_right, right_map1, right_map2, cv.INTER_LINEAR)</span><br><span class="line">    rectified = np.concatenate([left_rectified, right_rectified], axis=<span class="number">1</span>)</span><br><span class="line">    image = np.concatenate([frame, rectified])</span><br><span class="line"></span><br><span class="line">    imgL = cv.cvtColor(left_rectified, cv.COLOR_BGR2GRAY)</span><br><span class="line">    imgR = cv.cvtColor(right_rectified, cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    num = cv.getTrackbarPos(<span class="string">"num"</span>, depthWinTitle)</span><br><span class="line">    blockSize = cv.getTrackbarPos(<span class="string">"blockSize"</span>, depthWinTitle)</span><br><span class="line">    <span class="keyword">if</span> blockSize % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        blockSize += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> blockSize &lt; <span class="number">5</span>:</span><br><span class="line">        blockSize = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    stereo = cv.StereoBM_create(numDisparities=<span class="number">16</span> * num, blockSize=blockSize)</span><br><span class="line">    <span class="comment">#print(16 * num, blockSize)</span></span><br><span class="line">    disparity = stereo.compute(imgL, imgR)</span><br><span class="line"></span><br><span class="line">    disp = cv.normalize(disparity, disparity, alpha=<span class="number">0</span>,</span><br><span class="line">                        beta=<span class="number">255</span>, norm_type=cv.NORM_MINMAX, dtype=cv.CV_8U)</span><br><span class="line">    threeD = cv.reprojectImageTo3D(disparity.astype(np.float32) / <span class="number">16.</span>, Q)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">30</span>):</span><br><span class="line">        cv.line(image, (<span class="number">0</span>, <span class="number">16</span> * i), (<span class="number">640</span>, <span class="number">16</span> * i), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    cv.imshow(<span class="string">'3D Cam'</span>, image)</span><br><span class="line">    cv.imshow(depthWinTitle, disp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap0.release()</span><br><span class="line">cap1.release()</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行这个文件，就会自动采集图像进行匹配，最后计算出深度。</p>
<p>用鼠标在视差图上点一下就会显示出深度信息了哦。</p>
<img src="/2022/10/19/%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%87%E5%AE%9A%E3%80%81%E8%A7%86%E5%B7%AE%E5%9B%BE%E4%B8%8E%E6%B5%8B%E8%B7%9D/pic3.png" class="">
<p>作为一个双帧不同步的摄像头，这个视差图的效果感觉已经可以了，准确率还算可以，能跟5块钱的超声波测距打的有来有回，符合了一个玩具的身份...</p>
<p>当然，感觉标定板用的比较小，导致标定的误差还是比较大，还有一定的优化空间。</p>
<p>有钱了一定要上好一点的相机！</p>
<div class="note primary">
            <p>这篇博客代表三维视觉部分正式开坑了啦，考虑到这部分代码写的比较乱，打算后面在具体阐述原理的时候把他们好好地整理成一个方便可用的库。</p>
          </div>
]]></content>
      <categories>
        <category>三维视觉</category>
      </categories>
      <tags>
        <tag>双目摄像头</tag>
      </tags>
  </entry>
  <entry>
    <title>实现python的强类型检查</title>
    <url>/2023/02/22/%E5%AE%9E%E7%8E%B0python%E7%9A%84%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<p><strong>通过描述符、描述符MXIN、参数注解等方法来实现强制类型转换</strong></p>
<span id="more"></span>
<h2 id="类型检查">类型检查</h2>
<p>python本身是弱类型的语言，虽然使用方便，但是也会带来一些问题，比如在函数中传入了错误的类型，或者在使用某个变量时，忘记了它的类型，这些问题都会导致程序出错，而且很难发现。</p>
<p>有时候我们需要对传入的参数进行类型检查，以减少错误，这里介绍几种实现强类型检查的方法。</p>
<h3 id="使用描述符">使用描述符</h3>
<p>限制类型时首先想到的应该就是描述符。描述符本身也很简单，用的也比较多，这里就不再赘述了，下面是一个简单的描述符类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecInt</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,key</span>):</span><br><span class="line">        self.key=<span class="string">""</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="comment"># 设置时判断类型</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"not int"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            instance.__dict__[self.key]=value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.key]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self, instance</span>):</span><br><span class="line">        instance.__dict__.pop(self.key)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>:</span><br><span class="line">    nums=DecInt(<span class="string">"nums"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,nums</span>):</span><br><span class="line">        self.nums = nums</span><br><span class="line"></span><br><span class="line">a = X(<span class="number">1</span>)   <span class="comment"># 正常</span></span><br><span class="line">b = X(<span class="string">"1"</span>) <span class="comment"># 报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用描述符与mxin方法">使用描述符与MXIN方法</h3>
<p>描述符类可以玩的更花一点，就是使用继承关系，实现MXIN。不过这样理解起来有点复杂，下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 先创建一个描述符类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Descriptor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="literal">None</span>, **opts</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> opts.items():</span><br><span class="line">            <span class="built_in">setattr</span>(self, key, value)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面创建出用来类型检查的的二级基类，也不应实例化，本质还是描述符</span></span><br><span class="line"><span class="comment"># 这些类不应该被实例化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Typed</span>(<span class="title class_ inherited__">Descriptor</span>):</span><br><span class="line">    <span class="comment"># 在赋值的时候会检查类型是否相符</span></span><br><span class="line">    expected_type = <span class="built_in">type</span>(<span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, expected_type):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"expected "</span> + <span class="built_in">str</span>(self.expected_type))</span><br><span class="line">        <span class="built_in">super</span>().__set__(instance, value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Unsigned</span>(<span class="title class_ inherited__">Descriptor</span>):</span><br><span class="line">    <span class="comment"># 继承自描述符类，改写set方法，用来赋值时检查值是否大于0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"value must &gt; 0"</span>)</span><br><span class="line">        <span class="built_in">super</span>().__set__(instance, value)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxSized</span>(<span class="title class_ inherited__">Descriptor</span>):</span><br><span class="line">    <span class="comment"># 继承自描述符类，检查赋值的字符串长度是否超出限制</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="literal">None</span>, **opt</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'size'</span> <span class="keyword">not</span> <span class="keyword">in</span> opt:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"missing size option"</span>)</span><br><span class="line">        <span class="built_in">super</span>.__init__(name, **opt)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(value) &gt;= self.size:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"&gt; size"</span>)</span><br><span class="line">        <span class="built_in">super</span>.__set__(instance, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面基于描述符类来创建出需要用到检测类型的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>(<span class="title class_ inherited__">Typed</span>):</span><br><span class="line">    expected_type = <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsignedInteger</span>(Integer, Unsigned):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>(<span class="title class_ inherited__">Typed</span>):</span><br><span class="line">    expected_type = <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SizedString</span>(String, MaxSized):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后就可以使用这些类来进行类型约束</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span>:</span><br><span class="line">    name = SizedString(<span class="string">'name'</span>, size = <span class="number">8</span>)</span><br><span class="line">    shares = UnsignedInteger(<span class="string">'shares'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kargs</span>):</span><br><span class="line">        ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>下面来解释一下流程:</p><ul><li>首先<code>Descriptor</code>只是一个简单的描述符基类，且只有<code>set</code>方法</li><li><code>Typed</code>, <code>Unsigned</code>,<code>MaxSized</code>也是描述符，这些二级描述符继承自<code>Descriptor</code>，并重写了其<code>set</code>方法，分别检测赋值时类型、长度。</li><li><code>Integer</code>, <code>UnsignedInteger</code>,<code>String</code>,<code>SizedString</code>是继承上述描述符类，并基于上述限制来进行组合。由于默认没有构造函数，会使用基类的构造函数。<strong>同样也是描述符。</strong></li><li>直接使用的描述符是<code>Integer</code>,<code>UnsignedInteger</code>, <code>String</code>,<code>SizedString</code></li></ul><p><strong>同样，也可以使用装饰器的方式来完成，且速度更快！</strong></p>
          </div>
<p>当然，上面这个例子不使用MXIN也可以，只使用描述符也能达成相同效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecType</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key, type_</span>):</span><br><span class="line">        self.key=<span class="string">""</span></span><br><span class="line">        self.type_ = type_</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="comment"># 设置时判断类型</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, self.type_):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"not type {}"</span>.<span class="built_in">format</span>(self.type_))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            instance.__dict__[self.key]=value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.key]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self, instance</span>):</span><br><span class="line">        instance.__dict__.pop(self.key)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>:</span><br><span class="line">    nums=DecType(<span class="string">"nums"</span>, <span class="built_in">int</span>)</span><br><span class="line">    name=DecType(<span class="string">"names"</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums, name</span>):</span><br><span class="line">        self.nums = nums</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">a = X(<span class="number">1</span>, <span class="string">"1"</span>)   <span class="comment"># 正常</span></span><br><span class="line">b = X(<span class="string">"1"</span>, <span class="number">1</span>)   <span class="comment"># 报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="通过函数注解来限制函数传入参数">通过函数注解来限制函数传入参数</h3>
<p>上面的描述符都是限制类中的数据类型，但是检查函数的类型往往也是很常见的。</p>
<p>在某一次更新之后，python引入了注解语法，<strong>但是这些注解并不会限制参数类型，只是用于提示而已</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x:<span class="built_in">int</span>, y:<span class="built_in">float</span></span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是我们<strong>可以使用一个装饰器来利用注解信息来检查参数</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args</span>):</span><br><span class="line">        check_list = func.__annotations__</span><br><span class="line">        <span class="keyword">for</span> arg, type_ <span class="keyword">in</span> <span class="built_in">zip</span>(args,check_list.values()):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(arg, type_):</span><br><span class="line">                <span class="keyword">raise</span> TypeError(<span class="string">f"<span class="subst">{arg}</span> not <span class="subst">{type_}</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@check</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x:<span class="built_in">int</span>, y:<span class="built_in">float</span></span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码主要是通过<code>__annotations__</code>来获取注解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x:<span class="built_in">int</span>, y:<span class="built_in">float</span></span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__annotations__)</span><br><span class="line"><span class="comment"># {'x': &lt;class 'int'&gt;, 'y': &lt;class 'float'&gt;, 'return': &lt;class 'int'&gt;}</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>值得一提的是，FastAPI也是使用类似的方式来检查参数类型。</p>
<h2 id="总结">总结</h2>
<ul>
<li>检查类中的参数类型可以使用描述符、描述符MXIN的方式</li>
<li>检查函数传入的参数可以通过<code>__annotations__</code>方法+装饰器来实现</li>
</ul>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>将python中同步函数转换成多线程非阻塞函数</title>
    <url>/2022/10/14/%E5%B0%86python%E4%B8%AD%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%88%90%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="使用一个装饰器来将python中的同步函数转化成多线程函数">使用一个装饰器来将python中的同步函数转化成多线程函数</h2>
<span id="more"></span>
<div class="note info">
            <p>python由于GIL锁的原因，不支持真正的多线程，但是可以利用多线程来利用由于IO引起的阻塞问题，也算是曲线多线程了。</p>
          </div>
<h3 id="缘由">缘由</h3>
<p>目前我正在写一个基于<code>Requests</code>的多线程图像下载库框架，<a href="https://github.com/staskaer/anime_crawler">可以查看这里，目前已经基本写完</a>。爬虫可以异步来实现高并发以充分利用网络IO的等待，但是众所周知，<code>Requests</code>库是不支持异步的，但是可以通过多线程的方式来为其实现异步，不过使用线程的开销会稍微大一些。</p>
<h3 id="实现方式">实现方式</h3>
<p>实现方式很简单，只需要一个装饰器即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_async</span>(<span class="params">callback</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__exec</span>():</span><br><span class="line">                out = func(*args, **kwargs)</span><br><span class="line">                callback(out)</span><br><span class="line">                <span class="keyword">return</span> out</span><br><span class="line">            <span class="keyword">return</span> asyncio.get_event_loop().run_in_executor(<span class="literal">None</span>, __<span class="built_in">exec</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_callback</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line"><span class="meta">@run_async(<span class="params">_callback</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">return</span> requests.get(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get(<span class="string">"https://baidu.com"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done!"</span>) <span class="comment"># 注意这里是无阻塞的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只需要这样实现一个装饰器就能实现<code>requests.get()</code>函数的并发。</p>
<h3 id="使用线程池来进行改进">使用线程池来进行改进</h3>
<p>但是在时间过程中，上述代码不能长时间运行，否则内存占用会不断飙升。</p>
<p>原因是每次都创建出一个开销比较高的线程，但是没有进行回收，所以不断驻留在内存中导致占用过高。</p>
<p>不过我们可以使用线程池来修改它，将其资源限制在一定范围内。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_async</span>(<span class="params">callback</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__exec</span>():</span><br><span class="line">                out = func(*args, **kwargs)</span><br><span class="line">                callback(out) </span><br><span class="line">                <span class="keyword">return</span> out</span><br><span class="line">            <span class="keyword">return</span> pool.submit(__<span class="built_in">exec</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样每次都会从线程池拿一个线程出来进行处理。</p>
<h3 id="使其能用于类方法">使其能用于类方法</h3>
<p>上述代码虽然解决了内存占用问题，但是还有一个问题没有解决。</p>
<p>比如我定义了一个<code>Downloader</code>类，里面有<code>callback(self, *args)</code>和<code>download(self, *args)</code>函数。其中<code>download(self, *args)</code>函数负责下载任务，然后返回下载结果并交给<code>callback(self, *args)</code>处理，由于下载是并发的，所以装饰器会在<code>download(self, *args)</code>头上，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Donwloader</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,**kwargs</span>):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @run_async(<span class="params">callback</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="comment"># 下载一些东西</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="comment"># 回调函数</span></span><br><span class="line">        ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但这样是不能正常工作的，因为self没有被正常传递</p>
<p>改成下面这样就可以了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> anime_crawler.settings <span class="keyword">import</span> MAX_CONCURRENT_REQUESTS</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(MAX_CONCURRENT_REQUESTS)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_async_c</span>(<span class="params">callback</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__exec</span>():</span><br><span class="line">                out = func(*args, **kwargs)</span><br><span class="line">                callback(args[<span class="number">0</span>], out)  <span class="comment"># args[0]是self</span></span><br><span class="line">                <span class="keyword">return</span> out</span><br><span class="line">            <span class="keyword">return</span> pool.submit(__<span class="built_in">exec</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Donwloader</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,**kwargs</span>):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @run_async_c(<span class="params">callback</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="comment"># 下载一些东西</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="comment"># 回调函数</span></span><br><span class="line">        ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python异步</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>将python中的同步函数转换成协程异步函数(gevent)</title>
    <url>/2023/02/19/%E5%B0%86python%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8D%8F%E7%A8%8B%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0-gevent/</url>
    <content><![CDATA[<p><strong>使用gevent库来将python中的同步函数转化成多线程函数</strong></p>
<span id="more"></span>
<h2 id="将requests库转换成异步">将requests库转换成异步</h2>
<p>之前使用了多线程的方式将requests库转换成异步等待，但是由于线程开销较高，且本质上还是在空等，所以使用协程来实现异步等待会更好。</p>
<h3 id="gevent库">gevent库</h3>
<p>gevent库是一个网络库，它比asyncio标准库还要快一点。而且可以将同步函数直接转换成协程函数(其内置了loop)。</p>
<h4 id="猴子补丁">猴子补丁</h4>
<p>它主要使用的方式就是<strong>猴子补丁</strong>，原理大致如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> liba</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> libb <span class="keyword">as</span> liba</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样liba就被替换成了libb了，只要libb在接口上保证和liba的接口一致，那么就可以直接替换。</p>
<p>猴子补丁就是实现上述过程的东西。下面是猴子补丁使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="built_in">print</span>(socket.socket)   <span class="comment"># &lt;class 'socket.socket'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_socket() <span class="comment"># monkey.patch_all()是把所有库打上补丁</span></span><br><span class="line"><span class="built_in">print</span>(socket.socket)   <span class="comment"># &lt;class 'gevent._socket3.socket'&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就是<code>gevent</code>底层是<code>libev</code>，它从其之上再造了一个<code>socket</code>模块，具有跟标准库<code>socket</code>兼容的接口，而<code>gevent</code>中的<code>socket</code>是运行在<code>event loop</code>中的(标准库的socket不带)。</p>
<p>这样打完补丁后，socket库就是协程实现的了。</p>
<p>而requests基于urllib3,
urllib3基于socket，补丁是对socket的封装，所以requests库此时也成为协程异步的了。</p>
<h4 id="api">API</h4>
<p>下面有一些gevent常用的API</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建一个普通的Greenlet对象并启动</span></span><br><span class="line">gevent.spawn()</span><br><span class="line"><span class="comment"># 延时创建一个普通的Greenlet对象并启动</span></span><br><span class="line">gevent.spawn_later(seconds=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 创建的协程对象属于一个组</span></span><br><span class="line">gevent.spawn_raw()</span><br><span class="line"><span class="comment"># 返回当前正在执行的greenlet</span></span><br><span class="line">gevent.getcurrent()</span><br><span class="line"><span class="comment"># 将协程任务添加到事件循环，接收一个任务列表</span></span><br><span class="line">gevent.joinall(jobs)</span><br><span class="line"><span class="comment"># 可以替代join函数等待循环结束，也可以传入协程对象列表</span></span><br><span class="line">gevent.wait()</span><br><span class="line"><span class="comment"># 杀死一个协程</span></span><br><span class="line">gevent.kill()</span><br><span class="line"><span class="comment"># 杀死一个协程列表里的所有协程</span></span><br><span class="line">gevent.killall()</span><br><span class="line"><span class="comment"># 会自动将python的一些标准模块替换成gevent框架</span></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>使用<code>gevent.spawn()</code>创建了一个协程会自动执行，如果想要获取该协程的结果最好先<code>gevent.join()</code></strong></p>
<p>另外，<code>gevent</code>本身也是基于<code>greenlet</code>的，所以也可以使用<code>greenlet</code>对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Greenlet对象</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Greenlet</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Greenlet对象创建</span></span><br><span class="line">job = Greenlet(target0, <span class="number">3</span>)</span><br><span class="line">Greenlet.spawn() <span class="comment"># 创建一个协程并启动</span></span><br><span class="line">Greenlet.spawn_later(seconds=<span class="number">3</span>) <span class="comment"># 延时启动</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 协程启动</span></span><br><span class="line">job.start() <span class="comment"># 将协程加入循环并启动协程</span></span><br><span class="line">job.start_later(<span class="number">3</span>) <span class="comment"># 延时启动</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 等待任务完成</span></span><br><span class="line">job.join() <span class="comment"># 等待任务完成</span></span><br><span class="line">job.get() <span class="comment"># 获取协程返回的值</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 任务中断和判断任务状态</span></span><br><span class="line">job.dead() <span class="comment"># 判断协程是否死亡</span></span><br><span class="line">job.kill() <span class="comment"># 杀死正在运行的协程并唤醒其他的协程，这个协程将不会再执行，可以</span></span><br><span class="line">job.ready() <span class="comment"># 任务完成返回一个真值</span></span><br><span class="line">job.successful() <span class="comment"># 任务成功完成返回真值，否则抛出错误</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取属性</span></span><br><span class="line">job.loop <span class="comment"># 时间循环对象</span></span><br><span class="line">job.value <span class="comment"># 获取返回的值</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 捕捉异常</span></span><br><span class="line">job.exception <span class="comment"># 如果运行有错误，获取它</span></span><br><span class="line">job.exc_info <span class="comment"># 错误的详细信息</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置回调函数</span></span><br><span class="line">job.rawlink(back) <span class="comment"># 普通回调，将job对象作为回调函数的参数</span></span><br><span class="line">job.unlink() <span class="comment"># 删除回调函数</span></span><br><span class="line"><span class="comment"># 执行成功的回调函数</span></span><br><span class="line">job.link_value(back)</span><br><span class="line"><span class="comment"># 执行失败的回调函数</span></span><br><span class="line">job.link_exception(back)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，与线程类似，协程也存在协程池。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 等待直到有一个协程有结果</span></span><br><span class="line">pool.wait_available()</span><br><span class="line"><span class="comment"># 向进程池添加一个方法并跟踪，非阻塞</span></span><br><span class="line">pool.dd(greenlet)</span><br><span class="line"><span class="comment"># 停止跟踪某个协程</span></span><br><span class="line">pool.discard(greenlet)</span><br><span class="line"><span class="comment"># 加入并启动协程</span></span><br><span class="line">pool.start(greenlet)</span><br><span class="line"><span class="comment"># 阻塞等待结束</span></span><br><span class="line">pool.join()</span><br><span class="line"><span class="comment"># 杀死所有跟踪的协程</span></span><br><span class="line">pool.kill()</span><br><span class="line"><span class="comment"># 杀死一个协程</span></span><br><span class="line">pool.killone(greenlet)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>协程池启动一个协程时，也是非阻塞的。</p>
<h3 id="异步requests">异步requests</h3>
<p>使用requests库时，先创建协程对象，然后使用<code>gevent.joinall()</code>来等待所有协程对象完成。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">url,i</span>):</span><br><span class="line">    data = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"<span class="subst">{i}</span> done"</span>)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">url_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># 创建协程对象</span></span><br><span class="line">    url_list.append(gevent.spawn(f, <span class="string">'https://www.baidu.com/'</span>,i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直到所有协程对象完成为止</span></span><br><span class="line">gevent.joinall(url_list)</span><br><span class="line"><span class="built_in">print</span>(time.time() - start)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="使用装饰器来创建协程函数">使用装饰器来创建协程函数</h4>
<p>当然使用一个装饰器来隐式的完成创建协程对象会更方便</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey, pool, Greenlet</span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">p = pool.Pool(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用协程池来运行协程的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">async_d</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">warp_</span>(<span class="params">*args,**kargs</span>):</span><br><span class="line">        p.start(Greenlet(func, *args, **kargs))</span><br><span class="line">    <span class="keyword">return</span> warp_</span><br><span class="line"></span><br><span class="line"><span class="meta">@async_d</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">url,i</span>):</span><br><span class="line">    data = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"<span class="subst">{i}</span> done"</span>)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    f(<span class="string">'https://www.baidu.com/'</span>,i)</span><br><span class="line">p.join()</span><br><span class="line"><span class="built_in">print</span>(time.time() - start)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python异步</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次当乙方的经历</title>
    <url>/2022/11/04/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BD%93%E4%B9%99%E6%96%B9%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h2 id="给阳光电源提供噪声过滤的接口及实现的经历">给阳光电源提供噪声过滤的接口及实现的经历</h2>
<span id="more"></span>
<p>我导接到了一个来自阳光电源的企业横向项目。我正好负责其中的关于传统图像处理的部分，涉及到图像分割分类和对掩模噪声过滤这两部分。几次会议交流下来，掩模噪声过滤这部分已经基本实现，达到了企业的要求，于是企业方要我提供对应的接口与实现以便后续部署在他们的服务器上。然后，这段奇妙的经历正式开始...</p>
<h3 id="x0-前言----一念之差埋下的祸根">0x0
前言----一念之差埋下的祸根</h3>
<p>整个任务的流程大致是SIFT+聚类+匹配(实际上复杂得多得多，这里只列出每个子流程中最重要的一个环节)。</p>
<p>在某一阶段的任务完成后，我发现代码如果全用python实现的话，里面有不少for循环，而python的for循环又是出了名的慢。所以想着闲着也是闲着<strong>，不如把这些完全基于OpenCV的python代码拿C++重构了</strong>(看来是真的闲)。殊不知，一个大坑就在这次重构中被埋下了...</p>
<p>重构后的代码果然快了很多(提升3倍左右，opencv-python本身也是调的C++库代码，主要优化的部分是函数调用开销和庞大的for循环)。<strong>但是，代价是：项目使用了python和C++两种语言，且两者之间是强耦合</strong>。</p>
<h3 id="x1-伊始----逐步离谱的开发过程">0x1
伊始----逐步离谱的开发过程</h3>
<p>当我真正领到要把之前的所有代码整理成可用的库并提供简单的接口这项任务的时候，其实我还是比较懵逼的。</p>
<p>因为他们的意思感觉就是打算直接把我写的库改叭改叭就直接部署在服务器上了(起码我当时是这么认为的)。这着实让我有点惊慌：</p>
<ul>
<li>一是我担心我的代码出问题，而且一般公司应该都有一些代码规范啥的，我写的肯定不符合他们的规范(废话，我甚至连他们公司的代码规范都没读过)，他们肯定也不太会做code
review之类的</li>
<li>二是，我之前开发的代码都是一些原型代码，不涉及日志记录、强大的异常处理还有错误恢复等等鲁棒性措施(如果他们打算加进去又得code
review，而code review又会遇到我的代码不合规范的问题)。</li>
</ul>
<p>还有一点，他们给的deadline还是相对比较紧的。我写的代码在本地环境能跑，但是想要打包成一个对于不同架构下开箱即用的库，难度还是比较大的。(更何况是代码涉及到python和C++两种语言)。</p>
<p>但无论如何，都得继续进行下去。为了增强代码的可读性，我<strong>还得对python那部分代码进行重构</strong>(主要是任务是随着每次会议进行逐步增加，就慢慢变成衣驼使了...)</p>
<h3 id="x2-挣扎----在坑里陷得越来越深">0x2
挣扎----在坑里陷得越来越深</h3>
<p>当我从重构深渊中爬出来的时候，我需要真正开始思考<strong>如何提供一个能够在不同系统上开箱即用的库了</strong>。</p>
<p>其实关于python代码那部分不太考虑太多，python跨平台性能还是很强的。<strong>按照道理来说确实是这样</strong>，但是，他们公司有的图片实在是太大了，超过了OpnCV的像素限制大小，所以需要在OpenCV的源码中把限制像素大小的那几个断言注释掉，不然是没法用的。<strong>所以，如果想要不出问题地运行python代码，就必须需要从源码编译OpenCV的python库...</strong></p>
<p>然后是C++那部分代码，其实C++的跨平台也不错，<strong>只需要有对应平台的动态链接库</strong>，然后我们到时候一链接就OK啦。但是，还是一样的问题，直接下载下来的OpenCV链接库会出现超出像素限制的错误，<strong>所以还是得从头编译OpenCV库</strong>。</p>
<p>另外，因为服务器是linux系统，所以如果想要编译出该系统下的库，只需要找一台对应系统的服务器，或者...<strong>交叉编译</strong>。</p>
<p>幸好实验室里有一台linux服务器，只需要...等等，<strong>前两天这台服务器跑深度学习给烧了</strong>。没事，维修师傅应该很快就能修...等等，<strong>现在因为疫情封校，外来人员根本进不来</strong>！</p>
<p>寄！看来只能老老实实去交叉编译了</p>
<h3 id="x3-转机----要从坑里出去啦">0x3 转机----要从坑里出去啦？</h3>
<p>这时候我突然想到，之前从Github Student
Package里领过DigitalOcean的200美元金额，正好可以开一个服务器，然后当作编译服务器来用。</p>
<p>然后理所当然的就开了一个2C2G的服务器，而且由于服务器本身在墙外，拉github代码、下载依赖啥的都很快。当我配置好CMAKE选项，敲下令人很有安全感的<code>make -j2</code>后，一阵心情愉悦。</p>
<p>但是没过多久，我发现如果服务器的内存不够，opencv没法编译出python的库。但是又懒得换一台再走一套这个流程了，所以就干脆先不编译python的库，
只编译出c++的库。</p>
<p>就这样，总算是勉强弄出了C++的依赖库。然后就是要把这些库链接进我写的C++代码编译成的库中。</p>
<p>至于python，我是这样想的，因为他们既然能生成那种超大张的图像，所以他们的opencv-python肯定是魔改过的，我只要保证我的c++代码这里链接的库不出问题就可以了。</p>
<h3 id="x4-折磨----重复编译的地狱与初见曙光">0x4
折磨----重复编译的地狱与初见曙光</h3>
<p>由于涉及到在python中调用C++的库函数，关于这个问题，其实我之前没有搞过。我之前只是接触过Cython和一些C扩展的写法，但是C扩展也太难写了，所以后面没有深入。</p>
<p>后面经过一番搜索才知道可以使用ctypes这个包，但是具体怎么用还是不很清楚。考虑到那部分C++代码是以类的方式呈现的，所以我又为它搞了个包装函数(因为我只搜到了ctypes调用函数的方式，不清楚能不能调用类)。</p>
<p>但是调用的时候老是出错，我一度怀疑是搜出来的资料有问题还是我本身代码写的有问题，反复编译了好几次。</p>
<p>最终好不容易才摸清楚正确的调用方式。<strong>为了能调用c++库函数，我为这部分又写了一个适配器；为了让接口更加优雅，我又为适配器写了一个包装函数</strong>...</p>
<p>但不管怎么说，这一堆代码总算是能正确的跑起来了。</p>
<h3 id="x5-结束----但是似乎并不令人满意">0x5
结束----但是似乎并不令人满意</h3>
<p>总算是能够给出一套能用的库了，在服务器上测试了一下，运行的还不错。于是写了个文档和example程序，加上一点注释，把所有默认配置项全部引出组织成文件。接下来，就可以给公司人员测试了。</p>
<p>但是，我忘了我所有编译的都是动态链接库(<strong>这确实是我的失误，应该把OpenCV编译成静态库，把我的代码编译成动态库</strong>)，所以公司他们还需要重头编译...相当于我之前的一些工作都白干了...</p>
<p>而且他们之前还要我测试一下部分结构的改进效果，我还给忘了...</p>
<h3 id="x6-后记">0x6 后记</h3>
<p>这次经历还是很有意思的(虽然写出来之后可能没有读出来，这种事还是要经历才能有感知)，所以打算记录下来。</p>
<p>顺带一提，阳光电源和我交接工作的还是我们学校的学长，人非常好，之前还打电话问我要不要去他们公司实习，但是考虑到目前刚刚大三，而且这里疫情很重，所以就没去。</p>
]]></content>
      <categories>
        <category>奇趣记事</category>
      </categories>
      <tags>
        <tag>记事杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>记风火轮MIQI-RK3288开发板的踩坑过程</title>
    <url>/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="记风火轮miqi-rk3288开发板的踩坑过程">记风火轮MIQI-RK3288开发板的踩坑过程</h2>
<span id="more"></span>
<p>之前从某鱼上看到了价格比较合适的一块RK3288开发板，就顺便买下来了。记录一下烧录镜像过程中的踩坑记录。</p>
<img src="/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/pic1.jpg" class="">
<p>我买的就是上面这块板子，配置还是很不错的：RK3288四核处理器、2G
DDR3、16G
eMMC、4个USB2.0、HDMI、千兆网口、还有串口调试和一大票的GPIO。无论是当作家用服务器还是当超高配单片机或者是学习内核驱动开发感觉都不错，而且价格也比较便宜，这价格也不需要啥自行车。比我之前用的opi
PC2这种小水管强多了(其实我就跑跑bot挂个下载器，偶尔当作vsc的远程环境来用，PC2完全是够了)。(<strong>其实PC2的电源设计是有问题的，当CPU高频工作时会跑飞，也许增加电容可以改善这种情况</strong>)</p>
<img src="/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/pic3.jpg" class="">
<p>上面这个就是我目前的小水管服务器。</p>
<h3 id="镜像烧录">镜像烧录</h3>
<p>这块板子到手后我上电发现是Android的系统，而我是要做一个小服务器的，所以我要做的第一步就是烧录一个linux的系统上去。</p>
<p>由于这块板子自带了eMMC，所以不需要额外的内存卡用于烧写镜像，而是需要特殊的工具来完成烧写。</p>
<div class="note primary">
            <p>有一说一，这款产品的网站做的是真垃圾捏。存的资料都是伯度网盘，好多资料都失效了；而且官方也没有详细的教程；wiki页面还全是英文的，里面的图还全都废了，真就不要国内用户了呗。</p><p>这个是<a href="http://wiki.smartfire.cn/%E9%A6%96%E9%A1%B5"><font color="#0000ff"><u>板子的页面</u></font></a>，可以感受一下。</p>
          </div>
<p>首先，我们需要<a href="https://www.t-firefly.com/doc/download/4.html">下载瑞芯微提供的烧录工具和驱动</a>(RK3288就是瑞芯微的)。我们需要烧录到eMMC中，所以下载AndroidTools和对应的驱动并安装(现在这俩东西叫RKDevTool和RK驱动助手)。</p>
<img src="/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/pic2.png" class="">
<p>然后还需要下载我们需要的镜像。可以在<a href="https://pan.baidu.com/s/1qG8kNPaH1uARfxas7_CPvA">这里下载(提取码：4m0o)</a>，镜像在firmwares文件夹里。不过似乎<a href="https://www.t-firefly.com/doc/download/4.html">这里</a>的也能用，后面的镜像更新，所以推荐去这里下。但是这个官网的下载速度和伯度网盘差不多，我以我就找个小的下，我选了RK3288_Server_Ubuntu这个镜像，毕竟平时我也是需要关闭掉图形化显示的，所以不如干脆选一个不带图形化的界面的版本。</p>
<p>烧录前先把之前说的驱动装好，然后摁住板子后面的唯一一个按键不松手，把板子和电脑相连后等待几秒再松开那个按键，这样就进入了LOADER模式。打开那个AndroidTools，然后在升级固件的窗口中选择固件，然后点击烧录就完成了。</p>
<img src="/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/pic4.png" class="">
<p>然后断电再重新上电，随便找个显示器装上，就能看到成功启动了。不过由于我们没有装图形化显示界面，所以全是黑框框。<strong>以及这个默认的账号和密码都是firefly，它官网说的都不对，不过这种一般都是拿自己的公司来作为账号和密码，还是很好猜的</strong>。</p>
<img src="/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/pic5.jpg" class="">
<h3 id="配置网络">配置网络</h3>
<p>很显然我们不能每次使用这块板子就找来显示屏和鼠标键盘这种东西连上去，否则就显得太蠢了。</p>
<p>我们首先需要找个好地方来放板子，这个好地方需要满足以下条件：</p>
<ul>
<li>离路由器或者交换机近，可以提供网线直连。因为板子的USB是2.0，就不要接一个愚蠢的usb网卡了，而且作为一台服务器，使用无线传输方式来接入互联网真是太掉价了。</li>
<li>有足够的充电设备，因为后续扩展硬盘上去是需要额外供电设备的。</li>
<li>比较阴凉，虽然本身散热还行，但是最好还是找个阴凉的地方。</li>
</ul>
<p>我选择把这台小服务器扔在宿舍里，虽然在实验室里可能会更好(宿舍限电，说不定啥时候就崩了)，但是实验室的交换机离我有点远，要拉一根很长的网线才行。</p>
<p>配置网络的时候最好将其配置成局域网内的静态IP，而不要DHCP分配。因为前者在局域网内访问会很方便，而且我这个路由器又是捡垃圾捡来的，它那个地址续租好像有点问题(不是很确定，但是非静态地址过一段时间会断网)。</p>
<p>首先输入<code>ifconfig</code>查看网卡和当前ip地址，然后通过修改<code>/etc/network/interfaces</code>文件来修改网卡配置信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo vim /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是interfaces文件中的内容</span></span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.1.205</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就配置好了静态IP。</p>
<h3 id="配置frp内网穿透">配置frp内网穿透</h3>
<p>由于这台服务器位于内网，我们要访问它就需要和它连接在一个子网内，但是这很明显不方便。而为了能够在外网访问它，我们需要使用内网穿透工具，此处选用了frp。</p>
<p>使用frp时，要保证我们拥有一个公网ip，frp的配置分为客户端与服务器，客户端即为我们的板子，服务器是拥有公网ip的主机。</p>
<p>我们首先进入frp的<a href="https://github.com/fatedier/frp/releases">github页面</a>，下载我们需要的frp程序，注意，这个程序是同步需要在我们的板子和远程主机上下载并启动的，且需要对应架构。</p>
<h4 id="客户端配置">客户端配置</h4>
<p>由于我们的板子是32位arm架构的(你可以输入<code>arch</code>来查看架构)，所以我们需要下载arm版本的frp程序并解压。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_arm.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf frp_0.44.0_linux_arm.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> frp_0.44.0_linux_arm</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后开始配置frp客户端，我们先将ssh进行穿透。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vim frpc.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是配置文件内容</span></span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 127.0.0.1 <span class="comment"># 这个是服务器端的公网ip</span></span><br><span class="line">server_port = 7000 <span class="comment"># 这个是服务器端开放的端口，可以参见服务器端配置</span></span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后就可以输入<code>./frpc -c frpc.ini</code>启动一下看看效果，正常启动就没问题。</p>
<h4 id="服务器端配置">服务器端配置</h4>
<p>仅仅配置了客户端我们目前还是没有办法进行远程登录，还需要额外配置服务器端的frp程序。</p>
<p>我手上的这台服务器是<code>x86_64</code>架构的，所以我们需要下载对应架构的frp程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf frp_0.44.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> frp_0.44.0_linux_amd64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后类似的，我们也需要修改服务器端的配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vim frps.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是配置文件内容</span></span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000 <span class="comment"># 这个就是前面说的服务器端使用的ip地址</span></span><br><span class="line">dashboard_port = 7500 <span class="comment"># 这个是提供统计信息的界面，在浏览器中输入http://{服务器ip}:7500就能看到</span></span><br><span class="line">dashboard_user = admin <span class="comment"># 下面这俩是统计信息界面的账号密码，可以自己设置。</span></span><br><span class="line">dashboard_pwd = admin</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置完成后我们输入<code>./frps -c frps.ini</code>来启动服务器端程序看看运行结果，正常运行就是ok的。</p>
<p>最后注意需要在云服务器中的安全组里打开防火墙不然可能无法连接。</p>
<h4 id="自启动与后台执行">自启动与后台执行</h4>
<p>但是这样的话就会出现几个问题:</p>
<ul>
<li>板子每次重启都需要在内网内启动frpc程序</li>
<li>远程服务器的ssh不能断开，否则frps程序会随着ssh断开而关闭</li>
</ul>
<p>我们先来解决第二个问题，因为可以通过screen来快速解决。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">screen -S frps <span class="comment"># 先创建一个screen窗口</span></span><br><span class="line">./frps -c frps.ini <span class="comment"># 在窗口内执行</span></span><br><span class="line"></span><br><span class="line">CTRL^A D <span class="comment"># 按下ctrl^a 再按下d，此时这个窗口连同执行的程序就会进入后台。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们想重新连入这个窗口可以输入<code>screen -r frp</code>，这样可以很方便的查看日志，彻底关闭这个窗口可以按下ctrl^a
再按下k。</p>
<p>对于第一个问题，我们的解决方法是写一个bash脚本然后每次开机都自启动这个脚本。</p>
<p>我们先写一个我们需要被自启动的脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vim start.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是脚本内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/local/frp_0.39.1_linux_arm64</span><br><span class="line"><span class="built_in">nohup</span> ./frpc -c frpc.ini &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们编辑<code>/etc/rc.local</code>，如果没有这个文件可以参考<a href="https://www.linuxprobe.com/linux-rc-local.html">这里</a>。然后把我们的启动脚本添加进去。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo vim /etc/rc.local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是添加的内容 在exit 0之前</span></span><br><span class="line"></span><br><span class="line">bash /usr/local/start.sh &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就完成了。</p>
]]></content>
      <categories>
        <category>工具杂谈</category>
      </categories>
      <tags>
        <tag>开发板使用</tag>
        <tag>RK3288</tag>
      </tags>
  </entry>
  <entry>
    <title>通过python的反射机制来动态创建含参数的对象</title>
    <url>/2023/03/05/%E9%80%9A%E8%BF%87python%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%9D%A5%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%90%AB%E5%8F%82%E6%95%B0%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><strong>通过python的反射机制来动态创建含参数的对象</strong></p>
<span id="more"></span>
<h2 id="反射机制">反射机制</h2>
<p>反射机制其实就是通过字符串来获取对象的属性或者方法，或者通过字符串来创建对象。</p>
<p>举个例子，我们有一个类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">"A"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们为其成员<code>name</code>赋值的时候是使用<code>self.name = XXX</code>的形式来实现。如果我们想要通过字符串来实现这个功能，那么就可以使用反射机制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">setattr</span>(self, <span class="string">"name"</span>, <span class="string">"A"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">getattr</span>(self, <span class="string">"name"</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两种写法是一样的，第二种写法是基于反射来完成的，这样就可以动态创建属性，但是IDE无法补全。</p>
<div class="note info">
            <p><code>eval</code>函数也能做到反射，但是安全性太差</p>
          </div>
<h3 id="反射机制动态创建类">反射机制动态创建类</h3>
<p>反射机制最大的作用就是<strong>动态创建</strong>，下面以我目前遇到的一个情况为例，来阐述一下我对反射机制的应用的理解。</p>
<p>我目前正在写一个使用图像隐写技术来调制解调信息的项目，调制和解调制需要使用到编码器，如图。</p>
<img src="/2023/03/05/%E9%80%9A%E8%BF%87python%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%9D%A5%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%90%AB%E5%8F%82%E6%95%B0%E7%9A%84%E5%AF%B9%E8%B1%A1/pic1.png" class="">
<p>编码器和解码器是一一对应的，编码器会将编码器本身信息和要传输的信息一起编码，<strong>因此解码器需要根据编码信息来动态创建</strong>。并且由于项目本身性质，要求存储的编码器信息尽可能少(因此不能用pickle，更何况它本身也不安全)。</p>
<p>我想到的方案是这样的：假设需要用的解码器是<code>moudleA</code>中的类<code>decoderA</code>，创建<code>decoderA</code>的参数为<code>*args</code>，<strong>那么编码器就把<code>moudleA</code>和<code>decoderA</code>的名字以及<code>*args</code>存储到调制信息中，解码器在解码时，根据这些信息动态创建<code>decoderA</code>。</strong></p>
<p>这些解码后的信息都是字符串，因此需要使用反射。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">globals</span>()[<span class="string">"A"</span>]()</span><br><span class="line"><span class="built_in">print</span>(a.name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就实现了动态创建类。</p>
<h2 id="动态创建含参数的类">动态创建含参数的类</h2>
<p>但是这样远远不够，因为解码器不能能不传递参数。这时候就需要使用<code>getattr</code>和<code>setattr</code>来实现。</p>
<p>但是还有一个问题，<strong>因为解码后的信息都是<code>str</code>类型</strong>，所以类的构造函数只能接收<code>str</code>类型的参数，构造函数需要自己去处理这些参数。</p>
<p>但是如果一个类需要正确处理所有的<code>str</code>参数会导致代码很难维护，所以最好使用一个包装函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">A</span>(<span class="params">x:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="comment"># 为了防止注入，最好对A做参数检查</span></span><br><span class="line">    <span class="keyword">return</span> _A(<span class="string">f'x=int(<span class="subst">{x}</span>)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, args: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># create 用于记录创建时的参数</span></span><br><span class="line">        self.create = args</span><br><span class="line">        <span class="comment"># 把空格去掉，然后分割成一个个“key=value”的形式</span></span><br><span class="line">        args = [arg <span class="keyword">for</span> arg <span class="keyword">in</span> args.replace(<span class="string">" "</span>, <span class="string">""</span>).split(<span class="string">','</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通过setattr来动态创建属性</span></span><br><span class="line">        <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">            <span class="built_in">setattr</span>(self, arg.split(<span class="string">'='</span>)[<span class="number">0</span>], <span class="built_in">eval</span>(arg.split(<span class="string">'='</span>)[<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样通过<code>A(10)</code>时就会调用<code>_A("x=int(10)")</code>来返回一个对象。</p>
<p>而在<code>_A()</code>中，会先把这条创建参数存储下来，然后把参数分割成一个个<code>key=value</code>的形式，然后通过<code>setattr</code>来动态创建属性。</p>
<p>如果A本身就是一个编码解码器，并且把创建A的参数一起调制，那么在解码的时候就能正确创建出A类用于解码。</p>
<h3 id="使得ide能够补全">使得IDE能够补全</h3>
<p>由于上述代码都是通过动态创建属性的，所以IDE无法补全，所以需要显示指定出参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">A</span>(<span class="params">x:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="comment"># 为了防止注入，最好对A做参数检查</span></span><br><span class="line">    <span class="keyword">return</span> _A(<span class="string">f'x=int(<span class="subst">{x}</span>)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, args: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># IDE补全可用</span></span><br><span class="line">        self.x: <span class="built_in">int</span> = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># create 用于记录创建时的参数</span></span><br><span class="line">        self.create = args</span><br><span class="line">        <span class="comment"># 把空格去掉，然后分割成一个个“key=value”的形式</span></span><br><span class="line">        args = [arg <span class="keyword">for</span> arg <span class="keyword">in</span> args.replace(<span class="string">" "</span>, <span class="string">""</span>).split(<span class="string">','</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通过setattr来动态创建属性</span></span><br><span class="line">        <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">            <span class="built_in">setattr</span>(self, arg.split(<span class="string">'='</span>)[<span class="number">0</span>], <span class="built_in">eval</span>(arg.split(<span class="string">'='</span>)[<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面给出一个完整的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">A</span>(<span class="params">kernel: <span class="built_in">int</span> = <span class="number">2</span></span>):</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    创建A类</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">return</span> _A(<span class="string">f'kernel=int(<span class="subst">{kernel}</span>)'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_A</span>():</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    A类需要自己解析参数并动态创建</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, args: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 保证IDE工作</span></span><br><span class="line">        self.kernel: <span class="built_in">int</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 动态创建参数</span></span><br><span class="line">        self.create = args</span><br><span class="line">        args = [arg <span class="keyword">for</span> arg <span class="keyword">in</span> args.replace(<span class="string">" "</span>, <span class="string">""</span>).split(<span class="string">','</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">            <span class="built_in">setattr</span>(self, arg.split(<span class="string">'='</span>)[<span class="number">0</span>], <span class="built_in">eval</span>(arg.split(<span class="string">'='</span>)[<span class="number">1</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_create</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_cls</span>(<span class="params">package: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">                 class_name: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">                 args: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    利用类名和参数来动态创建类</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">__import__</span>(package, fromlist=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">globals</span>()[class_name](args)</span><br><span class="line"></span><br><span class="line">a = A(<span class="number">10</span>)</span><br><span class="line">b = generate_cls(a.__class__.__module__,a.__class__.__name__,a.create)</span><br><span class="line"><span class="built_in">print</span>(b.kernel)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样把<code>a.__class__.__module__</code>、<code>a.__class__.__name__</code>和<code>a.create</code>存储起来，就可以在解码时动态创建出<code>a</code>了。</p>
]]></content>
      <categories>
        <category>python技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Webbench源码剖析</title>
    <url>/2022/09/01/Webbench%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h2 id="webbench源码剖析">Webbench源码剖析</h2>
<span id="more"></span>
<p><a href="https://github.com/EZLippi/WebBench">项目地址</a></p>
<h3 id="webbench介绍">Webbench介绍</h3>
<div class="note primary">
            <p>Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。</p><p>而其源码也相当的短，只有500行，读起来非常容易。</p>
          </div>
<p>不过本项目虽然代码量很小，但是最好熟悉unix网络编程，以及linux下C语言多线程的实现(fork()函数)，否则可能看起来会比较吃力。</p>
<p>我们将代码拉下来后，可以发现，其只包含两个文件，我们首先分析代码行数较少的<code>socket.c</code>文件。</p>
<h3 id="socket.c源码剖析">socket.c源码剖析</h3>
<h4 id="文件说明">文件说明</h4>
<p>这个<code>socket.c</code>文件里仅有一个函数<code>int Socket(const char *host, int clientPort)</code>，这是对socket的一层封装，可以解析以字符串传入的<code>url地址</code>和<code>端口</code>，并返回一个指向服务器的socket套接字用于连接。</p>
<h4 id="函数工作流程">函数工作流程</h4>
<div class="note primary">
            <ol type="1"><li><p>首先准备好必须的参数并对其进行初始化。</p></li><li><p>先将主机名转换成ip并存储（包括本身就是ip的主机和通过dns解析主机两部分）</p></li><li><p>根据主机IP和端口创建socket套接字</p></li><li><p>执行一次连接，如果连接成功就返回这个套接字，否则返回错误码</p></li></ol>
          </div>
<h4 id="源码">源码</h4>
<p>这部分源码相对比较简单，主要懂一些linux下网络编程就不难看懂了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// host是目标主机名，clientPort为端口</span></span><br><span class="line"><span class="comment">// 建立与目标的TCP连接，返回客户端连接使用的套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Socket</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">int</span> clientPort)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock;              <span class="comment">// 本地套接字标识符</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> inaddr;  <span class="comment">// 主机ip的数字形式（32位）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ad</span>;</span> <span class="comment">// 处理网络通信套接字地址结构，存储地址族、套接字端口号、ip地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hp</span>;</span>    <span class="comment">// 存储了主机名、主机别名、ip及其类型、长度等，是gethostbyname返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ad, <span class="number">0</span>, <span class="keyword">sizeof</span>(ad)); <span class="comment">// 初始化套接字</span></span><br><span class="line">    ad.sin_family = AF_INET;    <span class="comment">// TCP/IP协议</span></span><br><span class="line"></span><br><span class="line">    inaddr = inet_addr(host); <span class="comment">// 先尝试将host转换成整型（不经过dns解析的ip形式主机）</span></span><br><span class="line">    <span class="keyword">if</span> (inaddr != INADDR_NONE)</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;ad.sin_addr, &amp;inaddr, <span class="keyword">sizeof</span>(inaddr)); <span class="comment">// 成功则保存转换结果</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 否则需要先经过dns解析</span></span><br><span class="line">        hp = gethostbyname(host); <span class="comment">// hp是存储解析结果的结构体</span></span><br><span class="line">        <span class="keyword">if</span> (hp == <span class="literal">NULL</span>)           <span class="comment">// 解析失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;ad.sin_addr, hp-&gt;h_addr, hp-&gt;h_length); <span class="comment">// 解析成功同样需要保存整型结构的IP地址</span></span><br><span class="line">    }</span><br><span class="line">    ad.sin_port = htons(clientPort); <span class="comment">// htons是将整型变量从主机字节顺序转变成网络字节顺序</span></span><br><span class="line"></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sock; <span class="comment">// 创建失败</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;ad, <span class="keyword">sizeof</span>(ad)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 创建成功但是不能连接成功也认为是失败</span></span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="webbench.c源码剖析">webbench.c源码剖析</h3>
<h4 id="文件说明-1">文件说明</h4>
<p>这个<code>webbench.c</code>文件是这个项目中最重要的文件，所有的处理操作都在这个文件中执行。</p>
<p>在这个文件头处可以看到可能令人疑惑的地方，在一行有一句<code>#include "socket.c"</code>，也就是把另一个.c文件给include进来了，但一般我们include都是.h文件。</p>
<p>其实在c语言中<code>#</code>开头的指令是预处理指令，我们知道，c语言进行编译的第一步就是预处理，而<code>include</code>指令就是把include后紧跟的文件原封不动的插入进来，而不做改变。而平时我们不这么做的原因就是当多个文件都include一个.c文件时，这个.c文件内的函数会被重定义。但这个项目就两个文件，所以不用考虑那么多。</p>
<div class="note info">
            <p><strong><em>关于预处理</em></strong></p><p>在linux环境下执行<code>gcc -E webbench.c &gt; result.txt</code>就能看到预处理结果，当然为了便于观察，可以把除了<code>#include "socket.c"</code>的所有其他头文件都注释掉。</p>
          </div>
<h4 id="源码-1">源码</h4>
<p>由于这个文件比较大，所以分函数来进行展示</p>
<p>先来看头文件部分和全局变量部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"socket.c"</span></span></span><br><span class="line"><span class="comment">// 这里include了一个.c文件可能会令人费解，但是理解C语言的编译过程就容易看懂了</span></span><br><span class="line"><span class="comment">// #include是一个预处理指令，在预处理过程中会用"socket.c"的内容来替换这个预处理</span></span><br><span class="line"><span class="comment">// 所以相当于完成了两个.c文件的拼接，等效于将"socket.c"直接写在这个文件前面</span></span><br><span class="line"><span class="comment">// 平时之所以不这样用是因为可能出现重定义的现象</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rpc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> timerexpired = <span class="number">0</span>; <span class="comment">// 计时器是否到期，到期为1，未到期为0</span></span><br><span class="line"><span class="type">int</span> speed = <span class="number">0</span>;                 <span class="comment">// 记录速度</span></span><br><span class="line"><span class="type">int</span> failed = <span class="number">0</span>;                <span class="comment">// 记录失败次数</span></span><br><span class="line"><span class="type">int</span> bytes = <span class="number">0</span>;                 <span class="comment">//记录传输的数据量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> http10 = <span class="number">1</span>; <span class="comment">// 0 - http/0.9, 1 - http/1.0, 2 - http/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了http的方法和全局配置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METHOD_GET 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METHOD_HEAD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METHOD_OPTIONS 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METHOD_TRACE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROGRAM_VERSION <span class="string">"1.5"</span></span></span><br><span class="line"><span class="type">int</span> method = METHOD_GET; <span class="comment">// 默认请求方法</span></span><br><span class="line"><span class="type">int</span> clients = <span class="number">1</span>;         <span class="comment">// 客户端连接数目</span></span><br><span class="line"><span class="type">int</span> force = <span class="number">0</span>;           <span class="comment">// 是否不等待服务器响应，发送请求后直接关闭连接</span></span><br><span class="line"><span class="type">int</span> force_reload = <span class="number">0</span>;    <span class="comment">// 是否强制代理服务器重新发送请求</span></span><br><span class="line"><span class="type">int</span> proxyport = <span class="number">80</span>;      <span class="comment">// 代理端口</span></span><br><span class="line"><span class="type">char</span> *proxyhost = <span class="literal">NULL</span>;  <span class="comment">// 代理地址</span></span><br><span class="line"><span class="type">int</span> benchtime = <span class="number">30</span>;      <span class="comment">// 持续时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络相关的变量</span></span><br><span class="line"><span class="type">int</span> mypipe[<span class="number">2</span>];              <span class="comment">// 读写管道，0为读取端，1为写入端</span></span><br><span class="line"><span class="type">char</span> host[MAXHOSTNAMELEN];  <span class="comment">// 保存主机的字符串</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_SIZE 2048   <span class="comment">// 请求的最大长度</span></span></span><br><span class="line"><span class="type">char</span> request[REQUEST_SIZE]; <span class="comment">// 请求内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态数组，用于记录各个选项的需要求参数</span></span><br><span class="line"><span class="comment">// no_argument表示选项没有参数，required_argument表示选项需要参数</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] =</span></span><br><span class="line">    {</span><br><span class="line">        {<span class="string">"force"</span>, no_argument, &amp;force, <span class="number">1</span>},</span><br><span class="line">        {<span class="string">"reload"</span>, no_argument, &amp;force_reload, <span class="number">1</span>},</span><br><span class="line">        {<span class="string">"time"</span>, required_argument, <span class="literal">NULL</span>, <span class="string">'t'</span>},</span><br><span class="line">        {<span class="string">"help"</span>, no_argument, <span class="literal">NULL</span>, <span class="string">'?'</span>},</span><br><span class="line">        {<span class="string">"http09"</span>, no_argument, <span class="literal">NULL</span>, <span class="string">'9'</span>},</span><br><span class="line">        {<span class="string">"http10"</span>, no_argument, <span class="literal">NULL</span>, <span class="string">'1'</span>},</span><br><span class="line">        {<span class="string">"http11"</span>, no_argument, <span class="literal">NULL</span>, <span class="string">'2'</span>},</span><br><span class="line">        {<span class="string">"get"</span>, no_argument, &amp;method, METHOD_GET},</span><br><span class="line">        {<span class="string">"head"</span>, no_argument, &amp;method, METHOD_HEAD},</span><br><span class="line">        {<span class="string">"options"</span>, no_argument, &amp;method, METHOD_OPTIONS},</span><br><span class="line">        {<span class="string">"trace"</span>, no_argument, &amp;method, METHOD_TRACE},</span><br><span class="line">        {<span class="string">"version"</span>, no_argument, <span class="literal">NULL</span>, <span class="string">'V'</span>},</span><br><span class="line">        {<span class="string">"proxy"</span>, required_argument, <span class="literal">NULL</span>, <span class="string">'p'</span>},</span><br><span class="line">        {<span class="string">"clients"</span>, required_argument, <span class="literal">NULL</span>, <span class="string">'c'</span>},</span><br><span class="line">        {<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>}};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prototypes */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">benchcore</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *request)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bench</span><span class="params">(<span class="type">void</span>)</span>;                     <span class="comment">// 执行压力测试的入口函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">build_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span>; <span class="comment">// 构造请求</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>前面这里就是定义了一些用到的宏和全局变量。</p>
<p>接下来我们来分析三个辅助函数，一个是用于设置定时器过期，一个用于显示帮助信息，另一个用于构造请求头。</p>
<p>其中，构造请求头的函数看起来稍微有些复杂，但是其实就是一些逻辑处理，然后根据http协议的定义手动构造出了请求体并保存在全局变量里面，这并不是我们分析的重点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 静态函数，用于信号处理，用于设置定时器过期</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alarm_handler</span><span class="params">(<span class="type">int</span> signal)</span></span><br><span class="line">{</span><br><span class="line">    timerexpired = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回帮助信息的函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// printf == fprintf(stdout, ...)</span></span><br><span class="line">    <span class="comment">// 不过fprintf的功能更强大，支持重定向</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">            <span class="string">"webbench [option]... URL\n"</span></span><br><span class="line">            <span class="string">"  -f|--force               Don't wait for reply from server.\n"</span></span><br><span class="line">            <span class="string">"  -r|--reload              Send reload request - Pragma: no-cache.\n"</span></span><br><span class="line">            <span class="string">"  -t|--time &lt;sec&gt;          Run benchmark for &lt;sec&gt; seconds. Default 30.\n"</span></span><br><span class="line">            <span class="string">"  -p|--proxy &lt;server:port&gt; Use proxy server for request.\n"</span></span><br><span class="line">            <span class="string">"  -c|--clients &lt;n&gt;         Run &lt;n&gt; HTTP clients at once. Default one.\n"</span></span><br><span class="line">            <span class="string">"  -9|--http09              Use HTTP/0.9 style requests.\n"</span></span><br><span class="line">            <span class="string">"  -1|--http10              Use HTTP/1.0 protocol.\n"</span></span><br><span class="line">            <span class="string">"  -2|--http11              Use HTTP/1.1 protocol.\n"</span></span><br><span class="line">            <span class="string">"  --get                    Use GET request method.\n"</span></span><br><span class="line">            <span class="string">"  --head                   Use HEAD request method.\n"</span></span><br><span class="line">            <span class="string">"  --options                Use OPTIONS request method.\n"</span></span><br><span class="line">            <span class="string">"  --trace                  Use TRACE request method.\n"</span></span><br><span class="line">            <span class="string">"  -?|-h|--help             This information.\n"</span></span><br><span class="line">            <span class="string">"  -V|--version             Display program version.\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造请求头的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">build_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    build_request的执行过程</span></span><br><span class="line"><span class="comment">    就是根据请求方式、http协议版本等等信息来构造处http的报文</span></span><br><span class="line"><span class="comment">    且这个报文是全局变量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先把保存主机的请求体部分的地址区域清空</span></span><br><span class="line">    <span class="built_in">memset</span>(host, <span class="number">0</span>, MAXHOSTNAMELEN);</span><br><span class="line">    <span class="built_in">memset</span>(request, <span class="number">0</span>, REQUEST_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后根据选项来判断请求的http协议版本</span></span><br><span class="line">    <span class="keyword">if</span> (force_reload &amp;&amp; proxyhost != <span class="literal">NULL</span> &amp;&amp; http10 &lt; <span class="number">1</span>)</span><br><span class="line">        http10 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (method == METHOD_HEAD &amp;&amp; http10 &lt; <span class="number">1</span>)</span><br><span class="line">        http10 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (method == METHOD_OPTIONS &amp;&amp; http10 &lt; <span class="number">2</span>)</span><br><span class="line">        http10 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (method == METHOD_TRACE &amp;&amp; http10 &lt; <span class="number">2</span>)</span><br><span class="line">        http10 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后开始正式构造请求体</span></span><br><span class="line">    <span class="comment">// 不过u1s1，这部分自己手动构造真是痛苦</span></span><br><span class="line">    <span class="keyword">switch</span> (method)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> METHOD_GET: <span class="comment">// get请求</span></span><br><span class="line">        <span class="built_in">strcpy</span>(request, <span class="string">"GET"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> METHOD_HEAD: <span class="comment">// head请求</span></span><br><span class="line">        <span class="built_in">strcpy</span>(request, <span class="string">"HEAD"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> METHOD_OPTIONS: <span class="comment">// options请求</span></span><br><span class="line">        <span class="built_in">strcpy</span>(request, <span class="string">"OPTIONS"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> METHOD_TRACE: <span class="comment">// trace请求</span></span><br><span class="line">        <span class="built_in">strcpy</span>(request, <span class="string">"TRACE"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(request, <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理url地址，做一些错误检测，而且不支持https</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">strstr</span>(url, <span class="string">"://"</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n%s: is not a valid URL.\n"</span>, url);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(url) &gt; <span class="number">1500</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"URL is too long.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != strncasecmp(<span class="string">"http://"</span>, url, <span class="number">7</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nOnly HTTP protocol is directly supported, set --proxy for others.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出url去掉协议头的部分</span></span><br><span class="line">    i = <span class="built_in">strstr</span>(url, <span class="string">"://"</span>) - url + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要求结尾以/来结尾，不知道为啥</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(url + i, <span class="string">'/'</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nInvalid URL syntax - hostname don't ends with '/'.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理使用代理的情况</span></span><br><span class="line">    <span class="keyword">if</span> (proxyhost == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 这种硬编码的东西看起来有点痛苦，就不考虑细节了</span></span><br><span class="line">        <span class="keyword">if</span> (index(url + i, <span class="string">':'</span>) != <span class="literal">NULL</span> &amp;&amp; index(url + i, <span class="string">':'</span>) &lt; index(url + i, <span class="string">'/'</span>))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">strncpy</span>(host, url + i, <span class="built_in">strchr</span>(url + i, <span class="string">':'</span>) - url - i);</span><br><span class="line">            <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">            <span class="built_in">strncpy</span>(tmp, index(url + i, <span class="string">':'</span>) + <span class="number">1</span>, <span class="built_in">strchr</span>(url + i, <span class="string">'/'</span>) - index(url + i, <span class="string">':'</span>) - <span class="number">1</span>);</span><br><span class="line">            proxyport = atoi(tmp);</span><br><span class="line">            <span class="keyword">if</span> (proxyport == <span class="number">0</span>)</span><br><span class="line">                proxyport = <span class="number">80</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">strncpy</span>(host, url + i, <span class="built_in">strcspn</span>(url + i, <span class="string">"/"</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">strcat</span>(request + <span class="built_in">strlen</span>(request), url + i + <span class="built_in">strcspn</span>(url + i, <span class="string">"/"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">strcat</span>(request, url);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (http10 == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request, <span class="string">" HTTP/1.0"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (http10 == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request, <span class="string">" HTTP/1.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(request, <span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (http10 &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request, <span class="string">"User-Agent: WebBench "</span> PROGRAM_VERSION <span class="string">"\r\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (proxyhost == <span class="literal">NULL</span> &amp;&amp; http10 &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">strcat</span>(request, <span class="string">"Host: "</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(request, host);</span><br><span class="line">        <span class="built_in">strcat</span>(request, <span class="string">"\r\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (force_reload &amp;&amp; proxyhost != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">strcat</span>(request, <span class="string">"Pragma: no-cache\r\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (http10 &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request, <span class="string">"Connection: close\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (http10 &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(request, <span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nRequest:\n%s\n"</span>, request);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们来进入main函数，main函数主要是解析选项，并构造url的请求头，然后调用bench函数来正式开始压力测试，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    main函数的处理过程就是先解析出所有的选项</span></span><br><span class="line"><span class="comment">    然后构造指向目标地址的url请求</span></span><br><span class="line"><span class="comment">    最后调用bench函数来执行压力测试</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">0</span>;           <span class="comment">// 用于记录当前标志（其实是char）</span></span><br><span class="line">    <span class="type">int</span> options_index = <span class="number">0</span>; <span class="comment">// 用于标记当前选项处理到的索引未知</span></span><br><span class="line">    <span class="type">char</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 若如果不带任何参数执行此程序就直接退出</span></span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则循环解析命令</span></span><br><span class="line">    <span class="comment">// getopt_long是解析命令的函数，此处不展开细🔒</span></span><br><span class="line">    <span class="comment">// 就是通过这个步骤来解析所有的选项</span></span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt_long(argc, argv, <span class="string">"912Vfrt:p:c:?h"</span>, long_options, &amp;options_index)) != EOF)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">            force = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">            force_reload = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'9'</span>:</span><br><span class="line">            http10 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">            http10 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">            http10 = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">            <span class="built_in">printf</span>(PROGRAM_VERSION <span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">            benchtime = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line">            <span class="comment">/* proxy server parsing server:port */</span></span><br><span class="line">            <span class="comment">// 由于代理是server:port的格式</span></span><br><span class="line">            <span class="comment">// 所以先查找处:的位置</span></span><br><span class="line">            <span class="comment">// strrchr就是查找并返回指向:字符的指针</span></span><br><span class="line">            tmp = <span class="built_in">strrchr</span>(optarg, <span class="string">':'</span>);</span><br><span class="line">            proxyhost = optarg;</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (tmp == optarg)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 没有主机，即字符串是:....的形式</span></span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in option --proxy %s: Missing hostname.\n"</span>, optarg);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (tmp == optarg + <span class="built_in">strlen</span>(optarg) - <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 没有端口，即字符串是...:的形式</span></span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in option --proxy %s Port number is missing.\n"</span>, optarg);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 由于tmp指向了冒号，所以把冒号置'\0'就完成了分割操作</span></span><br><span class="line">            *tmp = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="comment">// 然后获取端口号</span></span><br><span class="line">            proxyport = atoi(tmp + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">':'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">            usage();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">            <span class="comment">// atoi是把字符串转换成整型</span></span><br><span class="line">            clients = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optind == argc)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 最后一个被opt处理的选项与全部选项等长，就说明没有网址</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"webbench: Missing URL!\n"</span>);</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改默认的客户端数目与时间</span></span><br><span class="line">    <span class="keyword">if</span> (clients == <span class="number">0</span>)</span><br><span class="line">        clients = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (benchtime == <span class="number">0</span>)</span><br><span class="line">        benchtime = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copyright */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Webbench - Simple Web Benchmark "</span> PROGRAM_VERSION <span class="string">"\n"</span></span><br><span class="line">                    <span class="string">"Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造请求，存储在全局变量char request[REQUEST_SIZE]</span></span><br><span class="line">    <span class="comment">// optind指向下一个未处理的字符串的索引</span></span><br><span class="line">    <span class="comment">// 因此./webbench -c 5 -t 1 http://www.baidu.com/ wrong会被正常处理</span></span><br><span class="line">    <span class="comment">// 而./webbench -c 5 -t 1 wrong http://www.baidu.com/ 不会被正常处理</span></span><br><span class="line">    build_request(argv[optind]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Runing info: "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印连接日志，为毛要写成这个样子？？</span></span><br><span class="line">    <span class="keyword">if</span> (clients == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1 client"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d clients"</span>, clients);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">", running %d sec"</span>, benchtime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (force)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">", early socket close"</span>);</span><br><span class="line">    <span class="keyword">if</span> (proxyhost != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">", via proxy server %s:%d"</span>, proxyhost, proxyport);</span><br><span class="line">    <span class="keyword">if</span> (force_reload)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">", forcing reload"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">".\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用bench函数，开始压力测试，bench() 为压力测试核心代码</span></span><br><span class="line">    <span class="keyword">return</span> bench();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们分析用于作为测试入口的bench函数。</p>
<p>这个函数内是使用fork创建出子进程，同时分配管道用于主进程与子进程之间通信，最后还设定了主进程的逻辑为从管道中不断读取子进程的数据并汇总。</p>
<p>这里我们可以学到一点：<strong>所有需要处理的东西全部由子进程去做，主进程只负责汇总或打印报告之类的，这样处理的时候子进程崩了也不影响主进程</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 正式开始压力测试的入口函数，主要用于创建子进程、管道，以及主进程从管道中读取数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bench</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    FILE *f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个socket套接字</span></span><br><span class="line">    i = Socket(proxyhost == <span class="literal">NULL</span> ? host : proxyhost, proxyport);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nConnect to server failed. Aborting benchmark.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接，这次连接不计入测试</span></span><br><span class="line">    close(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建管道，mypipe也是全局变量</span></span><br><span class="line">    <span class="comment">// 管道用于两个进程之间数据交换</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(mypipe))</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"pipe failed."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fork出子进程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; clients; i++)</span><br><span class="line">    {</span><br><span class="line">        pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid &lt;= (<span class="type">pid_t</span>)<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 如果是子进程或者创建失败，休眠1s后退出循环，</span></span><br><span class="line">            <span class="comment">// 让父进程先执行，完成初始化（因为创建子进程是很快的）</span></span><br><span class="line">            <span class="comment">// 并且保证子进程中不会再fork出新的子进程</span></span><br><span class="line">            <span class="comment">// 子进程不fork出新的子进程，所以总的子进程数目就很好控制了</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主进程创建进程失败就退出</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; (<span class="type">pid_t</span>)<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"problems forking worker no. %d\n"</span>, i);</span><br><span class="line">        perror(<span class="string">"fork failed."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == (<span class="type">pid_t</span>)<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 子进程调用benchcore去尽可能发送请求</span></span><br><span class="line">        <span class="keyword">if</span> (proxyhost == <span class="literal">NULL</span>)</span><br><span class="line">            benchcore(host, proxyport, request);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            benchcore(proxyhost, proxyport, request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时写入管道</span></span><br><span class="line">        f = fdopen(mypipe[<span class="number">1</span>], <span class="string">"w"</span>);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            perror(<span class="string">"open pipe for writing failed."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入数据，来源于全局变量</span></span><br><span class="line">        <span class="built_in">fprintf</span>(f, <span class="string">"%d %d %d\n"</span>, speed, failed, bytes);</span><br><span class="line">        fclose(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 主进程读取管道</span></span><br><span class="line">        f = fdopen(mypipe[<span class="number">0</span>], <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            perror(<span class="string">"open pipe for reading failed."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义流 stream 应如何缓冲</span></span><br><span class="line">        <span class="comment">// 设置不使用缓冲。每个I/O操作都被即时写入管道</span></span><br><span class="line">        setvbuf(f, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化主进程的变量</span></span><br><span class="line">        speed = <span class="number">0</span>;</span><br><span class="line">        failed = <span class="number">0</span>;</span><br><span class="line">        bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 获取成功读取的参数个数</span></span><br><span class="line">            pid = <span class="built_in">fscanf</span>(f, <span class="string">"%d %d %d"</span>, &amp;i, &amp;j, &amp;k);</span><br><span class="line">            <span class="keyword">if</span> (pid &lt; <span class="number">2</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Some of our childrens died.\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            speed += i;</span><br><span class="line">            failed += j;</span><br><span class="line">            bytes += k;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 客户端数减一后如果等于0，说明没有多的客户端数据读取，直接退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (--clients == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        fclose(f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nSpeed=%d pages/min, %d bytes/sec.\nRequests: %d susceed, %d failed.\n"</span>,</span><br><span class="line">               (<span class="type">int</span>)((speed + failed) / (benchtime / <span class="number">60.0f</span>)),</span><br><span class="line">               (<span class="type">int</span>)(bytes / (<span class="type">float</span>)benchtime),</span><br><span class="line">               speed,</span><br><span class="line">               failed);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后是子进程发起请求的函数benchcore函数，这个函数其实逻辑也很简单，就是构造请求并发起，然后看看有没有错误，不过错误种类还挺多。</p>
<p>另外，这个函数还使用了信号量来作为定时器，这部分可以参考，即：<strong>在不影响程序执行的前提下进行定时</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 子进程发送请求的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">benchcore</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *req)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> rlen;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1500</span>];</span><br><span class="line">    <span class="type">int</span> s, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当程序执行到指定的秒数之后，发送SIGALRM信号，</span></span><br><span class="line">    <span class="comment">// 即设置alam_handler函数为信号处理函数</span></span><br><span class="line">    sa.sa_handler = alarm_handler;</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    alarm(benchtime); <span class="comment">// after benchtime,then exit</span></span><br><span class="line"></span><br><span class="line">    rlen = <span class="built_in">strlen</span>(req);</span><br><span class="line">nexttry:</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (timerexpired)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 定时器过期</span></span><br><span class="line">            <span class="comment">// 减去由于定时器过期引起的失败</span></span><br><span class="line">            <span class="keyword">if</span> (failed &gt; <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                failed--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        s = Socket(host, port);</span><br><span class="line">        <span class="comment">// 构造并发起请求失败</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt; <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            failed++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果请求报文写入套接字失败</span></span><br><span class="line">        <span class="keyword">if</span> (rlen != write(s, req, rlen))</span><br><span class="line">        {</span><br><span class="line">            failed++;</span><br><span class="line">            close(s);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果使用HTTP/0.9协议，因为会在服务器回复后自动断开连接，所以可以先关闭写端</span></span><br><span class="line">        <span class="comment">// 如果写端已经被关闭了，则说明异常连接</span></span><br><span class="line">        <span class="keyword">if</span> (http10 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (shutdown(s, <span class="number">1</span>))</span><br><span class="line">            {</span><br><span class="line">                failed++;</span><br><span class="line">                close(s);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">if</span> (force == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 读取服务器的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (timerexpired)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 将数据读取进buf中</span></span><br><span class="line">                i = read(s, buf, <span class="number">1500</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                {</span><br><span class="line">                    failed++;</span><br><span class="line">                    close(s);</span><br><span class="line">                    <span class="keyword">goto</span> nexttry;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 文件尾</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果读取到了数据，将总共传送的字节数加上读取到的数据的字节数</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    bytes += i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 关闭连接，如果失败，测试失败数加一，继续循环</span></span><br><span class="line">        <span class="keyword">if</span> (close(s))</span><br><span class="line">        {</span><br><span class="line">            failed++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        speed++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<div class="note primary">
            <p><strong>流程解析</strong></p><p><img src="/2022/09/01/Webbench%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic1.png" class="" title="_"></p>
          </div>
<div class="note primary">
            <h3 id="编程小技巧">编程小技巧</h3><ul><li><p>getopt_long() :其函数族成员有getopt、getopt_long、getopt_long_only，可以用来解析命令行参数，很实用。位于getopt.h，可以参阅<a href="https://blog.csdn.net/qq_33850438/article/details/80172275/"><font color="#0000ff"><strong>这篇文章</strong></font></a>来使用。</p></li><li><p>pipe() :管道是两个进程之间的连接，一个进程的标准输出成为另一个进程的标准输入。在UNIX操作系统中，管道用于进程间通信。可以参阅<a href="https://blog.51cto.com/u_15064646/3853841"><font color="#0000ff"><strong>这篇文章</strong></font></a>来使用。</p></li><li><p>fork() :用于创建出子进程，调用一次返回两次，子进程拥有父进程所有的打开的文件与变量。<strong>另外，在循环中使用fork会导致子进程继续fork，非常麻烦，为了计数方便可以让子进程在循环中break掉。</strong></p></li><li><p>fprintf() : printf() ==fprintf(stdout,...)这个函数功能更强大，支持重定向。</p></li><li><p>alarm() :alarm也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它向进程发送SIGALRM信号，可以设置对应的信号处理函数去处理这个信号。</p></li></ul>
          </div>
]]></content>
      <categories>
        <category>小型C语言项目源码剖析</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>小型C语言项目源码剖析</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(4)--levelDB的编码格式</title>
    <url>/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/</url>
    <content><![CDATA[<h2 id="leveldb的编码格式">levelDB的编码格式</h2>
<span id="more"></span>
<hr>
<h3 id="存储方式">存储方式</h3>
<p>当数据库获取到内存后，其需要将数据插入到内存中，并在适当的时候读取出来，如何高效地利用申请到的内存就是一个比较重要的问题。</p>
<div class="note info">
            <p>在levelDB中，数据是按照下列方法存储的：</p><ul><li><p>整数分为32位和64位定长整数</p></li><li><p>整数还使用变长整数存储</p></li><li><p>整数均为小端法存储</p></li><li><p>字符串采用长度前缀编码</p></li></ul>
          </div>
<h4 id="变长整数与定长整数">变长整数与定长整数</h4>
<p>所谓定长整数就是我们平时在C语言中定义的数据类型，其长度是始终不变的。</p>
<p>而变长整数则顾名思义，其编码的原理是只使用一个字节的低7位去存储数据，而最高位的用于做标识：当最高位为1时表示需要继续读取下一个字节。</p>
<img src="/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/pic1.jpg" class="">
<p>如上图所示，这样变长整数就可以使用1-5字节去表示int32的所有整数，表面上看，虽然表示非常大的整数的时候变长整数编码会占用更多的空间，但是由于大整数出现的频率一般是比较小的，所以就普遍而言，使用变长整数会节省更多的内存。</p>
<h4 id="字符串">字符串</h4>
<p>字符串使用长度前缀编码，即在把字符串的长度放在字符串的前面，然后组合起来编码。</p>
<p>而同时，字符串长度使用变长整数进行编码，所以一个字符串的存储格式是<code>32位变长整数编码字符串长度 + 字符串本身</code></p>
<p>使用长度前缀编码的方式，字符串能够编码任意字符(比如C语言不能在字符串中包含'\0')，同时，字符串的长度可以预先知道，所以有利于读写操作。另外，对于大部分字符串的长度都比较短的时候，并不会造成大量内存损失。</p>
<h3 id="源码解析部分">源码解析部分</h3>
<div class="note primary">
            <p>源码位置： <code>utils/coding.cc</code><code>utils/coding.h</code></p>
          </div>
<h4 id="头文件">头文件</h4>
<p>首先，我们先来看一下编码解码和插入数据的头文件，这部分内容很简单，就是处理编码格式的一些方法。</p>
<p>其中要注意用到了一个类<code>Slice</code>，这个类是对字符串的封装，比<code>std::string</code>封装更加低级，所以效率会更高，后面的文章会细🔒它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutFixed32</span><span class="params">(std::string *dst, <span class="type">uint32_t</span> value)</span></span>;                 <span class="comment">// 插入定长32位整数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutFixed64</span><span class="params">(std::string *dst, <span class="type">uint64_t</span> value)</span></span>;                 <span class="comment">//插入定长64位整数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutVarint32</span><span class="params">(std::string *dst, <span class="type">uint32_t</span> value)</span></span>;                <span class="comment">//插入变长32位整数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutVarint64</span><span class="params">(std::string *dst, <span class="type">uint64_t</span> value)</span></span>;                <span class="comment">//插入变长64位整数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutLengthPrefixedSlice</span><span class="params">(std::string *dst, <span class="type">const</span> Slice &amp;value)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetVarint32</span><span class="params">(Slice *input, <span class="type">uint32_t</span> *value)</span></span>;          <span class="comment">// 获取变长32位整数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetVarint64</span><span class="params">(Slice *input, <span class="type">uint64_t</span> *value)</span></span>;          <span class="comment">// 获取变长64位整数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetLengthPrefixedSlice</span><span class="params">(Slice *input, Slice *result)</span></span>; <span class="comment">// 获取字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于解码32/64位变长整数的函数，其中p是指向变长整数，limit是变长整数最大长度</span></span><br><span class="line"><span class="comment">// 而v存放的是解码后的值，如果不能解码则返回null</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">GetVarint32Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">const</span> <span class="type">char</span> *limit, <span class="type">uint32_t</span> *v)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">GetVarint64Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">const</span> <span class="type">char</span> *limit, <span class="type">uint64_t</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是上面GetVarint32Ptr函数的内部回调函数，是实际处理变长整数的东西</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">GetVarint32PtrFallback</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">const</span> <span class="type">char</span> *limit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">uint32_t</span> *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">VarintLength</span><span class="params">(<span class="type">uint64_t</span> v)</span></span>; <span class="comment">// 返回变长整数(32/64)的'长度'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">EncodeVarint32</span><span class="params">(<span class="type">char</span> *dst, <span class="type">uint32_t</span> value)</span></span>; <span class="comment">// 编码变长32位整数</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">EncodeVarint64</span><span class="params">(<span class="type">char</span> *dst, <span class="type">uint64_t</span> value)</span></span>; <span class="comment">// 编码变长64位整数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="type">char</span> *dst, <span class="type">uint32_t</span> value)</span></span>; <span class="comment">// 编码定长32位整数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">EncodeFixed64</span><span class="params">(<span class="type">char</span> *dst, <span class="type">uint64_t</span> value)</span></span>; <span class="comment">// 编码定长64位整数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">DecodeFixed32</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr)</span></span>;       <span class="comment">// 解码32位定长整数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint64_t</span> <span class="title">DecodeFixed64</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr)</span></span>;       <span class="comment">// 解码64位定长整数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>头文件只是给出了函数接口，下面我们就来进一步去分析各个函数。</p>
<h4 id="实现文件">实现文件</h4>
<p>为了方便分析，我们将其分成：编码解码定长整数、编码解码变长整数、Put和Get方法。</p>
<p>这部分代码全部围绕编码解码来实现的，其中定长的编解码很简单，就不在此赘述了。关于变长整数的编解码，其关于编码和解码的相关函数都预留了类似迭代器一样的超尾元素(指针)，这种形式的接口可以很方便的确定所处理数据的区间(变长整数的Put和Get相关函数都使用到了预留的超尾元素)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联函数本来是在头文件中的，但是此处将其当成一个函数来进行分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============编码解码定长整数=============*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码定长32位整数，实现思路就是类似结构体那样去分割uint32即可</span></span><br><span class="line"><span class="comment">// 但注意保证让dst有足够的空间去存储，否则会溢出或段错误</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="type">char</span> *dst, <span class="type">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// reinterpret_cast允许指针(引用)之间转换</span></span><br><span class="line">    <span class="comment">// 整型与指针类型间的转换以及指针与足够大的整型之间的转换</span></span><br><span class="line">    <span class="type">uint8_t</span> *<span class="type">const</span> buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span> *&gt;(dst);</span><br><span class="line"></span><br><span class="line">    buffer[<span class="number">0</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value);</span><br><span class="line">    buffer[<span class="number">1</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    buffer[<span class="number">2</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    buffer[<span class="number">3</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码定长64位整数，思路与编码定长32位整数一致</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">EncodeFixed64</span><span class="params">(<span class="type">char</span> *dst, <span class="type">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint8_t</span> *<span class="type">const</span> buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span> *&gt;(dst);</span><br><span class="line"></span><br><span class="line">    buffer[<span class="number">0</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value);</span><br><span class="line">    buffer[<span class="number">1</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    buffer[<span class="number">2</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    buffer[<span class="number">3</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    buffer[<span class="number">4</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    buffer[<span class="number">5</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">40</span>);</span><br><span class="line">    buffer[<span class="number">6</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">48</span>);</span><br><span class="line">    buffer[<span class="number">7</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">56</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码32位定长整数并返回，这同样不做边界检查</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">DecodeFixed32</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *<span class="type">const</span> buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span> *&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意是小端存储结构</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">0</span>])) |</span><br><span class="line">           (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">           (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">           (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码64位定长整数并返回，与上类似</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint64_t</span> <span class="title">DecodeFixed64</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *<span class="type">const</span> buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span> *&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buffer[<span class="number">0</span>])) |</span><br><span class="line">           (<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buffer[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">           (<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buffer[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">           (<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buffer[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">           (<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buffer[<span class="number">4</span>]) &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">           (<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buffer[<span class="number">5</span>]) &lt;&lt; <span class="number">40</span>) |</span><br><span class="line">           (<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buffer[<span class="number">6</span>]) &lt;&lt; <span class="number">48</span>) |</span><br><span class="line">           (<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(buffer[<span class="number">7</span>]) &lt;&lt; <span class="number">56</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============编码解码变长整数=============*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码32位变长整数</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">EncodeVarint32</span><span class="params">(<span class="type">char</span> *dst, <span class="type">uint32_t</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 这一部分的编码就是完全按照定义来的，用了5个if</span></span><br><span class="line">    <span class="comment">// 分别对应了1-5个字节范围内的长度</span></span><br><span class="line">    <span class="type">uint8_t</span> *ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span> *&gt;(dst);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">128</span>;</span><br><span class="line">    <span class="comment">/* 仿照EncodeVarint64的循环写法来重写这一部分</span></span><br><span class="line"><span class="comment">    while(v&gt;=B)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        *(ptr++) = v|B;</span></span><br><span class="line"><span class="comment">        v &gt;&gt;= 7;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    *(ptr++) = static_cast&lt;uint8_t&gt;(v);</span></span><br><span class="line"><span class="comment">    return reinterpret_cast&lt;char *&gt;(ptr);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>))</span><br><span class="line">    {</span><br><span class="line">        *(ptr++) = v;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">14</span>))</span><br><span class="line">    {</span><br><span class="line">        *(ptr++) = v | B;</span><br><span class="line">        *(ptr++) = v &gt;&gt; <span class="number">7</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">21</span>))</span><br><span class="line">    {</span><br><span class="line">        *(ptr++) = v | B;</span><br><span class="line">        *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">        *(ptr++) = v &gt;&gt; <span class="number">14</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">28</span>))</span><br><span class="line">    {</span><br><span class="line">        *(ptr++) = v | B;</span><br><span class="line">        *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">        *(ptr++) = (v &gt;&gt; <span class="number">14</span>) | B;</span><br><span class="line">        *(ptr++) = v &gt;&gt; <span class="number">21</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        *(ptr++) = v | B;</span><br><span class="line">        *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">        *(ptr++) = (v &gt;&gt; <span class="number">14</span>) | B;</span><br><span class="line">        *(ptr++) = (v &gt;&gt; <span class="number">21</span>) | B;</span><br><span class="line">        *(ptr++) = v &gt;&gt; <span class="number">28</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(ptr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码64位变长整数，此处没有使用循环，同样的，上面32位的也可以这样写</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">EncodeVarint64</span><span class="params">(<span class="type">char</span> *dst, <span class="type">uint64_t</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 将函数内的常数设置为局部静态变量，减少每次调用函数时的分配与开销</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">128</span>;</span><br><span class="line">    <span class="type">uint8_t</span> *ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span> *&gt;(dst);</span><br><span class="line">    <span class="comment">// B被设置成1&lt;&lt;7，当v&gt;=b时表示7位存不下</span></span><br><span class="line">    <span class="keyword">while</span> (v &gt;= B)</span><br><span class="line">    {</span><br><span class="line">        *(ptr++) = v | B;</span><br><span class="line">        v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">    }</span><br><span class="line">    *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(ptr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码32位变长整数，这个函数只处理小于128的单字节变长整数</span></span><br><span class="line"><span class="comment">// 大于127的部分则调用GetVarint32PtrFallback处理</span></span><br><span class="line"><span class="comment">// 此函数将解码后的值放在value中</span></span><br><span class="line"><span class="comment">// limit总是为p+5，因为变长整数最多5个字节</span></span><br><span class="line"><span class="comment">// p是一个指向包含值得字符串</span></span><br><span class="line"><span class="comment">// 返回的是对变长整数解码后的一个字节，设置成这样的目的是用于get方法</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">GetVarint32Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">const</span> <span class="type">char</span> *limit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (p &lt; limit)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">uint32_t</span> result = *(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span> *&gt;(p));</span><br><span class="line">        <span class="comment">// 内部只解码不超过127的整数，剩下的更长的交给GetVarint32PtrFallback处理</span></span><br><span class="line">        <span class="keyword">if</span> ((result &amp; <span class="number">128</span>) == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            *value = result;</span><br><span class="line">            <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetVarint32PtrFallback</span>(p, limit, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码32位变长整数中大于127的数字，即存储超过1个字节的变长32位整数</span></span><br><span class="line"><span class="comment">// 被GetVarint32Ptr调用</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">GetVarint32PtrFallback</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">const</span> <span class="type">char</span> *limit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">uint32_t</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于32位变长整数只能由28位存储数字，所以偏移的上限就是28位</span></span><br><span class="line">    <span class="comment">// 每个字节只能存储7位有效字符，所以每处理一字节就偏移7位</span></span><br><span class="line">    <span class="comment">// shift同时也是每个字节中有效数字的权</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">28</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 解码出一个字节</span></span><br><span class="line">        <span class="type">uint32_t</span> byte = *(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span> *&gt;(p));</span><br><span class="line">        p++;</span><br><span class="line">        <span class="comment">// 判断最高位，如果是1则继续取并执行，否则就返回解码的数据</span></span><br><span class="line">        <span class="keyword">if</span> (byte &amp; <span class="number">128</span>)</span><br><span class="line">        {</span><br><span class="line">            result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            result |= (byte &lt;&lt; shift);</span><br><span class="line">            *value = result;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(p);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当变长整数编码不正确就返回nullptr</span></span><br><span class="line">    <span class="comment">// 不正确的原因只能是因为连续5个字节都是被标记为1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码64位变长整数的函数，与解码32位变长的那个函数类似</span></span><br><span class="line"><span class="comment">// 不过这个函数没有回调，是直接在本函数内进行全部的解码工作</span></span><br><span class="line"><span class="comment">// 原因我觉得是这样的：因为小整数比较多，而小整数一般就以32位变长存储</span></span><br><span class="line"><span class="comment">// 而解码最小整数的函数被设置成内联函数，这样效率就会提升很多</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">GetVarint64Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">const</span> <span class="type">char</span> *limit, <span class="type">uint64_t</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint64_t</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个函数内部与GetVarint32PtrFallback一致</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">63</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">uint64_t</span> byte = *(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span> *&gt;(p));</span><br><span class="line">        p++;</span><br><span class="line">        <span class="keyword">if</span> (byte &amp; <span class="number">128</span>)</span><br><span class="line">        {</span><br><span class="line">            result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            result |= (byte &lt;&lt; shift);</span><br><span class="line">            *value = result;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(p);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============Put与Get方法=============*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把32位定长转换成字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutFixed32</span><span class="params">(std::string *dst, <span class="type">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 设置一个缓存区，然后把value编码到缓存区后插入</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="built_in">sizeof</span>(value)];</span><br><span class="line">    <span class="built_in">EncodeFixed32</span>(buf, value);</span><br><span class="line">    dst-&gt;<span class="built_in">append</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把64位定长转化成字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutFixed64</span><span class="params">(std::string *dst, <span class="type">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 设置一个缓存区，然后把value编码到缓存区后插入</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="built_in">sizeof</span>(value)];</span><br><span class="line">    <span class="built_in">EncodeFixed64</span>(buf, value);</span><br><span class="line">    dst-&gt;<span class="built_in">append</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把32位变长转化成字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutVarint32</span><span class="params">(std::string *dst, <span class="type">uint32_t</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 设置最大的缓冲区，注意EncodeVarint32会返回指向编码后的一个字节的指针</span></span><br><span class="line">    <span class="comment">// 所以就能根据指针偏移来计算出当前变长整数的长度</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> *ptr = <span class="built_in">EncodeVarint32</span>(buf, v);</span><br><span class="line">    dst-&gt;<span class="built_in">append</span>(buf, ptr - buf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把64位变长转化成字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutVarint64</span><span class="params">(std::string *dst, <span class="type">uint64_t</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 原理和PutVarint32一样，只是缓冲区大小大了一些</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> *ptr = <span class="built_in">EncodeVarint64</span>(buf, v);</span><br><span class="line">    dst-&gt;<span class="built_in">append</span>(buf, ptr - buf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把slice转化成字符串存储</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutLengthPrefixedSlice</span><span class="params">(std::string *dst, <span class="type">const</span> Slice &amp;value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 字符串的编码格式是长度在前，然后是字符串本身</span></span><br><span class="line">    <span class="comment">// 所以按照定义就可以插入了</span></span><br><span class="line">    <span class="comment">// 先插入长度，然后把字符串移动过去</span></span><br><span class="line">    <span class="comment">// 由于Slice末尾不需要'\0'，所以需要指定长度</span></span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, value.<span class="built_in">size</span>());</span><br><span class="line">    dst-&gt;<span class="built_in">append</span>(value.<span class="built_in">data</span>(), value.<span class="built_in">size</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算变长整数的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">VarintLength</span><span class="params">(<span class="type">uint64_t</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 这个函数思路很简单，不解析了</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (v &gt;= <span class="number">128</span>)</span><br><span class="line">    {</span><br><span class="line">        v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">        len++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串中获取32位变长</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetVarint32</span><span class="params">(Slice *input, <span class="type">uint32_t</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = input-&gt;<span class="built_in">data</span>();                   <span class="comment">// 先拿到字符串的首指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *limit = p + input-&gt;<span class="built_in">size</span>();           <span class="comment">// 然后获取尾部地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *q = <span class="built_in">GetVarint32Ptr</span>(p, limit, value); <span class="comment">//先解码出数据</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 所请求元素不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 由于一个字符串可能内部不止一个整数</span></span><br><span class="line">        <span class="comment">// 解码完一个整数后可能还剩余一部分未解码的数据</span></span><br><span class="line">        <span class="comment">// 比如字符串存储格式是前面一个32位变长+字符串本身</span></span><br><span class="line">        *input = <span class="built_in">Slice</span>(q, limit - q);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串中获取64位变长</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetVarint64</span><span class="params">(Slice *input, <span class="type">uint64_t</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 同上，只是部分接口不一样</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = input-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *limit = p + input-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *q = <span class="built_in">GetVarint64Ptr</span>(p, limit, value);</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        *input = <span class="built_in">Slice</span>(q, limit - q);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码出字符串</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetLengthPrefixedSlice</span><span class="params">(Slice *input, Slice *result)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    <span class="comment">// 先获取长度，然后根据长度去解码</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetVarint32</span>(input, &amp;len) &amp;&amp; input-&gt;<span class="built_in">size</span>() &gt;= len)</span><br><span class="line">    {</span><br><span class="line">        *result = <span class="built_in">Slice</span>(input-&gt;<span class="built_in">data</span>(), len);</span><br><span class="line">        input-&gt;<span class="built_in">remove_prefix</span>(len);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，关于字符串的解码部分我认为还是很巧妙的，因为字符串编码后的长度在前，且长度是一个变长整数，所以解码时需要先提取出长度。正常情况下的写法可能是先对整个编码后字符串遍历，解析出前面的长度，记录下这个字符串长度以及变长整数的长度后再去处理后面的字符串。</p>
<img src="/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/pic2.png" class="">
<p>但是levelDB中的处理方式是让变长解码函数解码多少就把输入中解码的这段数据给弄掉(修改了源字符串的指针)，因为这部分需要解码的值已经被解析出来并返回了，也就不再需要了。</p>
<img src="/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/pic3.png" class="">
<p><strong><em>每个解码函数只处理字符串开头，并且处理完成后及时改变字符串的首地址(后移)，这样就不需要记录这部分的状态并考虑处理细节了</em></strong></p>
<p>能够这样做的原因就是通过传递超尾元素来标定界限，同时所有处理函数都以指针作为数据传递的方式(统一接口标准)。</p>
<p>而直接移动字符串指针很容易就引出另外一个问题：会不会内存泄漏呢？</p>
<p>答案是不会，因为内存并不由Slice管理，Slice只是对底层字符串做出了映射而已，其主要目的是用于传递，后续我们会对Slice进行解析。</p>
<p>再特意把这段代码贴出来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetVarint32</span><span class="params">(Slice *input, <span class="type">uint32_t</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = input-&gt;<span class="built_in">data</span>();                   <span class="comment">// 先拿到字符串的首指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *limit = p + input-&gt;<span class="built_in">size</span>();           <span class="comment">// 然后获取尾部地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *q = <span class="built_in">GetVarint32Ptr</span>(p, limit, value); <span class="comment">//先解码出数据，q是超尾元素(相对变长整数而言)</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 所请求元素不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 由于一个字符串可能内部不止一个整数</span></span><br><span class="line">        <span class="comment">// 解码完一个整数后可能还剩余一部分未解码的数据</span></span><br><span class="line">        <span class="comment">// 比如字符串存储格式是前面一个32位变长+字符串本身</span></span><br><span class="line">        *input = <span class="built_in">Slice</span>(q, limit - q);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetLengthPrefixedSlice</span><span class="params">(Slice *input, Slice *result)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    <span class="comment">// 先获取长度，然后根据长度去解码</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetVarint32</span>(input, &amp;len) &amp;&amp; input-&gt;<span class="built_in">size</span>() &gt;= len)</span><br><span class="line">    {</span><br><span class="line">        *result = <span class="built_in">Slice</span>(input-&gt;<span class="built_in">data</span>(), len);</span><br><span class="line">        input-&gt;<span class="built_in">remove_prefix</span>(len);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="总结部分">总结部分</h2>
<table>
<colgroup>
<col style="width: 61%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数/变量</th>
<th style="text-align: center;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">inline void EncodeFixed32(char *dst,
uint32_t value)</td>
<td style="text-align: center;">编码定长32位整数</td>
</tr>
<tr class="even">
<td style="text-align: center;">inline void EncodeFixed64(char *dst,
uint64_t value)</td>
<td style="text-align: center;">编码定长64位整数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">inline uint32_t DecodeFixed32(const char
*ptr)</td>
<td style="text-align: center;">解码32位定长整数</td>
</tr>
<tr class="even">
<td style="text-align: center;">inline uint64_t DecodeFixed64(const char
*ptr)</td>
<td style="text-align: center;">解码64位定长整数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">char <em>EncodeVarint32(char </em>dst,
uint32_t v)</td>
<td style="text-align: center;">编码32位变长整数</td>
</tr>
<tr class="even">
<td style="text-align: center;">char <em>EncodeVarint64(char </em>dst,
uint64_t v)</td>
<td style="text-align: center;">编码64位变长整数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">inline const char
<em>GetVarint32Ptr(const char </em>p, const char <em>limit, uint32_t
</em>value)</td>
<td style="text-align: center;">解码32位变长整数</td>
</tr>
<tr class="even">
<td style="text-align: center;">const char
<em>GetVarint32PtrFallback(const char </em>p, const char
<em>limit,uint32_t </em>value)</td>
<td style="text-align: center;">解码32位变长整数中大于127的数字，被GetVarint32Ptr调用</td>
</tr>
<tr class="odd">
<td style="text-align: center;">const char <em>GetVarint64Ptr(const char
</em>p, const char <em>limit, uint64_t </em>value)</td>
<td style="text-align: center;">解码64位变长整数的函数</td>
</tr>
<tr class="even">
<td style="text-align: center;">void PutFixed32(std::string *dst,
uint32_t value)</td>
<td style="text-align: center;">把32位定长转换成字符串</td>
</tr>
<tr class="odd">
<td style="text-align: center;">void PutFixed64(std::string *dst,
uint64_t value)</td>
<td style="text-align: center;">把64位定长转化成字符串</td>
</tr>
<tr class="even">
<td style="text-align: center;">void PutVarint32(std::string *dst,
uint32_t v)</td>
<td style="text-align: center;">把32位变长转化成字符串</td>
</tr>
<tr class="odd">
<td style="text-align: center;">void PutVarint64(std::string *dst,
uint64_t v)</td>
<td style="text-align: center;">把64位变长转化成字符串</td>
</tr>
<tr class="even">
<td style="text-align: center;">void PutLengthPrefixedSlice(std::string
*dst, const Slice &amp;value)</td>
<td style="text-align: center;">把slice转化成字符串存储</td>
</tr>
<tr class="odd">
<td style="text-align: center;">int VarintLength(uint64_t v)</td>
<td style="text-align: center;">计算变长整数的长度</td>
</tr>
<tr class="even">
<td style="text-align: center;">bool GetVarint32(Slice <em>input,
uint32_t </em>value)</td>
<td style="text-align: center;">从字符串中获取32位变长</td>
</tr>
<tr class="odd">
<td style="text-align: center;">bool GetVarint64(Slice <em>input,
uint64_t </em>value)</td>
<td style="text-align: center;">从字符串中获取64位变长</td>
</tr>
<tr class="even">
<td style="text-align: center;">bool GetLengthPrefixedSlice(Slice
<em>input, Slice </em>result)</td>
<td style="text-align: center;">解码出字符串</td>
</tr>
</tbody>
</table>
<p>编码解码部分使用到了很多位级编程，这部分都很有意思，可以做到四两拨千斤的作用。</p>
<div class="note primary">
            <h3 id="编程小技巧">编程小技巧</h3><ul><li><p>在函数内需要用到的常量可以定义成内部静态常量<code>static const</code>，这样就避免了全局变量的额外开销与权限混乱、同时也能避免局部变量的每次都需要额外分配的开销。</p></li><li><p>当函数是处理连续的区间时，预留出超尾元素接口是很有必要的。</p></li></ul>
          </div>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(7)--SSTable结构</title>
    <url>/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/</url>
    <content><![CDATA[<h2 id="sstable结构">SSTable结构</h2>
<span id="more"></span>
<p>之前我们也提到过，levelDB的存储单元是SSTable，就即Sorted String
Table，是一个持久化的、有序的SortedMap，存储在磁盘上(除了一颗驻留在内存中)。</p>
<p>但是每次进行写操作时，不是直接写入SSTable，而是先写入WAL，即Write
Ahead
Log。这样做的目的是保存日志，因为可能会短时间内写入多条数据，而由于内存中的表项都是有序的，所以写每条数据之前必须找到其对应位置，且假如此时发生掉电或宕机，那么内存中的数据都没有了。而WAL写入的是硬盘，且其是日志结构，所以只需要进行磁盘的顺序写即可，这样一方面做了持久化，一方面也因为是顺序写不会产生明显的耗时。</p>
<p>SSTable是数据最终落盘的地方，而WAL保存了最近写入的数据，持久化到磁盘上，MemTable则是WAL里数据的内存表示，因为日志的格式不便于查询，在内存中才便于快速查询。</p>
<p>LevelDB的键值对都持久化到扩展名为ldb的文件中，一个ldb文件存储了一定键范围内的键值对，一个ldb文件就是我们的SSTable。</p>
<p>我们需要着重介绍一下这个SSTable。</p>
<h3 id="sstable的组成结构">SSTable的组成结构</h3>
<div class="note primary">
            <p>源码位置与说明</p><p>table/format.h table/format.cc:编解码BlockHandler，编解码Footer，根据BlockHandler读取一个键的内容<br>table/block_builder.h table/block_builder.cc:不断添加键值对，逐渐构建一个Block，主要是添加键值对，然后生成Block的数据<br>table/block.h table/block.cc: 对一个Block进行读取相关的功能<br>table/filter_block.h table/filter_block.ccinclude/leveldb/filter_policy.h util/bloom.cc:构建布隆过滤器数据，判断键是否存在的<br>include/leveldb/table.htable/table.cc：读取一个Table的内容，产生迭代器，或者根据一个键读取一个值<br>include/leveldb/table_builder.htable/table_builder.cc：不断添加键值对，逐渐构建一个Table<br>db/build.h db/build.cc：根据一个Iterator生成一个SSTable文件</p>
          </div>
<p>SSTable由以下几部分组成：</p>
<ul>
<li><code>Data Block</code> : 存储数据。Data
Block有多个，LevelDB将一个ldb文件里的键值对划分为多个Data
Block进行存储，每个Data
Block具有一定的大小，并且按照键的顺序进行排序，也就是后面一个Data
Block的第一个键大于前面一个Data Block的最后一个键，Data
Block可支持压缩。</li>
<li><code>Filter Block</code> :
用于过滤数据。也设计成为多个，目前只使用了一个，存储了布隆过滤器的二进制数据。目的是当查找一个键的时候，先查一下这个过滤器，如果不在，则去别处查，这样速度会快很多。</li>
<li><code>Meta Index Block</code> : 存储了指向Filter
Block的指针，根据这个指针可以找到某个Filter
Block开始的位置，以及其所占用的空间，这个指针的键是Meta
Block的名称，值是一个BlockHandler，是一个文件指针。</li>
<li><code>Index Block</code> : 存储了指向每一个Data
Block的指针的数组，这个指针的键大于等于对应的Data
Block的最后一个键，并且小于下一个Data Block的第一个键，通过Index
Block可以实现二分搜索，快速定位键属于哪个Data
Block，而不需要扫描所有的Data Block。</li>
<li><code>Footer</code> : 因为Meta Index Block和Index
Block的大小是不固定的，没法直接定位到这两个Block，所以最后有一个大小固定的Footer，保存两个BlockHandler，分别指向Meta
Index Block和Index Block。</li>
</ul>
<img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic1.jpg" class="">
<p>下面我们就来分别介绍每一个组件。</p>
<h4 id="footer">Footer</h4>
<div class="note primary">
            <p>源码位置 : <code>table/format.h</code><code>table/format.cc</code></p>
          </div>
<p>Footer的位置是固定的，在一个SSTable的结尾。但是由于Footer中使用了一些变长整数，为了确定Footer的位置，因此需要把Footer的大小固定下来，也就是对其做一些填充。所以Footer的格式如下所示</p>
<img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic2.jpg" class="">
<p>最后最后还存在一个Magic
number，这个魔数的作用是用于校验，生成的方法如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// table/format.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kTableMagicNumber was picked by running</span></span><br><span class="line"><span class="comment">//    echo http://code.google.com/p/leveldb/ | sha1sum</span></span><br><span class="line"><span class="comment">// and taking the leading 64 bits.</span></span><br><span class="line"><span class="comment">// 即使用echo http://code.google.com/p/leveldb/ | sha1sum生成然后截取了一部分</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> kTableMagicNumber = <span class="number">0xdb4775248b80fb57</span>ull;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>但是需要注意的是，这个只是文件中的存储格式，我们在Footer类中是看不到填充和魔数的</strong></p>
<p>我们接下来看一下Footer类的源码，由于Footer类中出现了<code>BlockHandle</code>，我们顺便把BlockHandle的类也看一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*================BlockHandle================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockHandle</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">uint64_t</span> offset_; <span class="comment">// Block在文件中的偏移量</span></span><br><span class="line">    <span class="type">uint64_t</span> size_;   <span class="comment">// Block的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// length of a BlockHandle最大长度</span></span><br><span class="line">    <span class="comment">// 之所以存在最大长度是因为使用的变长整数编码</span></span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    {</span><br><span class="line">        kMaxEncodedLength = <span class="number">10</span> + <span class="number">10</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BlockHandle</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset相关的一些方法</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">offset</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> offset_; }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_offset</span><span class="params">(<span class="type">uint64_t</span> offset)</span> </span>{ offset_ = offset; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size相关的一些方法</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> size_; }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_size</span><span class="params">(<span class="type">uint64_t</span> size)</span> </span>{ size_ = size; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码解码相关，把offset、size放入字符串或从字符串中解码</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EncodeTo</span><span class="params">(std::string *dst)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Status <span class="title">DecodeFrom</span><span class="params">(Slice *input)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/*================Footer================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Footer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 可以理解成广义指针，指向indexblock和metaindexblock</span></span><br><span class="line">    BlockHandle metaindex_handle_;</span><br><span class="line">    BlockHandle index_handle_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 长度，由于有两个BlockHandle，以及一个魔数，所以总共48字节</span></span><br><span class="line">    <span class="comment">// Footer的长度始终是固定的，如果BlockHandle没有占满，会额外引入填充</span></span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    {</span><br><span class="line">        kEncodedLength = <span class="number">2</span> * BlockHandle::kMaxEncodedLength + <span class="number">8</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Footer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理metaindex_handle相关函数</span></span><br><span class="line">    <span class="function"><span class="type">const</span> BlockHandle &amp;<span class="title">metaindex_handle</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> metaindex_handle_; }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_metaindex_handle</span><span class="params">(<span class="type">const</span> BlockHandle &amp;h)</span> </span>{ metaindex_handle_ = h; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理index_handle相关函数</span></span><br><span class="line">    <span class="function"><span class="type">const</span> BlockHandle &amp;<span class="title">index_handle</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> index_handle_; }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_index_handle</span><span class="params">(<span class="type">const</span> BlockHandle &amp;h)</span> </span>{ index_handle_ = h; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码解码函数，填充就是在这里引入的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EncodeTo</span><span class="params">(std::string *dst)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Status <span class="title">DecodeFrom</span><span class="params">(Slice *input)</span></span>;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到，这个BlockHandle类其中就只有两个私有成员:
offset_和size_，其中offset_表示当前的这个Block位于的位置，而size_则说明了这个块的长度，即通过起始位置+长度这两个坐标就指明了一个Block。</p>
<p>而Footer这个类，其私有成员只有两个BlockHandle，分别指向了metaindex
block和index
block这两个block。但是我们之前说过在文件中的Footer部分是存在填充和魔数的，可我们在类的成员中并没有看到，这是因为填充和魔数是在将类编码到文件时才会被引入，其实就是<code>Footer::EncodeTo</code>和<code>Footer::DecodeFrom</code>这两个函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*================BlockHandle================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockHandle::EncodeTo</span><span class="params">(std::string *dst)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Sanity check that all fields have been set</span></span><br><span class="line">    <span class="built_in">assert</span>(offset_ != ~<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">assert</span>(size_ != ~<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 其实就是把offset和size变长整数编码后放入字符串中</span></span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, offset_);</span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, size_);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BlockHandle::DecodeFrom</span><span class="params">(Slice *input)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 解码变长整数</span></span><br><span class="line">    <span class="comment">// 还是要赞美一下这个GetVarint64中直接移动Slice的设计，太优雅了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetVarint64</span>(input, &amp;offset_) &amp;&amp; <span class="built_in">GetVarint64</span>(input, &amp;size_))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"bad block handle"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*================Footer================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就是编码Footer到字符串的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Footer::EncodeTo</span><span class="params">(std::string *dst)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> original_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 这里调用BlockHandle的编码函数</span></span><br><span class="line">    metaindex_handle_.<span class="built_in">EncodeTo</span>(dst);</span><br><span class="line">    index_handle_.<span class="built_in">EncodeTo</span>(dst);</span><br><span class="line">    <span class="comment">// 填充是在这里引入的，就是调用了string.resize()函数</span></span><br><span class="line">    dst-&gt;<span class="built_in">resize</span>(<span class="number">2</span> * BlockHandle::kMaxEncodedLength);</span><br><span class="line">    <span class="comment">// 然后插入魔数，但是不是很清楚为什么要分两次插入而不用PutFixed64</span></span><br><span class="line">    <span class="comment">// 也许是考虑了32位机器？</span></span><br><span class="line">    <span class="built_in">PutFixed32</span>(dst, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(kTableMagicNumber &amp; <span class="number">0xffffffff</span>u));</span><br><span class="line">    <span class="built_in">PutFixed32</span>(dst, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(kTableMagicNumber &gt;&gt; <span class="number">32</span>));</span><br><span class="line">    <span class="built_in">assert</span>(dst-&gt;<span class="built_in">size</span>() == original_size + kEncodedLength);</span><br><span class="line">    (<span class="type">void</span>)original_size; <span class="comment">// Disable unused variable warning.</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串中解码出Footer的函数</span></span><br><span class="line"><span class="function">Status <span class="title">Footer::DecodeFrom</span><span class="params">(Slice *input)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 获取魔数并校验</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *magic_ptr = input-&gt;<span class="built_in">data</span>() + kEncodedLength - <span class="number">8</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> magic_lo = <span class="built_in">DecodeFixed32</span>(magic_ptr);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> magic_hi = <span class="built_in">DecodeFixed32</span>(magic_ptr + <span class="number">4</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> magic = ((<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(magic_hi) &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">                            (<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(magic_lo)));</span><br><span class="line">    <span class="keyword">if</span> (magic != kTableMagicNumber)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"not an sstable (bad magic number)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后解码出两个handle，继续赞叹一下GetVarint64的那个设计(第三次了)</span></span><br><span class="line">    Status result = metaindex_handle_.<span class="built_in">DecodeFrom</span>(input);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        result = index_handle_.<span class="built_in">DecodeFrom</span>(input);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 这里需要让输入的字串跳过填充和魔数</span></span><br><span class="line">        <span class="comment">// 从而保持了处理一部分丢弃一部分的良好的特征</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *end = magic_ptr + <span class="number">8</span>;</span><br><span class="line">        *input = <span class="built_in">Slice</span>(end, input-&gt;<span class="built_in">data</span>() + input-&gt;<span class="built_in">size</span>() - end);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过上述代码，我们就能很清晰地看到Footer和BlcokHandle是如何处理的了。</p>
<h4 id="blcok">Blcok</h4>
<p>其实其余的所有部分都可以看成是Block，其中BlockHandler可以看成是指向Block的指针，可以用其来读取出Blcok的内容。之前也阐述过BlockHandler的结构了，下面我们来看以下Block的结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iter</span>;                   <span class="comment">// 迭代器类</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">NumRestarts</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 读取restarts的数量，这个值是放在Block块的尾部的</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data_;            <span class="comment">// 存放数据的指针</span></span><br><span class="line">    <span class="type">size_t</span> size_;                 <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">uint32_t</span> restart_offset_;     <span class="comment">// 是restart偏移的位置</span></span><br><span class="line">    <span class="type">bool</span> owned_;                  <span class="comment">// 表示是否拥有这个数据，自己负责数据的申请和释放</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数等类基本函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Block</span><span class="params">(<span class="type">const</span> BlockContents &amp;contents)</span></span>;</span><br><span class="line">    <span class="built_in">Block</span>(<span class="type">const</span> Block &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Block &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Block &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Block</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> size_; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器接口</span></span><br><span class="line">    <span class="function">Iterator *<span class="title">NewIterator</span><span class="params">(<span class="type">const</span> Comparator *comparator)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现这个Block的类内部还是十分简洁的，不过还是要关于其私有成员做一些说明。</p>
<p>首先是<code>owned_</code>这个成员，之前我们说过，levelDB的内存管理是由Arena来管理的，当数据小于1kb时直接放入Arena分配的内存块中，否则就自己new一个内存出来存放。这里的owned_成员其实就说明了data中存放的数据是自己new出来的还是Arena分配出来的，如果是自己new出来的，则需要自己进行内存管理。</p>
<p>然后还有一个<code>restart_offset_</code>成员，我们先不说这个成员是干什么的，我们先来看一下Block内部的存储结构(<strong>此处说的不是Data
Block</strong>)。首先，所有的有效数据都存放在<code>data_</code>中，但是一个data_肯定存放不止一个数据，而且这些数据大小也未必相同，所以为了能够准确找到这些数据，我们还额外需要记录每条数据的头部的位置，或者成为每条数据头部距离起始位置的偏移，但是数据总数不知道，所以偏移的总数也不知道，因此还需要记录偏移的总数目。就构成了下图所示的结构。</p>
<img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic3.jpg" class="">
<p>上图可以看成是<code>data_</code>成员的结构(<strong>这是Block内部成员的关系，跟xxxhandler无关</strong>)，前面一部分是数据区，存放了各种数据；往下是偏移区，这部分分别指向了数据，但是我们实际上存放的有序的数据，所以没必要指向所有的数据区的内容(这里后面对Data
Block继续详细说明)，<strong>最后一个是偏移区大小也称为NumRestarts</strong>。</p>
<p>由于其他的xxx
Block都是一个Block结构，所以都具有Block的成员，所以关于Block的具体实现我们放在后面。</p>
<h4 id="data-block">Data Block</h4>
<p>我们先来看看Data Block中的数据存放。Data
Block的默认大小是4K，但这不是固定的，有可能会超过4K，每次插入一个键值对时都会判断是否超过了4KB，如果插入一个大一点的键值对，就会超过4KB，不过一个键值对只会保存在一个Data
Block里面，不会横跨两个Data Block。</p>
<p>由于相邻的键有可能存在相同的前缀，考虑到这一点，LevelDB设置了前缀压缩法，也就是后面的键只需要记录与前一个键不同的部分，以及跟前一个键相同部分的长度，这样通过前一个键就可以还原出后一个键的完整Key，为何要这么设计呢？之所以这样设计是为了节省存储空间，因为Keys之间有相同部分的概率是存在的(这也是之前compare类中的两个用于压缩的方法的用武之地)。</p>
<p>一个KV的格式如下：共享key的长度+非共享key的长度+值value的长度+非共享key的内容+值value。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">shared_length | non_shared_length | value_length | non_shared_contents | value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过shared_length和前一个键可以得到当前键的前缀，然后根据这个KV里面的后缀non_shared_contents，便可以拼接得到这个完整的键Key。通过这种前缀压缩的方式将多个KV连续存放在Data
Block里，但是这样会有一个问题，无论想查找哪一个键Key的值，都需要从Block的第一个键Key开始遍历，依次构造拼接出最终想要的key，那么搜索一个键Key就需要遍历整个Block，这样显然效率会比较低。那怎么办呢？怎么去优化？既然KV的格式已经定了（压缩共享key），要搜索一个Key就需要拼接，那能不能拼接不要无限长，把key一组一组的划分，同一组内key是可以共享的，每一组的第一个key作为起始key就不要共享，该组内后续的key与第一个key共享key，这样key的拼接就是有限次的，查找一个key不需要遍历整个Block，只需要遍历有限个Key，这样效率不会受影响。于是就引入一个叫restart
point的概念，记录每个分组的第一个KV的位置，这个位置的KV的shared_length为0，non_shared_length就是整个Key的长度，non_shared_contents就是完整的Key。<strong>这个restart
point其实就是之前的偏移区中的东西，这也是为什么上图中没有每个数据都被偏移区的指针指到；而我们之前说的data_中数据区，其中就是存放的多个kv。</strong>可以参考下面这张图，这里面还有一些crc校验和压缩类型之类的，我们先略过。</p>
<img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic4.jpg" class="">
<p>下面我们来看一下Block类的一些实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 读取numrestarts的函数，numrestarts放在data的最后</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Block::NumRestarts</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">assert</span>(size_ &gt;= <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DecodeFixed32</span>(data_ + size_ - <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Block::<span class="built_in">Block</span>(<span class="type">const</span> BlockContents &amp;contents)</span><br><span class="line">    : <span class="built_in">data_</span>(contents.data.<span class="built_in">data</span>()),</span><br><span class="line">      <span class="built_in">size_</span>(contents.data.<span class="built_in">size</span>()),</span><br><span class="line">      <span class="built_in">owned_</span>(contents.heap_allocated)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (size_ &lt; <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>))</span><br><span class="line">    {</span><br><span class="line">        size_ = <span class="number">0</span>; <span class="comment">// Error marker</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">size_t</span> max_restarts_allowed = (size_ - <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>)) / <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NumRestarts</span>() &gt; max_restarts_allowed)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// The size is too small for NumRestarts()</span></span><br><span class="line">            size_ = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            restart_offset_ = size_ - (<span class="number">1</span> + <span class="built_in">NumRestarts</span>()) * <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Block::~<span class="built_in">Block</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (owned_)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于提取从p内存位置开始的entry. 也就是内容块，即data_数据区各个条目</span></span><br><span class="line"><span class="comment">// 将长度分别记录到传进来的指针里面</span></span><br><span class="line"><span class="comment">// limit是不能超出的内存的长度</span></span><br><span class="line"><span class="comment">// 如果遇到什么错误，就返回空指针</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">DecodeEntry</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p, <span class="type">const</span> <span class="type">char</span> *limit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">uint32_t</span> *shared,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">uint32_t</span> *non_shared,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">uint32_t</span> *value_length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 如果已经不足三个bytes，那么肯定是没有内容或者出错了。</span></span><br><span class="line">    <span class="comment">// 为什么这里写明是3 bytes?</span></span><br><span class="line">    <span class="comment">// 这是因为shared key length, non-shared key length</span></span><br><span class="line">    <span class="comment">// value length三个长度即使是0,也会分别占用3 bytes.</span></span><br><span class="line">    <span class="comment">// 这里相当于做了一个优化，如果三个值之和都小于128，那肯定是每个值只占一个字节</span></span><br><span class="line">    <span class="keyword">if</span> (limit - p &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 分虽取出三个长度</span></span><br><span class="line">    *shared = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *&gt;(p)[<span class="number">0</span>];</span><br><span class="line">    *non_shared = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *&gt;(p)[<span class="number">1</span>];</span><br><span class="line">    *value_length = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *&gt;(p)[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 如查所有的长度都是小于128的。那么在压缩编码的时候，就是直接按照</span></span><br><span class="line">    <span class="comment">// 一个byte来存放。不需要解码</span></span><br><span class="line">    <span class="keyword">if</span> ((*shared | *non_shared | *value_length) &lt; <span class="number">128</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Fast path: all three values are encoded in one byte each</span></span><br><span class="line">        p += <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 如果已经是整数压缩存放的，那么在编解码的时候，就需要用Varint来处理一下</span></span><br><span class="line">        <span class="comment">// 注意每个的出错处理</span></span><br><span class="line">        <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, shared)) == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, non_shared)) == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, value_length)) == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 读出来的条目的长度肯定是non_shared_key_length + value_length</span></span><br><span class="line">    <span class="comment">// 如果余下的空间没有这么多了</span></span><br><span class="line">    <span class="comment">// 那么肯定是出错了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(limit - p) &lt; (*non_shared + *value_length))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回non_shared_key + value 内容的超始点</span></span><br><span class="line">    <span class="comment">// 后面在使用的时候</span></span><br><span class="line">    <span class="comment">// (p, non_shared_key)就是非共享的key的内容</span></span><br><span class="line">    <span class="comment">// (p+non_shared_key, value_length)就是value的内容。</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面的辅助函数就是用于辅助读取每个kv的key和value的，可以解析出shared、non_shared、value_length。</p>
<p>我们来看一下Block与Data Block的关系</p>
<img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic5.jpg" class="">
<p>Block中还定义了自己的迭代器类，不过这个东西与Data
Block结构无关，主要适用于遍历和构建的，我们后面再说他。</p>
<p>另外需要注意的是，Block本身不涉及kv的插入与删除，其只涉及到Bolck的存储、查找。</p>
<p>从Block的构造函数我们可以看到Block的构建来自于结构体BlockContents，这部分我们后面再说。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BlockContents</span> {</span><br><span class="line">  Slice data;           <span class="comment">// Actual contents of data</span></span><br><span class="line">  <span class="type">bool</span> cachable;        <span class="comment">// True iff data can be cached</span></span><br><span class="line">  <span class="type">bool</span> heap_allocated;  <span class="comment">// True iff caller should delete[] data.data()</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="index-block">Index Block</h4>
<p>知道Data Block的结构后，Index
Block就非常简单了，它其实就是存储了一个Kv数组，每一个Kv对应一个Data
Block，其中键大于等于对应的Data
Block中最后一个键，值为一个BlockHandler，可以定位到一个Data Block。Index
Block就是Data Block的索引，搜索时可以对Index
Block二分搜索，找到键对应的Data Block。</p>
<p>Index Block里面每一个Kv都是一个restart
point，也就是没有采用前缀压缩，相当于restart
point是一个稠密索引，每一个Kv都有一个restart point对应。</p>
<img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic6.jpg" class="">
<h4 id="meta-index-block">Meta Index Block</h4>
<p>和Index Block指向Data Block一样，Meta Index Block指向Filter
Block，是Filter Block的索引。不过目前只有一个Filter
Block，也就是里面只有一个Kv。键是Filter
Block的名字，而值是一个BlockHandler，指向对应的Filter Block。</p>
<p>对于目前存在的Bloom
Filter而言，键是<code>filter.leveldb.BuiltinBloomFilter2</code>。</p>
<img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic7.jpg" class="">
<h4 id="filter-block">Filter Block</h4>
<p>Filter Block就是Meta Index Block中记录的布隆过滤器了。</p>
<p>为什么要在SSTable文件中放置一个布隆过滤器？</p>
<p>我们知道布隆过滤器是一种概率型的数据结构，特点是高效的插入和查询，它的作用是为了快速判定一个Key是否存在。这不是精确判断：如果一个Key判定存在，实际不一定存在；但是，如果判定一个Key不存在，那就一定不存在，其结果是假阳性的。利用这个特性，可以快速的判定一个Key是否存在，如果不存在，就不需要再去查找了，直接返回错误；如果判定存在，则需要进一步查到确定Key是否存在。</p>
<p>在一个SSTable文件中，正常的查找流程如下：</p>
<ol type="1">
<li>对Index Block进行二分搜索，查到键所属的Data Block；</li>
<li>读取Data Block，对restart
point进行二分搜索，查找对应的键所属的restart point；</li>
<li>定位到restart point处，再遍历16个Keys进行键的查找。</li>
</ol>
<p>理想情况下，Index Block可以缓存在内存中，但是Data
Block数据量太大，可能不会缓存在内存中，这样就需要一次磁盘IO，查询效率必然不高。</p>
<p>如何避免磁盘IO呢？怎么才能放到内存中来查找呢？布隆过滤器可以解决这个问题。布隆过滤器比较小，可以缓存在内存中，这样就可以通过布隆过滤器快速判断对应的键有没有在这个SSTable里。如果判断键在SSTable，那也只有很小的概率是键不在这个SSTable里。这是典型的用空间换时间的思想，选择布隆过滤器是因为布隆过滤器的空间占用非常小，可以加载到内存中，进行快速判定。</p>
<p>LevelDB采用了多个布隆过滤器，默认情况下，每2KB的数据开启一个布隆过滤器（如下定义），因此，布隆过滤器也必然组成一个数组结构，last_word就是偏移数组的位置，数组的每个值指向一个布隆过滤器的位置。</p>
<p>由于布隆过滤器不是重点，此处只给出头文件，实现就暂且略过了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FilterBlockReader</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// REQUIRES: "contents" and *policy must stay live while *this is live.</span></span><br><span class="line">    <span class="built_in">FilterBlockReader</span>(<span class="type">const</span> FilterPolicy *policy, <span class="type">const</span> Slice &amp;contents);</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="type">uint64_t</span> block_offset, <span class="type">const</span> Slice &amp;key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> FilterPolicy *policy_;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data_;   <span class="comment">// 过滤器的起始位置</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *offset_; <span class="comment">// 偏移位置</span></span><br><span class="line">    <span class="type">size_t</span> num_;         <span class="comment">// 偏移总数</span></span><br><span class="line">    <span class="type">size_t</span> base_lg_;     <span class="comment">// Encoding parameter (see kFilterBaseLg in .cc file)</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="读取一个键的步骤">读取一个键的步骤</h3>
<p>过上面对SSTable的介绍，来总结一下在SSTable读取一个键的步骤。</p>
<p>要读取一个SSTable，首先需要打开这个SSTable，打开会有以下步骤:</p>
<ul>
<li>读取Footer，根据里面的读取Meta Index Block和Index Block，将Index
Block的内容缓存到内存中；</li>
<li>根据Meta Index Block读取布隆过滤器的数据，缓存到内存中。</li>
</ul>
<p>至于具体的读取函数和构建函数我们后面会详细阐述。</p>
<p>读取一个键的步骤如下：</p>
<ul>
<li>根据键对Index Block的restart point进行二分搜索，找到这个键对应的Data
Block的BlockHandler；</li>
<li>根据BlockHandler的偏移计算出布隆过滤器的编号，读取相应的布隆过滤器；</li>
<li>通过布隆过滤器的数据判断键是否存在，不存在就结束，否则读取对应的Data
Block；</li>
<li>对Data Block里的restart point进行二分搜索，找到搜索键对应的restart
point;</li>
<li>对这个restart
point对应的键进行搜索，最多搜索16个键，找到键或者找不到键。</li>
</ul>
<p>通过以上步骤可以看到Index
Block和布隆过滤器的内容都是缓存在内存里的，所以当一个键在SSTable不存在时，99%的概率是不需要磁盘IO的。</p>
<h2 id="总结">总结</h2>
<p>SSTable的实现还是相当复杂的，而且这部分涉及到了很多个类，这部分的技巧主要在数据结构上。SSTable和B+树的思想很像，就好像一个3层的B+树，Footer是根节点，定位到Index
Block，Index Block是第二层，可以定位到Data Block。</p>
<p>SSTable的文件布局比较紧凑，查询效率也比较高，不需要像B+树这样复杂，因为SSTable只会整体生成，而不会增量修改，也就是SSTable是只读，这个结构就是利用了这个特性。</p>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(8)--Block和SSTable的构建</title>
    <url>/2022/09/27/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-8/</url>
    <content><![CDATA[<h2 id="block和sstable的构建">Block和SSTable的构建</h2>
<span id="more"></span>
<p>我们在之前提到了SSTable和内部的各类Block的结构，也初步分析了其在源码中的类级别的组织结构，但是我们也能注意到类结构和实际写入文件的结构是存在明显差异的，所以我们现在就需要进一步了解levelDB是如何构建这些Block与SSTable的。</p>
<div class="note primary">
            <p>源码位置与说明:</p><p>table/block_builder.cc table/block_builder.h : Block构建相关<br>include/leveldb/table_builder.h table/table_builder.cc :table构建相关<br>include/leveldb/table.h table/table.cc :读取一个Table的内容，产生迭代器，或者根据一个键读取一个值</p>
          </div>
<h3 id="block的构建--blockbuilder">Block的构建--BlockBuilder</h3>
<p>我们之前看到的Block的类其实只有存储的数据类型、迭代器和查询相关的东西，那么Block获取到的数据是哪里来的呢？也就是哪个类来负责把一个一个kv插入到data_中呢？其实这个类就是BlockBuilder。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockBuilder</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> Options *options_;         <span class="comment">// Options选项</span></span><br><span class="line">    std::string buffer_;             <span class="comment">// 缓冲区，是存放kv的位置</span></span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; restarts_; <span class="comment">// Restart points</span></span><br><span class="line">    <span class="type">int</span> counter_;                    <span class="comment">// 将此类重启后的元素数目</span></span><br><span class="line">    <span class="type">bool</span> finished_;                  <span class="comment">// 是否构建完成</span></span><br><span class="line">    std::string last_key_;           <span class="comment">//上一个key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造析构函数相关</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BlockBuilder</span><span class="params">(<span class="type">const</span> Options *options)</span></span>;</span><br><span class="line">    <span class="built_in">BlockBuilder</span>(<span class="type">const</span> BlockBuilder &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    BlockBuilder &amp;<span class="keyword">operator</span>=(<span class="type">const</span> BlockBuilder &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重启此类，其实就是开启新的构建，因为每个Block内的数据大小是有限制的</span></span><br><span class="line">    <span class="comment">// 但是不需要为每个Block都创建一个BlockBuilder</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把key-value加入，要求构建过程没有结束且key比之前加入的key要大</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">const</span> Slice &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束此次构建，返回一个构建结果，即data_，包含数据区和偏执区两部分</span></span><br><span class="line">    <span class="comment">// 返回的字符串一直到下次Finish()被调用前都有效</span></span><br><span class="line">    <span class="function">Slice <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回构建的Block大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">CurrentSizeEstimate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前构建是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> buffer_.<span class="built_in">empty</span>(); }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到一个BlockBuilder的作用其实就是不断把key-value添加到缓冲区中，然后在完成构建时返回这个缓冲区。由于没有必须要为每个Block都生成一个BlockBuilder类，所以BlockBuilder类是可以复用的。</p>
<p>下面我们来看一下具体的实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">BlockBuilder::<span class="built_in">BlockBuilder</span>(<span class="type">const</span> Options *options)</span><br><span class="line">    : <span class="built_in">options_</span>(options), <span class="built_in">restarts_</span>(), <span class="built_in">counter_</span>(<span class="number">0</span>), <span class="built_in">finished_</span>(<span class="literal">false</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">assert</span>(options-&gt;block_restart_interval &gt;= <span class="number">1</span>);</span><br><span class="line">    restarts_.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// 第一个重启点就是0偏置位置</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重启BlockBuilder类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBuilder::Reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    buffer_.<span class="built_in">clear</span>();</span><br><span class="line">    restarts_.<span class="built_in">clear</span>();</span><br><span class="line">    restarts_.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// 第一个重启点就是0偏置位置</span></span><br><span class="line">    counter_ = <span class="number">0</span>;</span><br><span class="line">    finished_ = <span class="literal">false</span>;</span><br><span class="line">    last_key_.<span class="built_in">clear</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前的构建大小，包含三部分组成：data_[] restart_[] restart_num</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">BlockBuilder::CurrentSizeEstimate</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (buffer_.<span class="built_in">size</span>() +                      <span class="comment">// Raw data buffer</span></span><br><span class="line">            restarts_.<span class="built_in">size</span>() * <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>) + <span class="comment">// Restart array</span></span><br><span class="line">            <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));                    <span class="comment">// Restart array length</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束当次构建</span></span><br><span class="line"><span class="function">Slice <span class="title">BlockBuilder::Finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 需要把所有的重启点插入到数据后面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; restarts_.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">PutFixed32</span>(&amp;buffer_, restarts_[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">PutFixed32</span>(&amp;buffer_, restarts_.<span class="built_in">size</span>());</span><br><span class="line">    finished_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(buffer_);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入key-value</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBuilder::Add</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">const</span> Slice &amp;value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Slice <span class="title">last_key_piece</span><span class="params">(last_key_)</span></span>; <span class="comment">// 获取上一个key，需要保证当前key大于上一个key</span></span><br><span class="line">    <span class="built_in">assert</span>(!finished_);</span><br><span class="line">    <span class="built_in">assert</span>(counter_ &lt;= options_-&gt;block_restart_interval);</span><br><span class="line">    <span class="built_in">assert</span>(buffer_.<span class="built_in">empty</span>() <span class="comment">// No values yet?</span></span><br><span class="line">           || options_-&gt;comparator-&gt;<span class="built_in">Compare</span>(key, last_key_piece) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">size_t</span> shared = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出与上一个key之间的前缀长度</span></span><br><span class="line">    <span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// See how much sharing to do with previous string</span></span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> min_length = std::<span class="built_in">min</span>(last_key_piece.<span class="built_in">size</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared]))</span><br><span class="line">        {</span><br><span class="line">            shared++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 如果某个重启点后共享key数目到达预定值就新建重启点</span></span><br><span class="line">        restarts_.<span class="built_in">push_back</span>(buffer_.<span class="built_in">size</span>());</span><br><span class="line">        counter_ = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> non_shared = key.<span class="built_in">size</span>() - shared; <span class="comment">// 非共享key长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面就是按照key的格式插入到data_中</span></span><br><span class="line">    <span class="comment">// Add "&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;" to buffer_</span></span><br><span class="line">    <span class="built_in">PutVarint32</span>(&amp;buffer_, shared);</span><br><span class="line">    <span class="built_in">PutVarint32</span>(&amp;buffer_, non_shared);</span><br><span class="line">    <span class="built_in">PutVarint32</span>(&amp;buffer_, value.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add string delta to buffer_ followed by value</span></span><br><span class="line">    buffer_.<span class="built_in">append</span>(key.<span class="built_in">data</span>() + shared, non_shared);</span><br><span class="line">    buffer_.<span class="built_in">append</span>(value.<span class="built_in">data</span>(), value.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新类内数据</span></span><br><span class="line">    last_key_.<span class="built_in">resize</span>(shared);</span><br><span class="line">    last_key_.<span class="built_in">append</span>(key.<span class="built_in">data</span>() + shared, non_shared);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Slice</span>(last_key_) == key);</span><br><span class="line">    counter_++;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到，BlockBuilder还是很简单的，主要就是创建重启点、插入key-value，不过需要注意的是这个插入key-value的时候需要保证keys是有序的。</p>
<h3 id="table类">Table类</h3>
<p>在之前我们讲述SSTable的时候，我们其实是没有提到Table这个类的，因为前面的内容有点多，下面我们就来具体看一下这个类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> Table</span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TableCache</span>; <span class="comment">// 友元缓存类</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Rep</span>;              <span class="comment">// 这个是一个结构体，存放xxxhandler、Block之类的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把xxxindex Block中的内容给提取出来</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Iterator *<span class="title">BlockReader</span><span class="params">(<span class="type">void</span> *, <span class="type">const</span> ReadOptions &amp;, <span class="type">const</span> Slice &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Table</span><span class="params">(Rep *rep)</span> : rep_(rep) {</span>}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calls (*handle_result)(arg, ...) with the entry found after a call</span></span><br><span class="line">    <span class="comment">// to Seek(key).  May not make such a call if filter policy says</span></span><br><span class="line">    <span class="comment">// that key is not present.</span></span><br><span class="line">    <span class="function">Status <span class="title">InternalGet</span><span class="params">(<span class="type">const</span> ReadOptions &amp;, <span class="type">const</span> Slice &amp;key, <span class="type">void</span> *arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">void</span> (*handle_result)(<span class="type">void</span> *arg, <span class="type">const</span> Slice &amp;k,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> Slice &amp;v))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取Meta Block和Filter Block</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReadMeta</span><span class="params">(<span class="type">const</span> Footer &amp;footer)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReadFilter</span><span class="params">(<span class="type">const</span> Slice &amp;filter_handle_value)</span></span>;</span><br><span class="line"></span><br><span class="line">    Rep *<span class="type">const</span> rep_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Attempt to open the table that is stored in bytes [0..file_size)</span></span><br><span class="line">    <span class="comment">// of "file", and read the metadata entries necessary to allow</span></span><br><span class="line">    <span class="comment">// retrieving data from the table.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If successful, returns ok and sets "*table" to the newly opened</span></span><br><span class="line">    <span class="comment">// table.  The client should delete "*table" when no longer needed.</span></span><br><span class="line">    <span class="comment">// If there was an error while initializing the table, sets "*table"</span></span><br><span class="line">    <span class="comment">// to nullptr and returns a non-ok status.  Does not take ownership of</span></span><br><span class="line">    <span class="comment">// "*source", but the client must ensure that "source" remains live</span></span><br><span class="line">    <span class="comment">// for the duration of the returned table's lifetime.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// *file must remain live while this Table is in use.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个可以随机读取的SSTable文件，并返回从这个文件中读取的Table类</span></span><br><span class="line">    <span class="comment">// RandomAccessFile可以看成是一个随机读写迭代器</span></span><br><span class="line">    <span class="comment">// 这里的原文我保留下来，写的很详细</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Status <span class="title">Open</span><span class="params">(<span class="type">const</span> Options &amp;options, RandomAccessFile *file,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">uint64_t</span> file_size, Table **table)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造析构函数相关</span></span><br><span class="line">    <span class="built_in">Table</span>(<span class="type">const</span> Table &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Table &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Table &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Table</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个指向Table内的数据的迭代器，初始生成的迭代器不可用，需要手动初始化</span></span><br><span class="line">    <span class="function">Iterator *<span class="title">NewIterator</span><span class="params">(<span class="type">const</span> ReadOptions &amp;)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于估算key值所在记录的偏移，目前作用不是很清楚</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">ApproximateOffsetOf</span><span class="params">(<span class="type">const</span> Slice &amp;key)</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>头文件中定义了缓存用的友元类、迭代器这些，说明Table类其实也没有定义怎么构建SSTable，而主要的目的是从文件中读取一个SSTable出来。</p>
<p>由于这其中涉及到了迭代器和缓存类，所以具体的实现我们就先略过，等到后面再详细看。</p>
<h3 id="table的构建--tablebuilder">Table的构建--TableBuilder</h3>
<p>Block的构建是通过BlockBuilder类来完成的，而Table的构建则是通过TableBuilder类来完成的。我们先来看一下其头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> TableBuilder</span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 返回构建器状态</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">status</span>().<span class="built_in">ok</span>(); }</span><br><span class="line">    <span class="comment">// 写入Block的封装函数，对WriteRawBlock的封装</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteBlock</span><span class="params">(BlockBuilder *block, BlockHandle *handle)</span></span>;</span><br><span class="line">    <span class="comment">// 将Block实际写入文件的函数，包含压缩类型</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteRawBlock</span><span class="params">(<span class="type">const</span> Slice &amp;data, CompressionType, BlockHandle *handle)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Rep</span>; <span class="comment">// 这个Rep与Table类中的Rep不一样，其声明位置是不同的</span></span><br><span class="line">    Rep *rep_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建一个Builder类来完成文件的写入</span></span><br><span class="line">    <span class="built_in">TableBuilder</span>(<span class="type">const</span> Options &amp;options, WritableFile *file);</span><br><span class="line">    <span class="built_in">TableBuilder</span>(<span class="type">const</span> TableBuilder &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    TableBuilder &amp;<span class="keyword">operator</span>=(<span class="type">const</span> TableBuilder &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">TableBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变Builder类的Options，只有部分选项可以被更改</span></span><br><span class="line">    <span class="function">Status <span class="title">ChangeOptions</span><span class="params">(<span class="type">const</span> Options &amp;options)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个key-value需要保证key比之前的都大</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">const</span> Slice &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数的作用是把缓存区中的key-value持久化到磁盘中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回构建器的状态</span></span><br><span class="line">    <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束当前构建，和BlockTable中一样</span></span><br><span class="line">    <span class="function">Status <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛弃掉当前构建器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Abandon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add的次数</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">NumEntries</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回构建的文件大小</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">FileSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到TableBuilder的头文件中定义了将Key写入文件的部分。以及，虽然这个类中也存在一个类型为Req的东西，但是和Table类中的不是同一个东西，我们看一下其定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TableBuilder</span>::Rep</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">Rep</span>(<span class="type">const</span> Options &amp;opt, WritableFile *f)</span><br><span class="line">        : <span class="built_in">options</span>(opt),</span><br><span class="line">          <span class="built_in">index_block_options</span>(opt),</span><br><span class="line">          <span class="built_in">file</span>(f),</span><br><span class="line">          <span class="built_in">offset</span>(<span class="number">0</span>),</span><br><span class="line">          <span class="built_in">data_block</span>(&amp;options),</span><br><span class="line">          <span class="built_in">index_block</span>(&amp;index_block_options),</span><br><span class="line">          <span class="built_in">num_entries</span>(<span class="number">0</span>),</span><br><span class="line">          <span class="built_in">closed</span>(<span class="literal">false</span>),</span><br><span class="line">          <span class="built_in">filter_block</span>(opt.filter_policy == <span class="literal">nullptr</span></span><br><span class="line">                           ? <span class="literal">nullptr</span></span><br><span class="line">                           : <span class="keyword">new</span> <span class="built_in">FilterBlockBuilder</span>(opt.filter_policy)),</span><br><span class="line">          <span class="built_in">pending_index_entry</span>(<span class="literal">false</span>)</span><br><span class="line">    {</span><br><span class="line">        index_block_options.block_restart_interval = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Options options;                  <span class="comment">// 选项</span></span><br><span class="line">    Options index_block_options;      <span class="comment">// index_block的选项</span></span><br><span class="line">    WritableFile *file;               <span class="comment">// 写入的文件</span></span><br><span class="line">    <span class="type">uint64_t</span> offset;                  <span class="comment">// 偏移值</span></span><br><span class="line">    Status status;                    <span class="comment">// 状态</span></span><br><span class="line">    BlockBuilder data_block;          <span class="comment">// data_block构建器</span></span><br><span class="line">    BlockBuilder index_block;         <span class="comment">// index_block构建器</span></span><br><span class="line">    std::string last_key;             <span class="comment">// 上一个写入的key</span></span><br><span class="line">    <span class="type">int64_t</span> num_entries;              <span class="comment">// 写入的key次数</span></span><br><span class="line">    <span class="type">bool</span> closed;                      <span class="comment">// Table构建器是否关闭</span></span><br><span class="line">    FilterBlockBuilder *filter_block; <span class="comment">// 过滤器block</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We do not emit the index entry for a block until we have seen the</span></span><br><span class="line">    <span class="comment">// first key for the next data block.  This allows us to use shorter</span></span><br><span class="line">    <span class="comment">// keys in the index block.  For example, consider a block boundary</span></span><br><span class="line">    <span class="comment">// between the keys "the quick brown fox" and "the who".  We can use</span></span><br><span class="line">    <span class="comment">// "the r" as the key for the index block entry since it is &gt;= all</span></span><br><span class="line">    <span class="comment">// entries in the first block and &lt; all entries in subsequent</span></span><br><span class="line">    <span class="comment">// blocks.</span></span><br><span class="line">    <span class="comment">// 这里的原注释可以好好看一下</span></span><br><span class="line">    <span class="comment">// Invariant: r-&gt;pending_index_entry is true only if data_block is empty.</span></span><br><span class="line">    <span class="type">bool</span> pending_index_entry;   <span class="comment">// 当data_block为空时是true否则为false</span></span><br><span class="line">    BlockHandle pending_handle; <span class="comment">// 是一个为index_block添加数据时使用的handler</span></span><br><span class="line"></span><br><span class="line">    std::string compressed_output; <span class="comment">// 压缩输出</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个结构体中定义了table中包含的各个部分，这些部分没有直接在Table类中定义，是因为那样就会让Table类十分冗长，使用类内的一个结构体会清晰很多。实际上，TableBuilder类在进行构建的时候也是直接处理这个结构体的。</p>
<p>下面我们来看一下TableBuiler类的具体实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">TableBuilder::<span class="built_in">TableBuilder</span>(<span class="type">const</span> Options &amp;options, WritableFile *file)</span><br><span class="line">    : <span class="built_in">rep_</span>(<span class="keyword">new</span> <span class="built_in">Rep</span>(options, file))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (rep_-&gt;filter_block != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        rep_-&gt;filter_block-&gt;<span class="built_in">StartBlock</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">TableBuilder::~<span class="built_in">TableBuilder</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">assert</span>(rep_-&gt;closed); <span class="comment">// Catch errors where caller forgot to call Finish()</span></span><br><span class="line">    <span class="keyword">delete</span> rep_-&gt;filter_block;</span><br><span class="line">    <span class="keyword">delete</span> rep_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变TableBudiler类的选项</span></span><br><span class="line"><span class="function">Status <span class="title">TableBuilder::ChangeOptions</span><span class="params">(<span class="type">const</span> Options &amp;options)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (options.comparator != rep_-&gt;options.comparator)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">InvalidArgument</span>(<span class="string">"changing comparator while building table"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rep_-&gt;options = options;</span><br><span class="line">    rep_-&gt;index_block_options = options;</span><br><span class="line">    rep_-&gt;index_block_options.block_restart_interval = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个key-value</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">const</span> Slice &amp;value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Rep *r = rep_;</span><br><span class="line">    <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ok</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果之前有添加过，则需要保证现在的key比之前的key要大</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;num_entries &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">assert</span>(r-&gt;options.comparator-&gt;<span class="built_in">Compare</span>(key, <span class="built_in">Slice</span>(r-&gt;last_key)) &gt; <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pending_index_entry当data_block为空时是true，其实就是标识出重启点</span></span><br><span class="line">    <span class="comment">// 目的是把block加入index中</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;pending_index_entry)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">assert</span>(r-&gt;data_block.<span class="built_in">empty</span>());</span><br><span class="line">        <span class="comment">// 压缩一下key长度，这个压缩与重启点的压缩其实不冲突</span></span><br><span class="line">        r-&gt;options.comparator-&gt;<span class="built_in">FindShortestSeparator</span>(&amp;r-&gt;last_key, key);</span><br><span class="line">        std::string handle_encoding;</span><br><span class="line">        r-&gt;pending_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">        <span class="comment">// 把block中的起始位置和偏移编码后存入index，因为每个重启点处相当于datablock起点</span></span><br><span class="line">        r-&gt;index_block.<span class="built_in">Add</span>(r-&gt;last_key, <span class="built_in">Slice</span>(handle_encoding));</span><br><span class="line">        r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        r-&gt;filter_block-&gt;<span class="built_in">AddKey</span>(key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新一下参数并把key-value加入到data_block中</span></span><br><span class="line">    r-&gt;last_key.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">    r-&gt;num_entries++;</span><br><span class="line">    r-&gt;data_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果目前缓冲区数据长度比较长就持久化到文件</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> estimated_block_size = r-&gt;data_block.<span class="built_in">CurrentSizeEstimate</span>();</span><br><span class="line">    <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">Flush</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持久化到文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Rep *r = rep_;</span><br><span class="line">    <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ok</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;data_block.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">assert</span>(!r-&gt;pending_index_entry);</span><br><span class="line">    <span class="built_in">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle); <span class="comment">// 调用TableBuilder写入文件的函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">        r-&gt;status = r-&gt;file-&gt;<span class="built_in">Flush</span>(); <span class="comment">// 调用文件的持久化函数</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        r-&gt;filter_block-&gt;<span class="built_in">StartBlock</span>(r-&gt;offset); <span class="comment">// 布隆过滤器</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把Table中的Block写入文件，只是这个函数是一层封装，内部只执行了压缩步骤</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::WriteBlock</span><span class="params">(BlockBuilder *block, BlockHandle *handle)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 写入文件的格式block_data, type, crc</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">ok</span>());</span><br><span class="line">    Rep *r = rep_;</span><br><span class="line">    Slice raw = block-&gt;<span class="built_in">Finish</span>(); <span class="comment">// 拿出Block的数据</span></span><br><span class="line"></span><br><span class="line">    Slice block_contents;</span><br><span class="line">    CompressionType type = r-&gt;options.compression; <span class="comment">// 压缩类型</span></span><br><span class="line">    <span class="keyword">switch</span> (type)                                  <span class="comment">// 根据压缩类型来执行压缩</span></span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> kNoCompression: <span class="comment">// 不压缩</span></span><br><span class="line">        block_contents = raw;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> kSnappyCompression: <span class="comment">// Snappy压缩</span></span><br><span class="line">    {</span><br><span class="line">        std::string *compressed = &amp;r-&gt;compressed_output;</span><br><span class="line">        <span class="keyword">if</span> (port::<span class="built_in">Snappy_Compress</span>(raw.<span class="built_in">data</span>(), raw.<span class="built_in">size</span>(), compressed) &amp;&amp;</span><br><span class="line">            compressed-&gt;<span class="built_in">size</span>() &lt; raw.<span class="built_in">size</span>() - (raw.<span class="built_in">size</span>() / <span class="number">8u</span>))</span><br><span class="line">        {</span><br><span class="line">            block_contents = *compressed;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Snappy not supported, or compressed less than 12.5%, so just</span></span><br><span class="line">            <span class="comment">// store uncompressed form</span></span><br><span class="line">            block_contents = raw;</span><br><span class="line">            type = kNoCompression;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 调用WriteRawBlock来真正写入文件中</span></span><br><span class="line">    <span class="built_in">WriteRawBlock</span>(block_contents, type, handle);</span><br><span class="line">    r-&gt;compressed_output.<span class="built_in">clear</span>();</span><br><span class="line">    block-&gt;<span class="built_in">Reset</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::WriteRawBlock</span><span class="params">(<span class="type">const</span> Slice &amp;block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 CompressionType type, BlockHandle *handle)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Rep *r = rep_;</span><br><span class="line">    handle-&gt;<span class="built_in">set_offset</span>(r-&gt;offset);</span><br><span class="line">    handle-&gt;<span class="built_in">set_size</span>(block_contents.<span class="built_in">size</span>());</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(block_contents); <span class="comment">// 调用文件写入的函数</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="type">char</span> trailer[kBlockTrailerSize]; <span class="comment">// block的尾部由压缩类型与crc组成</span></span><br><span class="line">        trailer[<span class="number">0</span>] = type;</span><br><span class="line">        <span class="type">uint32_t</span> crc = crc32c::<span class="built_in">Value</span>(block_contents.<span class="built_in">data</span>(), block_contents.<span class="built_in">size</span>());</span><br><span class="line">        crc = crc32c::<span class="built_in">Extend</span>(crc, trailer, <span class="number">1</span>); <span class="comment">// Extend crc to cover block type</span></span><br><span class="line">        <span class="built_in">EncodeFixed32</span>(trailer + <span class="number">1</span>, crc32c::<span class="built_in">Mask</span>(crc));</span><br><span class="line">        <span class="comment">// 然后把尾部添加进文件中</span></span><br><span class="line">        r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(trailer, kBlockTrailerSize));</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;status.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            r-&gt;offset += block_contents.<span class="built_in">size</span>() + kBlockTrailerSize;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回状态</span></span><br><span class="line"><span class="function">Status <span class="title">TableBuilder::status</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> rep_-&gt;status; }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束构建</span></span><br><span class="line"><span class="function">Status <span class="title">TableBuilder::Finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Rep *r = rep_;</span><br><span class="line">    <span class="built_in">Flush</span>();</span><br><span class="line">    <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">    r-&gt;closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入filter_block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">WriteRawBlock</span>(r-&gt;filter_block-&gt;<span class="built_in">Finish</span>(), kNoCompression,</span><br><span class="line">                      &amp;filter_block_handle);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入metaindex_block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            std::string key = <span class="string">"filter."</span>;</span><br><span class="line">            key.<span class="built_in">append</span>(r-&gt;options.filter_policy-&gt;<span class="built_in">Name</span>());</span><br><span class="line">            std::string handle_encoding;</span><br><span class="line">            filter_block_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">            meta_index_block.<span class="built_in">Add</span>(key, handle_encoding);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">WriteBlock</span>(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入index_block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;pending_index_entry)</span><br><span class="line">        {</span><br><span class="line">            r-&gt;options.comparator-&gt;<span class="built_in">FindShortSuccessor</span>(&amp;r-&gt;last_key);</span><br><span class="line">            std::string handle_encoding;</span><br><span class="line">            r-&gt;pending_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">            r-&gt;index_block.<span class="built_in">Add</span>(r-&gt;last_key, <span class="built_in">Slice</span>(handle_encoding));</span><br><span class="line">            r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">WriteBlock</span>(&amp;r-&gt;index_block, &amp;index_block_handle);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入table的Footer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        Footer footer;</span><br><span class="line">        footer.<span class="built_in">set_metaindex_handle</span>(metaindex_block_handle);</span><br><span class="line">        footer.<span class="built_in">set_index_handle</span>(index_block_handle);</span><br><span class="line">        std::string footer_encoding;</span><br><span class="line">        footer.<span class="built_in">EncodeTo</span>(&amp;footer_encoding);</span><br><span class="line">        r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(footer_encoding);</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;status.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            r-&gt;offset += footer_encoding.<span class="built_in">size</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放弃构建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Abandon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Rep *r = rep_;</span><br><span class="line">    <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">    r-&gt;closed = <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add的次数</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TableBuilder::NumEntries</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> rep_-&gt;num_entries; }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件的大小</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TableBuilder::FileSize</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> rep_-&gt;offset; }</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过这个TableBuilder类，我们就可以很清晰地看出一个Table是怎么构建的了。下面给出构建一个Table的流程。</p>
<ul>
<li>TableBuilder类首先在类内创建出各类BlockBuilder，包括dataBlock，metadataBlock，filterBlock等等。</li>
<li>然后当每次需要插入一个key时就会调用TableBuilder的add方法，这个方法会自动负责处理index_block、重启点、filter_block以及对每个key进行长度压缩(这个压缩不是共享key，而是调用comparator中的FindShortestSeparator方法)。另外TableBuilder类插入key-value会首先写入内存中，只有当内存部分的大小超过一定长度才会写持久化到硬盘。</li>
<li>Flush函数负责将目前的数据区追加写到磁盘中，它会调用WriteBlock函数，注意Flush不会把非data_block的block持久化。</li>
<li>WriteBlock函数是对WriteRawBlock函数的封装。它主要是处理了数据压缩的部分，然后把压缩后的数据和压缩类型以及数据的crc校验码传递给WriteRawBlock函数。</li>
<li>WriteRawBlock函数是真正写入数据的函数，每个Block都由数据区和偏置区、压缩类型以及crc校验组成。</li>
<li>当一个table完成构建时就会调用finish函数，这个函数会负责追加写filter_block、metaindex_block、index_block和Footer。其中写入每个Block时会调用对应handler的encode函数来将每个block编码成字符串。</li>
</ul>
<p>我们继续来审视一下SSTable和Block的结构图，这样我们会更加清楚其结构。</p>
<img src="/2022/09/27/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-8/pic1.jpg" class="">
<img src="/2022/09/27/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-8/pic2.jpg" class="">
<h2 id="总结">总结</h2>
<p>不得不说，Block的统一的设计还是非常的巧妙，所有的Block结构都是一样的，只是提供了统一的接口(Add)，内部设计包含了key的前缀压缩、偏置区、重启点等等优化设计。而filterBlock和IndexBlock等等也是包含这些偏置区和重启点的，可能会感觉有些奇怪，因为这些存储的都是过滤器或者是索引。但是由于我们不需要关心这些内部的细节，所以可以看成是数据结构内部优化即可。</p>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>从ucore来总结操作系统(2)----物理内存、虚拟内存、转换</title>
    <url>/2023/01/16/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/</url>
    <content><![CDATA[<h2 id="物理内存虚拟内存转换">物理内存、虚拟内存、转换</h2>
<span id="more"></span>
<p>这篇是lab2的内容，主要就是实操一下页表和段页式的虚拟内存管理机制。</p>
<h3 id="x00-环境准备">0X00 环境准备</h3>
<p>首先，lab2是基于lab1的，所以需要把lab1的内容合并到lab2中，这里就不赘述了。</p>
<p>在正式开始编程之前，还是有必要来了解下ucore中已有的代码和机制。</p>
<p>本lab中，我们需要修改<code>defalult_pmm.c</code>中的default_init,default_init_memmap,default_alloc_pages,
default_free_pages这些函数来完成相应的功能。</p>
<p><strong>当ucore被启动之后，最重要的事情就是知道还有多少内存可用</strong>，一般来说，获取内存大小的方法由<em>BIOS中断调用</em>和<em>直接探测</em>两种。BIOS中断调用方法是一般只能在实模式下完成，而直接探测方法必须在保护模式下完成。ucore是通过BIOS中断调用来帮助完成的，由于BIOS中断调用必须在实模式下进行，所以在bootloader进入保护模式前完成这部分工作相对比较合适。通过BIOS中断获取内存可调用参数为e820h的INT
15h BIOS中断，BIOS通过系统内存映射地址描述符（Address Range
Descriptor）格式来表示系统物理内存布局。</p>
<p>探测功能在bootasm.S中实现，使用<code>INT 15</code>软中断来要求BIOS返回系统内存布局信息，然后把探查出来的信息存放在物理地址0x8000中，程序使用结构体struct
e820map作为保存地址范围描述符结构的缓冲区来保存内存布局，e820map定义在<code>kern/mm/memlayout.h</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// some constants for bios interrupt 15h AX = 0xE820</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E820MAX             20      <span class="comment">// number of entries in E820MAP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E820_ARM            1       <span class="comment">// address range memory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E820_ARR            2       <span class="comment">// address range reserved</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> {</span></span><br><span class="line">    <span class="type">int</span> nr_map;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">        <span class="type">uint64_t</span> addr;</span><br><span class="line">        <span class="type">uint64_t</span> size;</span><br><span class="line">        <span class="type">uint32_t</span> type;</span><br><span class="line">    } __attribute__((packed)) <span class="built_in">map</span>[E820MAX];</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>完成物理内存页管理初始化工作后，其物理地址的分布空间如下</strong></p>
<img src="/2023/01/16/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/pic1.png" class="">
<p><strong>在获得可用物理内存范围后，系统需要建立相应的数据结构来管理以物理页（按4KB对齐，且大小为4KB的物理内存单元）为最小单位的整个物理内存，以配合后续涉及的分页管理机制。</strong>每个物理页可以用一个Page数据结构来表示。Page定义在<code>kern/mm/memlayout.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * struct Page - Page descriptor structures. Each Page describes one</span></span><br><span class="line"><span class="comment"> * physical page. In kern/mm/pmm.h, you can find lots of useful functions</span></span><br><span class="line"><span class="comment"> * that convert Page to other data types, such as phyical address.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> {</span></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> ref;                        <span class="comment">// page frame's reference counter</span></span><br><span class="line">    <span class="comment">// 用两个bit表示两种属性</span></span><br><span class="line">    <span class="comment">// 1. PG_reserved位 此位为1时表示该页是内核保留的，不可分配</span></span><br><span class="line">    <span class="comment">// 2. PG_property位 此位为1时表示可分配，为0表示已分配</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;                 <span class="comment">// array of flags that describe the status of the page frame</span></span><br><span class="line">    <span class="comment">// 空闲块大小(以物理页位大小)，仅在当前页是空闲块的第一个物理页时有效</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> property;          <span class="comment">// the num of free block, used in first fit pm manager</span></span><br><span class="line">    <span class="type">list_entry_t</span> page_link;         <span class="comment">// free list link</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="x01-实现-first-fit-连续物理内存分配算法">0X01 实现 first-fit
连续物理内存分配算法</h3>
<p>这里的first-fit算法就是从物理内存的起始地址开始，找到第一个满足要求的空闲块，然后分配给进程。这里的要求就是空闲块的大小要大于等于需要分配的大小。空闲链表需要按照地址从低到高的次序排序。<strong>实验一要求实验的函数是分配物理内存的。</strong></p>
<p>其实，lab2自带的default_init_memmap、default_alloc_pages、default_free_pages实现了一个类似first
fit的算法，<strong>只不过直接<code>make qemu</code>会发现报错，我们可以直接在这基础上进行修改。</strong></p>
<p>同时，在<code>libs/list.h</code>已经定义好了双向链表；在<code>kern/mm/memlayout.h</code>中也定义了一个free_area_t的数据结构，包括<strong>空闲块双向链表的头</strong>和<strong>空闲块总数(以页为单位)</strong>；<code>kern/mm/pmm.h</code>中定义了一个通用的分配算法的函数列表，用pmm_manager表示，<strong>一个pmm_manager就是一个分配算法</strong>。其中init函数就是用来初始化free_area变量的,
first_fit分配算法可直接重用default_init函数的实现。init_memmap函数需要根据现有的内存情况构建空闲块列表的初始状态。</p>
<p>而这些<strong>函数的调用栈</strong>如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kern_init --&gt; pmm_init--&gt;page_init--&gt;init_memmap--&gt; pmm_manager-&gt;init_memmap</span><br></pre></td></tr></table></figure>
<p>而kern_init(内核初始化)、pmm_init(内存初始化)、page_init(读取物理内存，并进行分页)都已经实现了，所以我们首先从init_memmap开始看。</p>
<p>init_memmap(<strong>在此处其实就是default_init_memmap</strong>)需要根据page_init传递的参数，来建立连续内存的空闲块双向链表。<strong>链表头是free_area.free_list，链表项是Page数据结构的base-&gt;page_link。这样我们就依靠Page数据结构中的成员变量page_link形成了连续内存空闲块列表。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// kern/mm/default_pmm.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">default_init_memmap</span><span class="params">(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n)</span></span><br><span class="line">{</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p++)</span><br><span class="line">    { </span><br><span class="line">        <span class="comment">// 在查找可用内存并分配struct Page数组时</span></span><br><span class="line">        <span class="comment">// 就已经将将全部Page设置为reserved(page_init里)</span></span><br><span class="line">        <span class="comment">// 这里确保之前的初始化正确</span></span><br><span class="line">        assert(PageReserved(p));</span><br><span class="line">        <span class="comment">// 将Page标记为可用的:ref设为0,清除reserved,</span></span><br><span class="line">        <span class="comment">// 设置PG_property,并把property设置为0(不是空闲块的第一个物理页)</span></span><br><span class="line">        p-&gt;flags = p-&gt;property = <span class="number">0</span>; </span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 空闲块第一个物理页,property设置为n</span></span><br><span class="line">    base-&gt;property = n; </span><br><span class="line">    <span class="comment">// 设置空闲块的标志位</span></span><br><span class="line">    SetPageProperty(base);</span><br><span class="line">    <span class="comment">// 更新空闲块的总和</span></span><br><span class="line">    nr_free += n;        </span><br><span class="line">    <span class="comment">//'p-&gt;page_link'将这个页面链接到'free_list'。 </span></span><br><span class="line">               </span><br><span class="line">    list_add_after(&amp;free_list, &amp;(base-&gt;page_link)); </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是一个物理页初始化函数，其功能是将所有可用的Page的flags设置为PG_property，引用计数设置为0，property设置为0，初始化page_link空闲块的第一个物理块的property设置为该空闲块的大小，将其加入到空闲列表。<strong>每次调用会把一个实际的物理块加入到空闲区块中</strong>。由于需要保证升序，所以需要使用list_add_after函数(测试下来只有一个块，又因为是双向链表，其实不影响的)。</p>
<p>然后我们来考虑一下页面分配函数，即default_alloc_pages函数，<strong>它的作用是在空闲列表中搜索第一个空闲块(块大小&gt;=n)，如果找到则把找到的page返回。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// kern/mm/default_pmm.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> Page *<span class="title function_">default_alloc_pages</span><span class="params">(<span class="type">size_t</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 确保能够分配</span></span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; nr_free)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 从空闲链表中找到第一个能够分配的块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">    <span class="comment">// 一直查找下去，直到回到头部</span></span><br><span class="line">    <span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 通过list_entry_t来获取page</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> le2page(le, page_link);</span><br><span class="line">        <span class="comment">// 检查p-&gt;property(记录这个块中空闲物理页的数量)是否&gt;=n.</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;property &gt;= n)</span><br><span class="line">        {</span><br><span class="line">            page = p;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果找到符合要求的空闲块</span></span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果空闲块非常大，就要切割</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;property &gt; n)</span><br><span class="line">        {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> page + n;</span><br><span class="line">            p-&gt;property = page-&gt;property - n;</span><br><span class="line">            <span class="comment">// 然后把剩下的空闲块加入到空闲链表中</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            但是此处要注意保证按照地址升序排列</span></span><br><span class="line"><span class="comment">            原始代码此处是不正确的，此处已修正</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            SetPageProperty(p);</span><br><span class="line">            <span class="comment">// 把切割的后半部分插入到原来的块后面</span></span><br><span class="line">            list_add_after(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 然后从空闲链表中删除这个块</span></span><br><span class="line">        list_del(&amp;(page-&gt;page_link));</span><br><span class="line">        <span class="comment">// 更新参数，并保证分配出去的块标志位正确</span></span><br><span class="line">        nr_free -= n;</span><br><span class="line">        ClearPageProperty(page);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实就是遍历一下双向链表，注意一下对空闲块分割后同样需要按照升序插入即可。</p>
<p>还有一个函数是default_free_pages，其作用是将物理页释放，即将物理页加入到空闲链表中。这个函数会稍微麻烦一点，毕竟会涉及到空闲块的合并</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">default_free_pages</span><span class="params">(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n)</span></span><br><span class="line">{</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="comment">// 清除每页的标志位和引用计数</span></span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p++)</span><br><span class="line">    {</span><br><span class="line">        assert(!PageReserved(p) &amp;&amp; !PageProperty(p));</span><br><span class="line">        p-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随后将空闲页加入到空闲链表中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置头页</span></span><br><span class="line">    base-&gt;property = n;</span><br><span class="line">    SetPageProperty(base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历空闲链表，将空闲页合并</span></span><br><span class="line">    <span class="type">list_entry_t</span> *le = list_next(&amp;free_list);</span><br><span class="line">    <span class="keyword">while</span> (le != &amp;free_list)</span><br><span class="line">    {</span><br><span class="line">        p = le2page(le, page_link);</span><br><span class="line">        le = list_next(le);</span><br><span class="line">        <span class="comment">// 如果p页的地址刚好紧接在以base页开头的空闲块之后</span></span><br><span class="line">        <span class="comment">// 就把base页和p页合并</span></span><br><span class="line">        <span class="keyword">if</span> (base + base-&gt;property == p)</span><br><span class="line">        {</span><br><span class="line">            base-&gt;property += p-&gt;property;</span><br><span class="line">            ClearPageProperty(p);</span><br><span class="line">            list_del(&amp;(p-&gt;page_link));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果p页的地址刚好紧接在以base页开头的空闲块之前</span></span><br><span class="line">        <span class="comment">// 就把p页和base页合并</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p + p-&gt;property == base)</span><br><span class="line">        {</span><br><span class="line">            p-&gt;property += base-&gt;property;</span><br><span class="line">            ClearPageProperty(base);</span><br><span class="line">            base = p;</span><br><span class="line">            list_del(&amp;(p-&gt;page_link));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 至此，就将所有与base开头的块合并完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新一下空闲页的数量</span></span><br><span class="line">    nr_free += n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    同样，这里原函数也是不正确的</span></span><br><span class="line"><span class="comment">    需要寻找到合适的位置插入base，而不能直接在前面插入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    le = list_next(&amp;free_list);</span><br><span class="line">    <span class="keyword">while</span> (le != &amp;free_list)</span><br><span class="line">    {</span><br><span class="line">        p = le2page(le, page_link); <span class="comment">// 将空闲列表条目转换为页面</span></span><br><span class="line">        <span class="keyword">if</span> (base + base-&gt;property &lt;= p)</span><br><span class="line">        { <span class="comment">// 地址大小由空闲块大小来表示</span></span><br><span class="line">            assert(base + base-&gt;property != p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        le = list_next(le);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    list_add_before(le, &amp;(base-&gt;page_link));</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个函数首先要清除页面的各种标志位和引用计数，从而保证每一页都可以直接被分配。随后将空闲页加入到空闲链表中，合并分两种情况进行，一种是base页的地址刚好紧接在以base页开头的空闲块之后，另一种是p页的地址刚好紧接在以base页开头的空闲块之前。最后更新空闲页的数量，然后寻找到合适的位置插入base，而不能直接在前面插入。</p>
<p>修改完成后，输入<code>make qemu</code>即可看到第一项测试通过。</p>
<h3 id="x02-实现寻找虚拟地址对应的页表项">0X02
实现寻找虚拟地址对应的页表项</h3>
<p>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。其中的get_pte函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。本练习需要补全get_pte函数，位于
<code>kern/mm/pmm.c</code>，实现其功能。get_pte函数的调用关系图如下所示：</p>
<img src="/2023/01/16/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/pic2.png" class="">
<p>本实验要求实现一个get_pte函数，<strong>此函数找到一个虚拟地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表(要认识到页表二级页表也在内存中)</strong>。</p>
<p>就是给定一个虚拟地址，返回下图中红框(即PTE)在内存中地址(也是虚拟地址)。</p>
<img src="/2023/01/16/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/pic3.0.jpg" class="">
<p>Intel
80386采用了二级页表来建立线性地址与物理地址之间的映射关系。由于我们已经具有了一个物理内存页管理器default_pmm_manager，支持动态分配和释放内存页的功能，我们就可以用它来获得所需的空闲物理页。在二级页表结构中，<strong>页目录表占4KB空间，可通过alloc_page函数获得一个空闲物理页作为页目录表</strong>（Page
Directory Table，PDT）。同理，ucore也通过这种类似方式获得一个页表（Page
Table，PT）所需的4KB空间。</p>
<div class="note primary">
            <p>在保护模式中，x86体系结构将内存地址分成三种：<strong>逻辑地址（也称虚拟地址）、线性地址和物理地址。</strong></p><ul><li>段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势。</li><li>在段式存储管理基础上，给每个段加一级页表。同时，通过指向相同的页表基址，实现进程间的段共享。</li><li>在段页式管理中，操作系统弱化了段式管理中的功能，实现以分页为主的内存管理。段式管理只起到了一个过滤的作用，它将地址不加转换直接映射成线性地址。<strong>将虚拟地址转换为物理地址的过程如下</strong>：<ul><li>根据段寄存器中的段选择子，获取GDT中的特定基址并加上目标偏移来确定<strong>线性地址</strong>。由于GDT中所有的基址全为0（因为弱化了段式管理的功能，对等映射），所以此时的逻辑地址和线性地址是相同的。</li><li>根据该线性地址，获取对应页表项，并根据该页表项来获取对应的<strong>物理地址</strong>。</li></ul></li></ul><p><strong>一级页表（页目录表PageDirectoryTable,PDT）的起始地址存储于%cr3寄存器中。</strong></p><p><img src="/2023/01/16/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/pic3.jpg" class=""></p>
          </div>
<p>在一个简单的两级页表中，页目录为每页页表包含了一项。它由多个<strong>页目录项</strong>（Page
Directory Entries，PDE）组成。PDE（至少）拥有有效位（valid
bit）和页帧号（page frame number，PFN），类似于
PTE。但是，正如上面所暗示的，这个有效位的含义稍有不同：<strong>如果 PDE
项是有效的，则意味着该项指向的页表（通过PFN）中至少有一页是有效的</strong>，即在该
PDE 所指向的页中，至少一个PTE，其有效位被设置为1。如果 PDE
项无效（即等于零），则 PDE的其余部分没有定义。</p>
<p><strong>一个线性地址对应的各个页表项如下</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A linear address 'la' has a three-part structure as follows:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +--------10------+-------10-------+---------12----------+</span></span><br><span class="line"><span class="comment">// | Page Directory |   Page Table   | Offset within Page  |</span></span><br><span class="line"><span class="comment">// |      Index     |     Index      |                     |</span></span><br><span class="line"><span class="comment">// +----------------+----------------+---------------------+</span></span><br><span class="line"><span class="comment">//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span></span><br><span class="line"><span class="comment">//  \----------- PPN(la) -----------/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The PDX, PTX, PGOFF, and PPN macros decompose linear addresses as shown.</span></span><br><span class="line"><span class="comment">// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),</span></span><br><span class="line"><span class="comment">// use PGADDR(PDX(la), PTX(la), PGOFF(la)).</span></span><br></pre></td></tr></table></figure>
<p>由于get_pte函数中给出了详细的步骤注释，我们直接给出代码</p>
<p><strong>注意，PTE内容的设置是调用者的职责，get_pte只需要给调用者一个可访问的PTE(page
table entry)即可。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// get_pte - get pte and return the kernel virtual address of this pte for la</span></span><br><span class="line"><span class="comment">//         - if the PT contians this pte didn't exist, alloc a page for PT</span></span><br><span class="line"><span class="comment">//  parameter:</span></span><br><span class="line"><span class="comment">//   pgdir:  the kernel virtual base address of PDT</span></span><br><span class="line"><span class="comment">//   la:     the linear address need to map</span></span><br><span class="line"><span class="comment">//   create: a logical value to decide if alloc a page for PT</span></span><br><span class="line"><span class="comment">//  return vaule: the kernel virtual address of this pte</span></span><br><span class="line"><span class="comment">// pgdir是页目录 la是线性地址(虚拟地址) create是是否新建</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">get_pte</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> la, <span class="type">bool</span> create)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 这部分懒得翻译了，就是说了几个有用的宏</span></span><br><span class="line">    <span class="comment">/* LAB2 EXERCISE 2: YOUR CODE</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you need to visit a physical address, please use KADDR()</span></span><br><span class="line"><span class="comment">     * please read pmm.h for useful macros</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Maybe you want help comment, BELOW comments can help you finish the code</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   PDX(la) = the index of page directory entry of VIRTUAL ADDRESS la.</span></span><br><span class="line"><span class="comment">     *   KADDR(pa) : takes a physical address and returns the corresponding kernel virtual address.</span></span><br><span class="line"><span class="comment">     *   set_page_ref(page,1) : means the page be referenced by one time</span></span><br><span class="line"><span class="comment">     *   page2pa(page): get the physical address of memory which this (struct Page *) page  manages</span></span><br><span class="line"><span class="comment">     *   struct Page * alloc_page() : allocation a page</span></span><br><span class="line"><span class="comment">     *   memset(void *s, char c, size_t n) : sets the first n bytes of the memory area pointed by s</span></span><br><span class="line"><span class="comment">     *                                       to the specified value c.</span></span><br><span class="line"><span class="comment">     * DEFINEs:</span></span><br><span class="line"><span class="comment">     *   PTE_P           0x001                   // page table/directory entry flags bit : Present</span></span><br><span class="line"><span class="comment">     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable</span></span><br><span class="line"><span class="comment">     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">// 1. 先在一级页表中查找二级页表的地址</span></span><br><span class="line">    <span class="comment">// 一级页表中每一项都是PDE(page directory entry)</span></span><br><span class="line">    <span class="comment">// 指向一个二级页表</span></span><br><span class="line">    <span class="type">pde_t</span> *pdep = pgdir[PDX(la)]; <span class="comment">// (1) find page directory entry</span></span><br><span class="line">    <span class="comment">// 2. 如果获取到的二级页表无效，那么就要创建一个有效的出来</span></span><br><span class="line">    <span class="keyword">if</span> (!(*pdep &amp; PTE_P))</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (create) <span class="comment">// (2) check if entry is not present</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 3. 调用物理分配器分配一个物理页</span></span><br><span class="line">            p = alloc_pages(<span class="number">1</span>); <span class="comment">// (3) check if creating is needed, then alloc page for page table</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// CAUTION: this page is used for page table, not for common data page</span></span><br><span class="line">        <span class="comment">// 4. 设置页面的引用计数为1</span></span><br><span class="line">        set_page_ref(p, <span class="number">1</span>); <span class="comment">// (4) set page reference</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 获取物理页的物理地址</span></span><br><span class="line">        <span class="type">uintptr_t</span> pa = page2pa(p); <span class="comment">// (5) get linear address of page</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 清空物理页的内容，需要注意的是使用虚拟地址</span></span><br><span class="line">        <span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE); <span class="comment">// (6) clear page content using memset</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 将新分配的页面设置为当前缺失的页目录条目中,之后该页面就是其中的一个二级页面</span></span><br><span class="line">        *pdep = pa | PTE_U | PTE_W | PTE_P; <span class="comment">// (7) set page directory entry's permission</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 8. 返回在pgdir中对应于la的二级页表项(pte)</span></span><br><span class="line">    <span class="keyword">return</span> &amp;((<span class="type">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)]; <span class="comment">// (8) return page table entry</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>其实我一开始对这里的虚拟地址和物理地址交替出现感到挺奇怪的，后来查阅了一下《操作系统真象还原》，因此给出自己的理解。</p><p>首先，<strong>即使在保护模式下，CPU总线上放的地址也是32位的物理地址</strong>。</p><p>在打开保护模式后，CPU会将页表地址加载到cr3寄存器中，这个地址存储的是<strong>物理地址</strong>，目的是方便直接送入CPU的总线中。</p><p>虽然内存分页机制是将虚拟地址转换成物理地址，但是在转换过程中相当于在关闭分页机制下进行，<strong>所有的页表和页表项的寻址，他们的地址都会被CPU当成最终的物理地址，直接送上总线，不会再被分页机制转换</strong>(否则因此递归转换)</p><p>但是有的时候，<strong>需要修改页表，程序访问页表的时候需要使用页表的虚拟地址</strong>，这种是通过自映射的方式实现的。</p>
          </div>
<p>这里涉及到三个类型pte_t、pde_t和uintptr_t。通过参见<code>mm/mmlayout.h</code>和<code>libs/types.h</code>，可知它们其实都是unsigned
int类型。在此做区分，是为了分清概念。</p>
<p>pde_t全称为 page directory
entry，也就是<strong>一级页表的表项</strong>（注意：pgdir实际不是表项，而是一级页表本身。实际上应该新定义一个类型pgd_t来表示一级页表本身）。pte_t全称为
page table
entry，表示<strong>二级页表的表项</strong>。uintptr_t表示为线性地址，由于段式管理只做直接映射，所以它也是逻辑地址。</p>
<p>pgdir给出页表起始地址。通过查找这个页表，我们需要给出二级页表中对应项的地址。虽然目前我们只有boot_pgdir一个页表，但是引入进程的概念之后每个进程都会有自己的页表。</p>
<p>有可能根本就没有对应的二级页表的情况，所以二级页表不必要一开始就分配，而是等到需要的时候再添加对应的二级页表。如果在查找二级页表项时，发现对应的二级页表不存在，则需要根据create参数的值来处理是否创建新的二级页表。如果create参数为0，则get_pte返回NULL；如果create参数不为0，则get_pte需要申请一个新的物理页，再在一级页表中添加页目录项指向表示二级页表的新物理页。注意，新申请的页必须全部设定为零，因为这个页所代表的虚拟地址都没有被映射。</p>
<p>当建立从一级页表到二级页表的映射时，需要注意设置控制位。这里应该设置同时设置上PTE_U、PTE_W和PTE_P。如果原来就有二级页表，或者新建立了页表，则只需返回对应项的地址即可。</p>
<p>虚拟地址只有映射上了物理页才可以正常的读写。在完成映射物理页的过程中，除了要像上面那样在页表的对应表项上填上相应的物理地址外，还要设置正确的控制位。</p>
<h3 id="x03-实现释放某虚地址所在的页并取消对应二级页表项的映射">0X03
实现释放某虚地址所在的页并取消对应二级页表项的映射</h3>
<p>当释放一个包含某虚地址的物理内存页时，需要让对应此物理内存页的管理数据结构Page做相关的清除处理，使得此物理内存页成为空闲；另外还需把表示虚地址与物理地址对应关系的二级页表项清除。请仔细查看和理解page_remove_pte函数中的注释。为此，需要补全在
<code>kern/mm/pmm.c</code>中的page_remove_pte函数。</p>
<p>刚才的实验是为了创建一个PTE项，现在的任务是删除一个PTE项。</p>
<p>因为和之前的实验类似，而且注释非常全，难度很低，对着弄就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// page_remove_pte - free an Page sturct which is related linear address la</span></span><br><span class="line"><span class="comment">//                 - and clean(invalidate) pte which is related linear address la</span></span><br><span class="line"><span class="comment">// note: PT is changed, so the TLB need to be invalidate</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">page_remove_pte</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> la, <span class="type">pte_t</span> *ptep)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* LAB2 EXERCISE 3: YOUR CODE</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Please check if ptep is valid, and tlb must be manually updated if mapping is updated</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Maybe you want help comment, BELOW comments can help you finish the code</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   struct Page *page pte2page(*ptep): get the according page from the value of a ptep</span></span><br><span class="line"><span class="comment">     *   free_page : free a page</span></span><br><span class="line"><span class="comment">     *   page_ref_dec(page) : decrease page-&gt;ref. NOTICE: ff page-&gt;ref == 0 , then this page should be free.</span></span><br><span class="line"><span class="comment">     *   tlb_invalidate(pde_t *pgdir, uintptr_t la) : Invalidate a TLB entry, but only if the page tables being</span></span><br><span class="line"><span class="comment">     *                        edited are the ones currently in use by the processor.</span></span><br><span class="line"><span class="comment">     * DEFINEs:</span></span><br><span class="line"><span class="comment">     *   PTE_P           0x001                   // page table/directory entry flags bit : Present</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 先检查输入的pte是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!(*ptep &amp; PTE_P)) <span class="comment">//(1) check if this page table entry is present</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通过对应pte找到对应的page</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep); <span class="comment">//(2) find corresponding page to pte</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 减少page的引用计数</span></span><br><span class="line">    page_ref_dec(page); <span class="comment">//(3) decrease page reference</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 如果引用计数为0 释放page</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;ref == <span class="number">0</span>)</span><br><span class="line">        free_page(page); <span class="comment">//(4) and free this page when page reference reachs 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 清除pte</span></span><br><span class="line">    *ptep = <span class="number">0</span>; <span class="comment">//(5) clear second page table entry</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 刷新tlb</span></span><br><span class="line">    tlb_invalidate(pgdir, la); <span class="comment">//(6) flush tlb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="页表自映射">页表自映射</h4>
<p>由于页表本身也是一个物理内存块，所有页表可以有一个项指向自身，一级页表和二级页表都有。更具体的可以参考这篇文章<a href="https://blog.csdn.net/qq_41453285/article/details/108170100">页表自映射</a>。</p>
<img src="/2023/01/16/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/pic4.png" class="">
<p><strong>页表自映射(这是一种设计手段)主要是为了保证能通过虚拟地址来访问页表。</strong></p>
<p>正常页表里放的都是物理地址(一级页表里放的都是二级页表物理地址，二级页表放的是页面的物理地址)。但是程序有时候需要通过虚拟地址来访问页表，比如在页表中查找某个虚拟地址对应的页表项，这时候就需要页表自映射。</p>
<p>通过虚拟地址访问一级页表：</p>
<ul>
<li>首先程序使用一级页表的虚拟地址访问</li>
<li>由于CPU本身就有寄存器存放一级页表物理地址，但是为了保证访问页表和其他页面的过程一致性，所以还是会通过页部件进行转换</li>
<li>页部件尝试从虚拟地址的第一段找出目标页面的二级页表地址，但由于一级页表自映射，所以得到的"二级页表"仍然是一级页表本身</li>
<li>然后页部件把从虚拟地址第二段找出目标页面的在"二级页表"的位置，同样还是一级页表自映射，相当于重复了一下操作(保证过程一致性)</li>
</ul>
<p>通过虚拟地址访问二级页表：</p>
<ul>
<li>首先程序使用二级页表的虚拟地址访问</li>
<li>页部件从虚拟地址的第一段找出目标页面的二级页表地址，此时正常页面一样，会得到二级页表的物理地址(此时就已经得到了目标二级页表物理地址)</li>
<li>然后页部件把从虚拟地址第二段找出目标页面的在二级页表的位置，此时二级页表自映射，得到二级页表物理地址</li>
</ul>
<h3 id="x04-总结">0X04 总结</h3>
<p>通过这个lab2，我们学习了以下内容:</p>
<ul>
<li>探测可用物理内存，并组织成块，实现函数来分配和释放物理内存块</li>
<li>一二级页表、实现函数来寻找二级页表项</li>
<li>理解页表中的项均为物理地址，但是同时页表还需要虚拟地址用于修改</li>
<li>理解保护模式在硬件上的组织(32位地址线、页表寄存器、地址检查)和软件上的组织(虚拟地址、页表)，所有在总线上的地址都是物理地址</li>
<li>页表自映射、页表虚拟地址和物理地址对应关系</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>ucore操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>从ucore来总结操作系统(3)----页面置换与Page Fault</title>
    <url>/2023/01/18/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3/</url>
    <content><![CDATA[<h2 id="页面置换与page-fault">页面置换与Page Fault</h2>
<span id="more"></span>
<p>这篇是lab3的内容，主要就是实操一下页面置换算法和当缺页发生时的处理。</p>
<h3 id="x00-环境准备">0X00 环境准备</h3>
<p>lab3也是基于lab2和lab1的，所以我们先用meld工具把lab2(lab2是包含lab1的)合并到lab3中已有的文件上。</p>
<p>在lab2中，我们已经能够<strong>管理物理内存</strong>了(组织成块，并提供first
fit分配算法、实现虚拟地址映射到PTE上)，有关内存的数据结构和相关操作都是直接针对实际存在的资源--物理内存空间的管理，没有从一般应用程序对内存的“需求”考虑，即需要有相关的数据结构和操作来体现一般应用程序对虚拟内存的“需求”。<strong>一般应用程序的对虚拟内存的“需求”与物理内存空间的“供给”没有直接的对应关系</strong>，ucore是通过page
fault异常处理来间接完成这二者之间的衔接。因此，在lab3中，将进一步实现虚拟内存的缺页中断和页面置换。</p>
<p>比如程序可以预先申请出一些内存，但是操作系统并不分配，直到程序用到这些内存所在的页面时，操作系统才通过page
fault异常来分配(linux下的写时分配)。</p>
<p>但是<strong>page_fault函数不知道哪些是“合法”的虚拟页</strong>，原因是ucore还缺少一定的数据结构来描述这种不在物理内存中的“合法”虚拟页。为此ucore通过建立<strong>mm_struct</strong>和<strong>vma_struct</strong>数据结构，描述了ucore模拟应用程序运行所需的合法内存空间。当访问内存产生page
fault异常时，可获得访问的内存的方式（读或写）以及具体的虚拟内存地址，这样ucore就可以查询此地址，看是否属于vma_struct数据结构中描述的合法地址范围中，如果在，则可根据具体情况进行请求调页/页换入换出处理（这就是练习2涉及的部分）；如果不在，则报错。mm_struct和vma_struct数据结构结合页表表示虚拟地址空间和物理地址空间的示意图如下所示：</p>
<img src="/2023/01/18/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3/pic1.png" class="">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 描述一个进程的虚拟地址空间 每个进程的 pcb 中 会有一个指针指向本结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 链接同一页目录表的虚拟内存空间 的 双向链表的 头节点</span></span><br><span class="line">    <span class="type">list_entry_t</span> mmap_list;</span><br><span class="line">    <span class="comment">// 当前正在使用的虚拟内存空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span></span><br><span class="line">    <span class="comment">// mm_struct 所维护的页表地址(拿来找 PTE)</span></span><br><span class="line">    <span class="comment">// 通过访问pgdir可以查找某虚拟地址对应的页表项是否存在以及页表项的属性等</span></span><br><span class="line">    <span class="type">pde_t</span> *pgdir;</span><br><span class="line">    <span class="comment">// 虚拟内存块的数目</span></span><br><span class="line">    <span class="type">int</span> map_count;</span><br><span class="line">    <span class="comment">// 记录访问情况链表头地址(用于置换算法)</span></span><br><span class="line">    <span class="type">void</span> *sm_priv;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟内存空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 虚拟内存空间属于的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span></span><br><span class="line">    <span class="comment">// 连续地址的虚拟内存空间的起始位置和结束位置</span></span><br><span class="line">    <span class="type">uintptr_t</span> vm_start;</span><br><span class="line">    <span class="type">uintptr_t</span> vm_end;</span><br><span class="line">    <span class="comment">// 虚拟内存空间的属性 (读/写/执行)</span></span><br><span class="line">    <span class="type">uint32_t</span> vm_flags;</span><br><span class="line">    <span class="comment">// 双向链表 从小到大将虚拟内存空间链接起来</span></span><br><span class="line">    <span class="type">list_entry_t</span> list_link;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note primary">
            <p>mm_struct应该是整个进程的虚拟内存描述表，记录了整个进程所拥有的虚拟地址</p><p>vma_struct是描述了一个有效的虚拟内存空间的信息，比如虚拟内存空间的起始地址、结束地址、属性等。</p><p>由于进程的虚拟空间是固定的，所以只有一个mm_struct；但是进程的占用的虚拟空间是可以是不连续的、分块的，所以一个mm_struct可以包含多个vma_struct。</p>
          </div>
<p><strong>对于vma_struct</strong>，vm_start和vm_end描述了一个连续地址的虚拟内存空间的起始位置和结束位置，这两个值都应该是PGSIZE
对齐的，而且描述的是一个合理的地址空间范围（即严格确保 vm_start &lt;
vm_end的关系）；list_link是一个双向链表，按照从小到大的顺序把一系列用vma_struct表示的虚拟内存空间链接起来，并且还要求这些链起来的vma_struct应该是不相交的，即vma之间的地址空间无交集；vm_flags表示了这个虚拟内存空间的属性，有只读、可读写、可执行。vm_mm是一个指针，指向一个比vma_struct更高的抽象层次的数据结构mm_struct，这里把一个mm_struct结构的变量简称为mm变量。</p>
<p><strong>对于mm_struct</strong>，这个数据结构表示了包含所有虚拟内存空间的共同属性。其中，mmap_list是双向链表头，链接了所有属于同一页目录表的虚拟内存空间(目前只有一个目录表PDT)，mmap_cache是指向当前正在使用的虚拟内存空间，由于操作系统执行的“局部性”原理，当前正在用到的虚拟内存空间在接下来的操作中可能还会用到，这时就不需要查链表，而是直接使用此指针就可找到下一次要用到的虚拟内存空间。由于mmap_cache
的引入，可使得 mm_struct 数据结构的查询加速 30% 以上。pgdir 所指向的就是
mm_struct数据结构所维护的页表。通过访问pgdir可以查找某虚拟地址对应的页表项是否存在以及页表项的属性等。map_count记录mmap_list
里面链接的
vma_struct的个数。sm_priv指向用来链接记录页访问情况的链表头，这建立了mm_struct和后续要讲到的swap_manager之间的联系。</p>
<p><strong>总而言之就是 mm_struct 描述了整个进程的虚拟地址空间 而
vma_struct 描述了 进程中的一小部分虚拟内存空间</strong></p>
<p>除此之外，page页面结构体页新增了两个成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> {</span></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> ref;                        <span class="comment">// page frame's reference counter</span></span><br><span class="line">    <span class="comment">// 用两个bit表示两种属性</span></span><br><span class="line">    <span class="comment">// 1. PG_reserved位 此位为1时表示该页是内核保留的，不可分配</span></span><br><span class="line">    <span class="comment">// 2. PG_property位 此位为1时表示可分配，为0表示已分配</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;                 <span class="comment">// array of flags that describe the status of the page frame</span></span><br><span class="line">    <span class="comment">// 空闲块大小(以物理页位大小)，仅在当前页是空闲块的第一个物理页时有效</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> property;          <span class="comment">// the num of free block, used in first fit pm manager</span></span><br><span class="line">    <span class="type">list_entry_t</span> page_link;         <span class="comment">// free list link</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是新增的成员</span></span><br><span class="line">    <span class="type">list_entry_t</span> pra_page_link;     <span class="comment">// 用于连接上一个和下一个*可交换已分配*的物理页</span></span><br><span class="line">    <span class="type">uintptr_t</span> pra_vaddr;            <span class="comment">// 用于保存该物理页所对应的虚拟地址。</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="x01-缺页中断写时创建和页面置换算法">0X01
缺页中断、写时创建和页面置换算法</h3>
<p>此时我们需要完成<code>kern/mm/vmm.c</code>中的，<code>do_pgfault</code>函数，这个函数的作用是处理缺页中断。当缺页发生的时候，CPU会先把产生缺页中断的虚拟地址存放进CR2寄存器，然后把错误码等压入堆栈，并通过<code>__alltraps-&gt;trap-&gt;trap_dispatch-&gt;pgfault_handler-&gt;do_pgfault</code>这样调用栈来最终由do_pgfault函数处理缺页中断。</p>
<div class="note info">
            <p><strong>缺页中断实质上还是需要硬件的支持</strong>。在保护模式下，CPU引用一个段需要查看段描述符，段描述符存在段描述符表中。但有的时候，对应的段并不存在于内存中(CPU允许段描述符表中注册的段不再内存中，这是它提供给软件的策略)，此时硬件产生缺页中断。</p><p><strong>不过，不同体系的处理器产生缺页中断的过程不一致，所以系统如何检测到缺页发生可以当作是硬件黑盒</strong></p>
          </div>
<p>同样的，这个函数中同样存在大量的注释和已经写好的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* do_pgfault - interrupt handler to process the page fault execption</span></span><br><span class="line"><span class="comment"> * @mm         : the control struct for a set of vma using the same PDT</span></span><br><span class="line"><span class="comment"> * @error_code : the error code recorded in trapframe-&gt;tf_err which is setted by x86 hardware</span></span><br><span class="line"><span class="comment"> * @addr       : the addr which causes a memory access exception, (the contents of the CR2 register)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CALL GRAPH: trap--&gt; trap_dispatch--&gt;pgfault_handler--&gt;do_pgfault</span></span><br><span class="line"><span class="comment"> * The processor provides ucore's do_pgfault function with two items of information to aid in diagnosing</span></span><br><span class="line"><span class="comment"> * the exception and recovering from it.</span></span><br><span class="line"><span class="comment"> *   (1) The contents of the CR2 register. The processor loads the CR2 register with the</span></span><br><span class="line"><span class="comment"> *       32-bit linear address that generated the exception. The do_pgfault fun can</span></span><br><span class="line"><span class="comment"> *       use this address to locate the corresponding page directory and page-table</span></span><br><span class="line"><span class="comment"> *       entries.</span></span><br><span class="line"><span class="comment"> *   (2) An error code on the kernel stack. The error code for a page fault has a format different from</span></span><br><span class="line"><span class="comment"> *       that for other exceptions. The error code tells the exception handler three things:</span></span><br><span class="line"><span class="comment"> *         -- The P flag   (bit 0) indicates whether the exception was due to a not-present page (0)</span></span><br><span class="line"><span class="comment"> *            or to either an access rights violation or the use of a reserved bit (1).</span></span><br><span class="line"><span class="comment"> *         -- The W/R flag (bit 1) indicates whether the memory access that caused the exception</span></span><br><span class="line"><span class="comment"> *            was a read (0) or write (1).</span></span><br><span class="line"><span class="comment"> *         -- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)</span></span><br><span class="line"><span class="comment"> *            or supervisor mode (0) at the time of the exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_pgfault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="type">uint32_t</span> error_code, <span class="type">uintptr_t</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> ret = -E_INVAL;</span><br><span class="line">    <span class="comment">// try to find a vma which include addr</span></span><br><span class="line">    <span class="comment">// 尝试找到一个包含addr的vma</span></span><br><span class="line">    <span class="comment">// 也就是看一下这个地址是不是在进程某个vma的范围内</span></span><br><span class="line">    <span class="comment">// vma管理的是所有有效地址，所以如果不在vma中，就是不合法的</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> find_vma(mm, addr);</span><br><span class="line"></span><br><span class="line">    pgfault_num++;</span><br><span class="line">    <span class="comment">// If the addr is in the range of a mm's vma?</span></span><br><span class="line">    <span class="comment">// 没有vma包含这个地址，不合法</span></span><br><span class="line">    <span class="keyword">if</span> (vma == <span class="literal">NULL</span> || vma-&gt;vm_start &gt; addr)</span><br><span class="line">    {</span><br><span class="line">        cprintf(<span class="string">"not valid addr %x, and  can not find it in vma\n"</span>, addr);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// check the error_code</span></span><br><span class="line">    <span class="comment">// 下面执行权限检查和判断访问页面是否存在物理页面中</span></span><br><span class="line">    <span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 进到此处，说明对页面是写请求，同时页面存在于物理内存中</span></span><br><span class="line">        <span class="comment">// 但是还没有检查权限，权限的检查是case 2中的代码</span></span><br><span class="line">        <span class="comment">// 如果权限也满足，就可以直接写入了，不需要置换</span></span><br><span class="line">        <span class="comment">/* error code flag : default is 3 ( W/R=1, P=1): write, present */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">/* error code flag : (W/R=1, P=0): write, not present */</span></span><br><span class="line">        <span class="comment">// 写页面，但是页面不存在</span></span><br><span class="line">        <span class="comment">// 检查下权限，没有写入权限就fail</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">        {</span><br><span class="line">            cprintf(<span class="string">"do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">/* error code flag : (W/R=0, P=1): read, present */</span></span><br><span class="line">        <span class="comment">// 读内存，且内存也存在于物理内存中</span></span><br><span class="line">        <span class="comment">// 肯定是可以直接读的，不应该进入缺页中断中，直接错误</span></span><br><span class="line">        cprintf(<span class="string">"do_pgfault failed: error code flag = read AND present\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* error code flag : (W/R=0, P=0): read, not present */</span></span><br><span class="line">        <span class="comment">// 读内存，但是内存不存在于物理内存中</span></span><br><span class="line">        <span class="comment">// 检查下权限，没有读权限就fail</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC)))</span><br><span class="line">        {</span><br><span class="line">            cprintf(<span class="string">"do_pgfault failed: error code flag = read AND not present, but the addr's vma cannot read or exec\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* IF (write an existed addr ) OR</span></span><br><span class="line"><span class="comment">     *    (write an non_existed addr &amp;&amp; addr is writable) OR</span></span><br><span class="line"><span class="comment">     *    (read  an non_existed addr &amp;&amp; addr is readable)</span></span><br><span class="line"><span class="comment">     * THEN</span></span><br><span class="line"><span class="comment">     *    continue process</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 检查完权限，下面正式处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置页表条目所对应的权限</span></span><br><span class="line">    <span class="type">uint32_t</span> perm = PTE_U;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE)</span><br><span class="line">    {</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 内存对齐</span></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line"></span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="type">pte_t</span> *ptep = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 1: YOUR CODE</span></span><br><span class="line"><span class="comment">     * Maybe you want help comment, BELOW comments can help you finish the code</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   get_pte : get an pte and return the kernel virtual address of this pte for la</span></span><br><span class="line"><span class="comment">     *             if the PT contians this pte didn't exist, alloc a page for PT (notice the 3th parameter '1')</span></span><br><span class="line"><span class="comment">     *   pgdir_alloc_page : call alloc_page &amp; page_insert functions to allocate a page size memory &amp; setup</span></span><br><span class="line"><span class="comment">     *             an addr map pa&lt;---&gt;la with linear address la and the PDT pgdir</span></span><br><span class="line"><span class="comment">     * DEFINES:</span></span><br><span class="line"><span class="comment">     *   VM_WRITE  : If vma-&gt;vm_flags &amp; VM_WRITE == 1/0, then the vma is writable/non writable</span></span><br><span class="line"><span class="comment">     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable</span></span><br><span class="line"><span class="comment">     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access</span></span><br><span class="line"><span class="comment">     * VARIABLES:</span></span><br><span class="line"><span class="comment">     *   mm-&gt;pgdir : the PDT of these vma</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 1: YOUR CODE*/</span></span><br><span class="line">    <span class="comment">// 先尝试获取pte，如果不存在，get_pte会自动创建一个pte表项</span></span><br><span class="line">    ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">1</span>); <span class="comment">//(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.</span></span><br><span class="line">    <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果这个表项对应的物理地址不存在，那么就需要分配一个物理页</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 分配一个物理页，并让虚拟地址addr映射到这个物理页</span></span><br><span class="line">        <span class="comment">// 就是让之前分配的pte表项指向这个物理页</span></span><br><span class="line">        <span class="keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        <span class="comment">//(2) if the phy addr isn't exist, then alloc a page &amp; map the phy addr with logical addr</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 如果PTE存在，说明该页被置换到外存，需要换回来</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE</span></span><br><span class="line"><span class="comment">         * Now we think this pte is a  swap entry, we should load data from disk to a page with phy addr,</span></span><br><span class="line"><span class="comment">         * and map the phy addr with logical addr, trigger swap manager to record the access situation of this page.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  Some Useful MACROs and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">         *  MACROs or Functions:</span></span><br><span class="line"><span class="comment">         *    swap_in(mm, addr, &amp;page) : alloc a memory page, then according to the swap entry in PTE for addr,</span></span><br><span class="line"><span class="comment">         *                               find the addr of disk page, read the content of disk page into this memroy page</span></span><br><span class="line"><span class="comment">         *    page_insert ： build the map of phy addr of an Page with the linear addr la</span></span><br><span class="line"><span class="comment">         *    swap_map_swappable ： set the page swappable</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (swap_init_ok)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">struct</span> Page *page = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 先把目标地址加载到内存page页上</span></span><br><span class="line">            ret = swap_in(mm, addr, &amp;page);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">goto</span> failed;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 然后把page页映射到虚拟地址addr上，权限为perm</span></span><br><span class="line">            ret = page_insert(mm-&gt;pgdir, page, addr, perm);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后把page页设置为可交换的</span></span><br><span class="line">            swap_map_swappable(mm, addr, page, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 然后设置一下page页的虚拟地址</span></span><br><span class="line">            page-&gt;pra_vaddr = addr;</span><br><span class="line">            <span class="comment">//(1）According to the mm AND addr, try to load the content of right disk page</span></span><br><span class="line">            <span class="comment">//    into the memory which page managed.</span></span><br><span class="line">            <span class="comment">//(2) According to the mm, addr AND page, setup the map of phy addr &lt;---&gt; logical addr</span></span><br><span class="line">            <span class="comment">//(3) make the page swappable.</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line">            cprintf(<span class="string">"no swap_init_ok but ptep is %x, failed\n"</span>, *ptep);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个函数就是处理缺页中断的函数，它做的事情很简单：</p>
<ul>
<li>检查访问是否合法(vma、权限)</li>
<li>访问PTE检查物理页面是否存在，说明物理页面本身不存在，不存在则创建一个物理页面</li>
<li>如果PTE存在，那么说明物理页面之前被换出去了，那么再调用页面置换算法换回来</li>
</ul>
<p>然后实现一下FIFO页面置换算法，主要是实现<code>kern/mm/swap_fifo.c</code>中完成map_swappable和swap_out_victim函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _fifo_map_swappable(<span class="keyword">struct</span> mm_struct *mm, <span class="type">uintptr_t</span> addr, <span class="keyword">struct</span> Page *page, <span class="type">int</span> swap_in)</span><br><span class="line">{</span><br><span class="line">    <span class="type">list_entry_t</span> *head = (<span class="type">list_entry_t</span> *)mm-&gt;sm_priv;</span><br><span class="line">    <span class="type">list_entry_t</span> *entry = &amp;(page-&gt;pra_page_link);</span><br><span class="line"></span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// record the page access situlation</span></span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span></span><br><span class="line">    <span class="comment">// 就是将这一页加入到链表头中(最近访问过的放前面) 使其可以被置换算法使用到</span></span><br><span class="line">    list_add(head, entry);</span><br><span class="line">    <span class="comment">//(1)link the most recent arrival page at the back of the pra_list_head qeueue.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  (4)_fifo_swap_out_victim: According FIFO PRA, we should unlink the  earliest arrival page in front of pra_list_head qeueue,</span></span><br><span class="line"><span class="comment"> *                            then set the addr of addr of this page to ptr_page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 选择页面置换出去</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _fifo_swap_out_victim(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> Page **ptr_page, <span class="type">int</span> in_tick)</span><br><span class="line">{</span><br><span class="line">    <span class="type">list_entry_t</span> *head = (<span class="type">list_entry_t</span> *)mm-&gt;sm_priv;</span><br><span class="line">    assert(head != <span class="literal">NULL</span>);</span><br><span class="line">    assert(in_tick == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Select the victim */</span></span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span></span><br><span class="line">    <span class="comment">// 选择最早的页面作为置换出去的页面</span></span><br><span class="line">    <span class="type">list_entry_t</span> *victim = head-&gt;prev;</span><br><span class="line">    <span class="comment">// 查找到该页面的链表项</span></span><br><span class="line">    *ptr_page = le2page(victim, pra_page_link);</span><br><span class="line">    <span class="comment">// 将该页面从链表中删除</span></span><br><span class="line">    list_del(victim);</span><br><span class="line">    <span class="comment">//(1)  unlink the  earliest arrival page in front of pra_list_head qeueue</span></span><br><span class="line">    <span class="comment">//(2)  set the addr of addr of this page to ptr_page</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于mm_struct中维护了访问的页面的顺序，所以通过其可以轻松的找出需要置换的页面并删除。</p>
<h3 id="x02-总结">0X02 总结</h3>
<p>通过这个lab3，我们学习了以下内容:</p>
<ul>
<li>缺页中断的处理：检查权限、检查页面位置、置换或分配</li>
<li>使用FIFO算法实现页面置换</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>ucore操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>从ucore来总结操作系统(4)----内核线程</title>
    <url>/2023/01/20/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-4/</url>
    <content><![CDATA[<h2 id="内核线程">内核线程</h2>
<span id="more"></span>
<p>这篇是lab4的内容，主要就是实现一下创建内核线程，摆脱单线程运行。</p>
<h3 id="x00-环境准备">0X00 环境准备</h3>
<p>本lab基于之前所有实现的lab。</p>
<p>lab2和lab3完成了对内存的虚拟化，但整个控制流还是一条线串行执行。lab4将在此基础上进行CPU的虚拟化，即让ucore实现分时共享CPU，<strong>实现多条控制流能够并发执行</strong>。从某种程度上，我们可以把控制流看作是一个内核线程。本次实验将首先接触的是内核线程的管理。内核线程是一种特殊的进程，内核线程与用户进程的区别有两个：内核线程只运行在内核态而用户进程会在在用户态和内核态交替运行；所有内核线程直接使用共同的ucore内核内存空间，不需为每个内核线程维护单独的内存空间而用户进程需要维护各自的用户内存空间。从内存空间占用情况这个角度上看，我们可以把线程看作是一种共享内存空间的轻量级进程。</p>
<p>为了实现内核线程，需要设计管理线程的数据结构，即<strong>进程控制块</strong>（在这里也可叫做线程控制块）。如果要让内核线程运行，我们首先要创建内核线程对应的进程控制块，还需把这些进程控制块通过链表连在一起，便于随时进行插入，删除和查找操作等进程管理事务。<strong>这个链表就是进程控制块链表</strong>。然后在通过<strong>调度器（scheduler）来让不同的内核线程在不同的时间段占用CPU执行</strong>，实现对CPU的分时共享。这就是整个lab4做的工作。</p>
<p>由于进程(此处是线程)是通过进程描述块来描述的，所以切换进程的运行本质上也就是更换进程描述块。下面是进程描述块的结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>        <span class="comment">// 当前进程的状态</span></span><br><span class="line">    <span class="type">int</span> pid;                      <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="type">int</span> runs;                     <span class="comment">// 当前进程被调度的次数</span></span><br><span class="line">    <span class="type">uintptr_t</span> kstack;             <span class="comment">// 内核栈</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">bool</span> need_resched;   <span class="comment">// 是否需要被调度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span>   <span class="comment">// 父进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>         <span class="comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>       <span class="comment">// 保存的上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>         <span class="comment">// 中断所保存的上下文</span></span><br><span class="line">    <span class="type">uintptr_t</span> cr3;                <span class="comment">// 页目录表的地址</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;               <span class="comment">// 当前进程的相关标志</span></span><br><span class="line">    <span class="type">char</span> name[PROC_NAME_LEN + <span class="number">1</span>]; <span class="comment">// 进程名称（可执行文件名）</span></span><br><span class="line">    <span class="type">list_entry_t</span> list_link;       <span class="comment">// 用于连接list</span></span><br><span class="line">    <span class="type">list_entry_t</span> hash_link;       <span class="comment">// 用于连接hash list</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p><strong>下面内容来自指导书，解释更加详细</strong></p><ul><li>mm：内存管理的信息，包括内存映射列表、页表指针等。mm成员变量在lab3中用于虚存管理。<strong>但在实际OS中，内核线程常驻内存，不需要考虑swappage问题，在lab5中涉及到了用户进程，才考虑进程用户内存空间的swappage问题，mm才会发挥作用</strong>。所以在lab4中mm对于内核线程就没有用了，这样内核线程的proc_struct的成员变量*mm=0是合理的。mm里有个很重要的项pgdir，记录的是该进程使用的一级页表的物理地址。由于*mm=NULL，所以在proc_struct数据结构中需要有一个代替pgdir项来记录页表起始地址，这就是proc_struct数据结构中的cr3成员变量。</li><li>state：进程所处的状态。</li><li>parent：用户进程的父进程（创建它的进程）。在所有进程中，只有一个进程没有父进程，就是内核创建的第一个内核线程idleproc。内核根据这个父子关系建立一个树形结构，用于维护一些特殊的操作，例如确定某个进程是否可以对另外一个进程进行某种操作等等。</li><li>context：进程的上下文，用于进程切换（参见switch.S）。在uCore中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等）。使用context保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用context进行上下文切换的函数是在kern/process/switch.S中定义switch_to。</li><li>tf：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。除此之外，uCore内核允许嵌套中断。因此为了保证嵌套中断发生时tf总是能够指向当前的trapframe，uCore 在内核栈上维护了 tf的链，可以参考trap.c::trap函数做进一步的了解。</li><li>cr3: cr3 保存页表的物理地址，目的就是进程切换的时候方便直接使用lcr3实现页表切换，避免每次都根据 mm 来计算cr3。mm数据结构是用来实现用户空间的虚存管理的，但是内核线程没有用户空间，它执行的只是内核中的一小段代码（通常是一小段函数），所以它没有mm结构，也就是NULL。当某个进程是一个普通用户态进程的时候，PCB 中的 cr3就是 mm 中页表（pgdir）的物理地址；而当它是内核线程的时候，cr3等于boot_cr3。而boot_cr3指向了uCore启动时建立好的内核虚拟空间的页目录表首地址。</li><li>kstack:每个线程都有一个内核栈，并且位于内核地址空间的不同位置。对于内核线程，该栈就是运行时的程序使用的栈；而对于普通进程，该栈是发生特权级改变的时候使保存被打断的硬件信息用的栈。uCore在创建进程时分配了2个连续的物理页（参见memlayout.h中KSTACKSIZE的定义）作为内核栈的空间。这个栈很小，所以内核中的代码应该尽可能的紧凑，并且避免在栈上分配大的数据结构，以免栈溢出，导致系统崩溃。kstack记录了分配给该进程/线程的内核栈的位置。主要作用有以下几点。首先，当内核准备从一个进程切换到另一个的时候，需要根据kstack的值正确的设置好 tss （可以回顾一下在实验一中讲述的 tss在中断处理过程中的作用），以便在进程切换以后再发生中断时能够使用正确的栈。其次，内核栈位于内核地址空间，并且是不共享的（每个线程都拥有自己的内核栈），因此不受到mm 的管理，当进程退出的时候，内核能够根据 kstack的值快速定位栈的位置并进行回收。uCore 的这种内核栈的设计借鉴的是 linux的方法（但由于内存管理实现的差异，它实现的远不如 linux的灵活），它使得每个线程的内核栈在不同的位置，这样从某种程度上方便调试，但同时也使得内核对栈溢出变得十分不敏感，因为一旦发生溢出，它极可能污染内核中其它的数据使得内核崩溃。如果能够通过页表，将所有进程的内核栈映射到固定的地址上去，能够避免这种问题，但又会使得进程切换过程中对栈的修改变得相当繁琐。感兴趣的同学可以参考linux kernel 的代码对此进行尝试。</li></ul><p>为了管理系统中所有的进程控制块，uCore维护了如下全局变量（位于kern/process/proc.c）：</p><ul><li>static struct proc*current：当前占用CPU且处于“运行”状态进程控制块指针。通常这个变量是只读的，只有在进程切换的时候才进行修改，并且整个切换和修改过程需要保证操作的原子性，目前至少需要屏蔽中断。可以参考switch_to 的实现。</li><li>static struct proc*initproc：本实验中，指向一个内核线程。本实验以后，此指针将指向第一个用户态进程。</li><li>static list_entry_thash_list[HASH_LIST_SIZE]：所有进程控制块的哈希表，proc_struct中的成员变量hash_link将基于pid链接入这个哈希表中。</li><li>list_entry_tproc_list：所有进程控制块的双向线性列表，proc_struct中的成员变量list_link将链接入这个链表中。</li></ul>
          </div>
<h3 id="x01-分配并初始化一个进程控制块">0X01
分配并初始化一个进程控制块</h3>
<p>在ucore中，当创建进程的时候，需要先申请一个进程控制块(空块，后续填入线程的内容)，在<code>init.c::kern_init</code>函数调用了<code>proc.c::proc_init</code>函数。proc_init函数启动了创建内核线程的步骤。首先当前的执行上下文（从kern_init
启动至今）就可以看成是uCore内核（也可看做是内核进程）中的一个内核线程的上下文。为此，uCore通过给当前执行的上下文分配一个进程控制块以及对它进行相应初始化，将其打造成第0个内核线程
--
idleproc。即调用alloc_proc函数来通过kmalloc函数获得proc_struct结构的一块内存块-，作为第0个进程控制块。并把proc进行初步初始化（即把proc_struct中的各个成员变量清零）</p>
<p>我们的任务就是实现这个alloc_proc函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// alloc_proc - alloc a proc_struct and init all fields of proc_struct</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct *</span><br><span class="line"><span class="title function_">alloc_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// LAB4:EXERCISE1 YOUR CODE</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * below fields in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment">         *       enum proc_state state;                      // Process state</span></span><br><span class="line"><span class="comment">         *       int pid;                                    // Process ID</span></span><br><span class="line"><span class="comment">         *       int runs;                                   // the running times of Proces</span></span><br><span class="line"><span class="comment">         *       uintptr_t kstack;                           // Process kernel stack</span></span><br><span class="line"><span class="comment">         *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?</span></span><br><span class="line"><span class="comment">         *       struct proc_struct *parent;                 // the parent process</span></span><br><span class="line"><span class="comment">         *       struct mm_struct *mm;                       // Process's memory management field</span></span><br><span class="line"><span class="comment">         *       struct context context;                     // Switch here to run process</span></span><br><span class="line"><span class="comment">         *       struct trapframe *tf;                       // Trap frame for current interrupt</span></span><br><span class="line"><span class="comment">         *       uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)</span></span><br><span class="line"><span class="comment">         *       uint32_t flags;                             // Process flag</span></span><br><span class="line"><span class="comment">         *       char name[PROC_NAME_LEN + 1];               // Process name</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        proc-&gt;state = PROC_UNINIT;                           <span class="comment">// 设置进程为“初始”态</span></span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;                                      <span class="comment">// 设置进程pid的未初始化值</span></span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;                                      <span class="comment">// 进程运行时间为0</span></span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;                                    <span class="comment">// 进程的内核栈为0，即没有内核栈</span></span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;                              <span class="comment">// 1为进程占据CPU，0为进程释放CPU</span></span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;                                 <span class="comment">// 进程的父进程</span></span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;                                     <span class="comment">// lab4中mm对于内核线程就没有用</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> context)); <span class="comment">// 初始化进程上下文</span></span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;                                     <span class="comment">// 中断帧的指针为NULL</span></span><br><span class="line">        proc-&gt;cr3 = boot_cr3;                                <span class="comment">// 使用内核页目录表的基址</span></span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;                                     <span class="comment">// 进程标志为0</span></span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);                <span class="comment">// 初始化进程名称</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p><strong>几个参数含义</strong></p><ul><li><strong>state</strong> 设置了进程的状态为“初始”态，这表示进程已经“出生”了，正在获取资源茁壮成长中</li><li><strong>pid</strong>设置了进程的pid为-1，这表示进程的“身份证号”还没有办好</li><li><strong>cr3</strong>表明由于该内核线程在内核中运行，故采用为uCore内核已经建立的页表，即设置为在uCore内核页表的起始地址boot_cr3。<em>后续实验中可进一步看出所有内核线程的内核虚地址空间（也包括物理地址空间）是相同的。既然内核线程共用一个映射内核空间的页表，这表示内核空间对所有内核线程都是“可见”的，所以更精确地说，这些内核线程都应该是从属于同一个唯一的“大内核进程”—uCore内核。</em></li></ul>
          </div>
<div class="note primary">
            <p><strong>关于context和trapframe</strong></p><p>proc_struct存在以上两个字段，分别保存了进程的上下文和中断帧。</p><ul><li><strong>context</strong>保存了进程的上下文，其实就是当前程序执行到的汇编的位置和相关寄存器，这样从进程A切换到进程B的时候就能恢复进程B执行到的位置。</li><li><strong>trapframe</strong>这个保存了中断帧，主要是实现进程A在中断过程中被切换至进程B，再切换到进程A后能从中断正确返回(中断函数好多都是公用的，需要中断帧来准确记录到底是哪个进程进入到当前的中断函数中)</li></ul><p>另外，我们还能体会到<strong>为什么子进程要继承父进程的资源</strong></p><p>比如，当进程A fork出子进程A1时，由于<strong>子进程A1继承了父进程A的上下文和中断帧(当然还有其他资源)</strong>(此时子进程A1和父进程A可以看作是两个进程，分别被调度)，所以子进程能够通过中断帧在创建的时候就进行中断返回(fork是系统调用，需要进入内核态的中断函数里)</p>
          </div>
<h3 id="x02-为新创建的内核线程分配资源">0X02
为新创建的内核线程分配资源</h3>
<p>创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，<strong>但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源</strong>。ucore一般通过do_fork实际创建新的内核线程。<strong>do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。</strong>在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。需要完成在<code>kern/process/proc.c</code>中的do_fork函数中的处理过程。它的大致执行步骤包括：</p>
<ul>
<li>调用alloc_proc，首先获得一块用户信息块。</li>
<li>为进程分配一个内核栈。</li>
<li>复制原进程的内存管理信息到新进程（但内核线程不必做此事）</li>
<li>复制原进程上下文到新进程</li>
<li>将新进程添加到进程列表</li>
<li>唤醒新进程</li>
<li>返回新进程号</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* do_fork -     parent process for a new child process</span></span><br><span class="line"><span class="comment"> * @clone_flags: used to guide how to clone the child process</span></span><br><span class="line"><span class="comment"> * @stack:       the parent's user stack pointer. if stack==0, It means to fork a kernel thread.</span></span><br><span class="line"><span class="comment"> * @tf:          the trapframe info, which will be copied to child process's proc-&gt;tf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_fork</span><span class="params">(<span class="type">uint32_t</span> clone_flags, <span class="type">uintptr_t</span> <span class="built_in">stack</span>, <span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="comment">// 进程数目太多</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    }</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">// LAB4:EXERCISE2 YOUR CODE</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)</span></span><br><span class="line"><span class="comment">     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack</span></span><br><span class="line"><span class="comment">     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags</span></span><br><span class="line"><span class="comment">     *                 if clone_flags &amp; CLONE_VM, then "share" ; else "duplicate"</span></span><br><span class="line"><span class="comment">     *   copy_thread:  setup the trapframe on the  process's kernel stack top and</span></span><br><span class="line"><span class="comment">     *                 setup the kernel entry point and stack of process</span></span><br><span class="line"><span class="comment">     *   hash_proc:    add proc into proc hash_list</span></span><br><span class="line"><span class="comment">     *   get_pid:      alloc a unique pid for process</span></span><br><span class="line"><span class="comment">     *   wakeup_proc:  set proc-&gt;state = PROC_RUNNABLE</span></span><br><span class="line"><span class="comment">     * VARIABLES:</span></span><br><span class="line"><span class="comment">     *   proc_list:    the process set's list</span></span><br><span class="line"><span class="comment">     *   nr_process:   the number of process set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 1. 分配程序结构体</span></span><br><span class="line">    proc = alloc_proc();</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="comment">// alloc_proc默认是没有父进程的</span></span><br><span class="line">    <span class="comment">// 但是fork本身就是父进程调用的，所以这里要设置父进程</span></span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 分配内核栈</span></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 复制内存空间，把所有虚拟页数据复制过去</span></span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 复制线程</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 插入进程哈希表和进程链表</span></span><br><span class="line">    <span class="comment">// 这一步需要阻止中断防止竞争</span></span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    {</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        list_add(&amp;proc_list, &amp;(proc-&gt;list_link));</span><br><span class="line">        nr_process++;</span><br><span class="line">    }</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 唤醒进程</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 设置返回值</span></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line"><span class="comment">//    2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line"><span class="comment">//    3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line"><span class="comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line"><span class="comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line"><span class="comment">//    6. call wakeup_proc to make the new child process RUNNABLE</span></span><br><span class="line"><span class="comment">//    7. set ret vaule using child proc's pid</span></span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来看一下do_fork函数中调用的几个函数。</p>
<ul>
<li>setup_kstack ：
分配2个页面，然后将其的虚拟地址作为进程内核态页面</li>
<li>copy_mm ：
复制内存空间，但是由于是写时复制，所以这个函数什么都不做</li>
<li>copy_thread ：
会把父进程的trapframe复制到子进程的内核栈中，然后设置子进程的内核栈指针和内核入口地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// copy_thread - setup the trapframe on the  process's kernel stack top and</span></span><br><span class="line"><span class="comment">//             - setup the kernel entry point and stack of process</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">copy_thread</span><span class="params">(<span class="keyword">struct</span> proc_struct *proc, <span class="type">uintptr_t</span> esp, <span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 设置子进程的中断帧，并把中断帧放在子进程的内核栈顶</span></span><br><span class="line">    <span class="comment">// 由于子进程的创建是系统调用产生，所以必须通过中断帧返回</span></span><br><span class="line">    <span class="comment">// 为了保证子进程的中断帧与父进程的中断帧一致，所以需要复制父进程的中断帧(即系统调用位置)</span></span><br><span class="line">    <span class="comment">// 为了便于区分子进程和父进程，把子进程的中断帧中的eax置为0</span></span><br><span class="line">    <span class="comment">// 这样子进程被调度返回的时候，就会返回0</span></span><br><span class="line">    proc-&gt;tf = (<span class="keyword">struct</span> trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="number">1</span>;</span><br><span class="line">    *(proc-&gt;tf) = *tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程返回值</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置中断时的栈为当前栈，并加上中断标志</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_esp = esp;</span><br><span class="line">    proc-&gt;tf-&gt;tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子进程的下一条指令执行forkret</span></span><br><span class="line">    proc-&gt;context.eip = (<span class="type">uintptr_t</span>)forkret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把中断帧放在子进程的的栈顶</span></span><br><span class="line">    proc-&gt;context.esp = (<span class="type">uintptr_t</span>)(proc-&gt;tf);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p><strong>fork函数与copy_thread</strong></p><p>从copy_thread中，我们能看出，子进程和父进程的返回值不同的原因是因为修改了返回值寄存器，子进程返回值就变成了0</p><p>同时，还要设置子进程的下一条指令为执行forkret函数，这个函数的传入参数是中断帧，目的是中断返回</p><p>当子进程被调度的时候，就会从这个函数中完成中断返回。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// forkret -- the first kernel entry point of a new thread/process</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> the addr of forkret is setted in copy_thread function</span></span><br><span class="line"><span class="comment">//       after switch_to, the current proc will execute here.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    forkrets(current-&gt;tf);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs and %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line">    # set stack to this new process's trapframe</span><br><span class="line">    movl 4(%esp), %esp</span><br><span class="line">    jmp __trapret</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>但是中断返回到哪里？</strong></p><p>这个返回的位置其实在kernel_thread中被设置，我们来看一下这个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// kernel_thread - create a kernel thread using "fn" function</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> the contents of temp trapframe tf will be copied to</span></span><br><span class="line"><span class="comment">//       proc-&gt;tf in do_fork--&gt;copy_thread function</span></span><br><span class="line"><span class="comment">// 创建一个内核线程，执行的函数是fn，参数是arg</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">uint32_t</span> clone_flags)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 创建临时中断帧</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    <span class="comment">// 设置中断帧的段寄存器</span></span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="type">uint32_t</span>)fn;</span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="type">uint32_t</span>)arg;</span><br><span class="line">    <span class="comment">// 设置中断帧的中断返回地址</span></span><br><span class="line">    tf.tf_eip = (<span class="type">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">    <span class="comment">// 使用do_fork创建一个内核线程</span></span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到中断返回到kernel_thread_entry，这个函数的作用先是调用fn函数，然后调用do_exit退出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">kernel_thread_entry:        # void kernel_thread(void)</span><br><span class="line"></span><br><span class="line">    pushl %edx              # push arg</span><br><span class="line">    call *%ebx              # call fn</span><br><span class="line"></span><br><span class="line">    pushl %eax              # save the return value of fn(arg)</span><br><span class="line">    call do_exit            # call do_exit to terminate current thread</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>因此，内核线程调度是这样的：</strong></p><ul><li>调用<strong>kernel_thread</strong>函数，创建一个内核线程，需要执行的函数是fn，对应的参数是arg。kernel_thread函数会先创建中断帧，中断帧的返回函数是kernel_thread_entry</li><li>然后kernel_thread函数会调用<strong>do_fork</strong>函数，创建一个内核线程，这个函数会把中断帧复制到子进程的内核栈中，然后设置子进程的内核栈指针和上下文的入口地址为forkret(这是由copy_thread函数完成的)</li><li>调度发生时，会先通过上下文入口地址进入<strong>forkret</strong>函数，这个函数(实际上这个是包装函数)会完成中断返回，返回到kernel_thread_entry函数</li><li><strong>kernel_thread_entry</strong>函数会调用fn函数，然后调用do_exit函数退出</li></ul>
          </div>
<ul>
<li>get_proc_id ：
分配一个进程id，这个提供一个比较高性能的快速分配唯一pid的算法</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// get_pid - alloc a unique pid for process</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_pid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// last_pid是上一次分配的</span></span><br><span class="line">    <span class="comment">// next_safe是下一次可以安全分配的界限</span></span><br><span class="line">    <span class="comment">// 如果last_pid已经超过了next_safe</span></span><br><span class="line">    <span class="comment">// 那么就需要重新遍历一遍proc_list，找到next_safe</span></span><br><span class="line">    <span class="comment">// 否则就直接对last_pid进行加1操作得到的pid就一定是安全的</span></span><br><span class="line">    <span class="keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="type">list_entry_t</span> *<span class="built_in">list</span> = &amp;proc_list, *le;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这两个变量是内部的静态变量，生命期跟函数无关</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> next_safe = MAX_PID, last_pid = MAX_PID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个if判断是第一次调用get_pid的时候</span></span><br><span class="line">    <span class="comment">// 第一次调用的时候必须要遍历一遍</span></span><br><span class="line">    <span class="keyword">if</span> (++last_pid &gt;= MAX_PID)</span><br><span class="line">    {</span><br><span class="line">        last_pid = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> inside;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果last_pid已经超过了next_safe</span></span><br><span class="line">    <span class="keyword">if</span> (last_pid &gt;= next_safe)</span><br><span class="line">    {</span><br><span class="line">    inside:</span><br><span class="line">        <span class="comment">// next_safe从MAX_PID开始</span></span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        <span class="comment">// 遍历proc_list，以找到next_safe</span></span><br><span class="line">        le = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 找到进程</span></span><br><span class="line">            proc = le2proc(le, list_link);</span><br><span class="line">            <span class="comment">// 如果进程的pid等于last_pid(这个pid已经被分配过了)</span></span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;pid == last_pid)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 对last_pid进行加1操作</span></span><br><span class="line">                <span class="comment">// 如果last_pid已经超过了next_safe</span></span><br><span class="line">                <span class="comment">// 且last_pid已经超过了MAX_PID</span></span><br><span class="line">                <span class="comment">// 那么就需要重新遍历一遍proc_list，找到next_safe</span></span><br><span class="line">                <span class="comment">// 且last_pid没有超过MAX_PID，其实就是对last_pid+1</span></span><br><span class="line">                <span class="keyword">if</span> (++last_pid &gt;= next_safe)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (last_pid &gt;= MAX_PID)</span><br><span class="line">                    {</span><br><span class="line">                        last_pid = <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    <span class="keyword">goto</span> repeat;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果进程的pid大于last_pid，且小于next_safe</span></span><br><span class="line">            <span class="comment">// 那么就更新next_safe为当前进程的pid</span></span><br><span class="line">            <span class="comment">// 因为last_pid是一个一个遍历的，所以next_safe一定是可用的最大值+1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid)</span><br><span class="line">            {</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> last_pid;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/2023/01/20/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-4/pic1.png" class="">
<ul>
<li>wakeup_proc ： 把进程的状态设置为就绪</li>
<li>hash_proc ： 把进程加入到hash表中</li>
</ul>
<h3 id="x02-进程切换">0X02 进程切换</h3>
<p>首先，schedule函数会遍历proc_list，找到一个就绪的进程，然后调用proc_run函数进行进程切换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    <span class="type">list_entry_t</span> *le, *last;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">next</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子操作</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 先把当前线程的需要调度标志清除</span></span><br><span class="line">        current-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        last = (current == idleproc) ? &amp;proc_list : &amp;(current-&gt;list_link);</span><br><span class="line">        le = last;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到下一个需要调度的线程(为就绪状态)</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> ((le = list_next(le)) != &amp;proc_list)</span><br><span class="line">            {</span><br><span class="line">                next = le2proc(le, list_link);</span><br><span class="line">                <span class="keyword">if</span> (next-&gt;state == PROC_RUNNABLE)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">while</span> (le != last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到就绪状态的线程，就调度idleproc</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span> || next-&gt;state != PROC_RUNNABLE)</span><br><span class="line">        {</span><br><span class="line">            next = idleproc;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则运行新的就绪状态线程</span></span><br><span class="line">        next-&gt;runs++;</span><br><span class="line">        <span class="keyword">if</span> (next != current)</span><br><span class="line">        {</span><br><span class="line">            proc_run(next);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在proc_run函数中，会调用switch_to函数进行进程切换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// proc_run - make process "proc" running on cpu</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> before call switch_to, should load  base addr of "proc"'s new PDT</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_run</span><span class="params">(<span class="keyword">struct</span> proc_struct *proc)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (proc != current)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        <span class="comment">// 原子操作</span></span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        {</span><br><span class="line">            current = proc;</span><br><span class="line">            <span class="comment">// 设置ring0的内核栈地址</span></span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);</span><br><span class="line">            <span class="comment">// 加载页目录表</span></span><br><span class="line">            lcr3(next-&gt;cr3);</span><br><span class="line">            <span class="comment">// 切换上下文</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br><span class="line">        }</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在switch_to函数中，会调用汇编函数__switch_to进行进程切换，主要是切换到对应的上下文中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl switch_to</span><br><span class="line">switch_to:                      # switch_to(from, to)</span><br><span class="line">    # save from's registers</span><br><span class="line">    movl 4(%esp), %eax          # 获取当前进程的context结构地址</span><br><span class="line">    popl 0(%eax)                # 将eip保存至当前进程的context结构</span><br><span class="line">    movl %esp, 4(%eax)          # 将esp保存至当前进程的context结构</span><br><span class="line">    movl %ebx, 8(%eax)          # 将ebx保存至当前进程的context结构</span><br><span class="line">    movl %ecx, 12(%eax)         # 将ecx保存至当前进程的context结构</span><br><span class="line">    movl %edx, 16(%eax)         # 将edx保存至当前进程的context结构</span><br><span class="line">    movl %esi, 20(%eax)         # 将esi保存至当前进程的context结构</span><br><span class="line">    movl %edi, 24(%eax)         # 将edi保存至当前进程的context结构</span><br><span class="line">    movl %ebp, 28(%eax)         # 将ebp保存至当前进程的context结构</span><br><span class="line"></span><br><span class="line">    # restore to's registers</span><br><span class="line">    movl 4(%esp), %eax          # 获取下一个进程的context结构地址</span><br><span class="line">                                # 需要注意的是，其地址不是8(%esp)，因为之前已经pop过一次栈。</span><br><span class="line">    movl 28(%eax), %ebp         # 恢复ebp至下一个进程的context结构</span><br><span class="line">    movl 24(%eax), %edi         # 恢复edi至下一个进程的context结构</span><br><span class="line">    movl 20(%eax), %esi         # 恢复esi至下一个进程的context结构</span><br><span class="line">    movl 16(%eax), %edx         # 恢复edx至下一个进程的context结构</span><br><span class="line">    movl 12(%eax), %ecx         # 恢复ecx至下一个进程的context结构</span><br><span class="line">    movl 8(%eax), %ebx          # 恢复ebx至下一个进程的context结构</span><br><span class="line">    movl 4(%eax), %esp          # 恢复esp至下一个进程的context结构</span><br><span class="line">    pushl 0(%eax)               # 插入下一个进程的eip，以便于ret到下个进程的代码位置。</span><br><span class="line">    ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，目标程序的上下文已经切换完成，可以开始执行对应的进程了。</p>
<h3 id="x03-总结">0X03 总结</h3>
<p>通过这个lab4，我们学习了以下内容:</p>
<ul>
<li>使用进程描述符来对进程的上下文和其他信息进行描述，方便调度</li>
<li>在fork系统调用时，通过创建中断帧和上下文信息来实现中断返回，并分析了为什么子进程和父进程返回值不同</li>
<li>get_pid算法，快速分配不重数</li>
<li>进程切换的方法</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>ucore操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>从ucore来总结操作系统(5)----用户线程</title>
    <url>/2023/01/22/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-5/</url>
    <content><![CDATA[<h2 id="用户线程">用户线程</h2>
<span id="more"></span>
<h3 id="x00-环境准备">0X00 环境准备</h3>
<p>本lab基于前所有lab，但是需要对其进行一些扩展：</p>
<ul>
<li>alloc_proc函数：添加对proc_struct::wait_state以及proc_struct::cptr/optr/yptr成员的初始化。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct *<span class="title function_">alloc_proc</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) </span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="comment">// Lab5 code</span></span><br><span class="line">        proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note primary">
            <p><strong>proc结构体中的 parent, cptr, yptr, optr</strong></p><p>proc-&gt;parent是指向父进程的指针, proc-&gt;cptr是指向子进程的指针,proc-&gt;optr是指向更老兄弟进程的指针,proc-&gt;yptr是指向更年轻兄弟进程的指针</p><p>因为子进程并不唯一, 父进程的cptr指针指向最近建立的子进程,yptr和optr是子进程之间通过时间顺序形成的双向链表,但是这个双向链表两边都是NULL，并不是严格的双向链表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">                     +----------------+</span><br><span class="line">                     | parent process |</span><br><span class="line">                     +----------------+</span><br><span class="line">              parent ^         \       ^  parent</span><br><span class="line">                    /           \       \</span><br><span class="line">                   /             \ cptr  \</span><br><span class="line">                  /         yptr  V       \      yptr</span><br><span class="line">           +-------------+  --&gt;  +-------------+  --&gt;  <span class="literal">NULL</span></span><br><span class="line">           | old process |       | New Process |</span><br><span class="line"><span class="literal">NULL</span>  &lt;--  +-------------+  &lt;--  +-------------+</span><br><span class="line">      optr                  optr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
          </div>
<ul>
<li>idt_init函数：设置中断T_SYSCALL的触发特权级位DPL_USER</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">{</span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// Lab5 code</span></span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>trap_dispatch函数：设置每100次时间中断后，当前正在执行的进程被调度，也注释掉输出100ticks的函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span> </span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) </span><br><span class="line">    {</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks++;</span><br><span class="line">        <span class="keyword">if</span>(ticks % TICK_NUM == <span class="number">0</span>){</span><br><span class="line">            <span class="comment">// Lab5 Code</span></span><br><span class="line">            assert(current != <span class="literal">NULL</span>);</span><br><span class="line">            current-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//print_ticks();</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="comment">// ......</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>do_fork函数：添加对当前程序等待状态的检查，以及使用set_link函数来设置进程之间的关系</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_fork</span><span class="params">(<span class="type">uint32_t</span> clone_flags, <span class="type">uintptr_t</span> <span class="built_in">stack</span>, <span class="keyword">struct</span> trapframe *tf)</span> </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// ..........</span></span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    <span class="comment">// Lab5: 确保当前进程的wait状态为空</span></span><br><span class="line">    assert(current-&gt;wait_state == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    {</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        <span class="comment">// Lab5: 设置进程间的关系</span></span><br><span class="line">        set_links(proc);</span><br><span class="line">    }</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">    <span class="comment">// ..........</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note primary">
            <p>只有当前进程不在等待中，才能进入fork函数里</p><p>set_link函数,是设置proc结构体中的 cptr, yptr, optr,因为子进程并不唯一, 这个函数位置保证,父进程的cptr指针指向最近建立的子进程,yptr和optr是子进程之间通过时间顺序形成的双向链表。</p>
          </div>
<h3 id="x01-加载应用程序并执行">0X01 加载应用程序并执行</h3>
<p>一般我们fork出子进程后会立刻执行execv函数，从而加载到另一个程序(这也是为什么大多需要写时复制，因为新程序不需要父进程的上下文)。</p>
<p><code>kern/process/proc.c</code>的do_execv函数加载并解析一个处于内存中的ELF执行文件格式(<strong>因为此时没有文件系统，所以所有用户程序需要随内核编译，参见实验指导书</strong>)的应用程序，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。</p>
<p>而上述函数调用load_icode函数来完成具体的实现，所以我们需要完成<code>kern/process/proc.c</code>中的load_icode函数。</p>
<p>不过在实现这个函数之前，我们<strong>先分析一下创建内核线程的过程</strong>：</p>
<ul>
<li>首先用户程序随内核编译，放在内核代码的后面，然后随内核一起被bootloader加载到内存中。</li>
<li>在本实验中第一个用户进程是由第二个内核线程initproc通过把hello应用程序执行码覆盖到initproc的用户虚拟内存空间来创建的，其会通过调用<code>KERNEL_EXECVE(hello)</code>来创建用户线程</li>
<li>KERNEL_EXECVE(hello)会调用<code>kernel_execve</code>函数来调用<code>SYS_exec</code>系统调用(这里面会做一些解析传递用户线程地址的工作，非常的简单)</li>
<li>系统调用发生后，会进入中断处理函数(中断的调用栈此处就忽略了)</li>
<li>在中断处理函数中，会进入到我们在准备工作中写的那个分支，会直接调用<code>syscall</code>函数。</li>
<li>在syscall函数中，由于<strong>此时还未中断返回，所以syscall会从中断帧中取出系统调用代号</strong>，并使用一个函数指针数组来调用对应的系统调用处理函数，此时就是<code>sys_exec</code>函数。</li>
<li>sys_exec函数会解析传递进来的参数并转换一下(<strong>因为各个系统调用需要的参数数目不同，所以传递的是类似'变长参数'的东西(其实是一个数组，各个函数各取所需)</strong>)，然后调用<code>do_execv</code>函数来加载应用程序并执行。</li>
<li>当各个子函数都执行完，就正确加载了程序并建立了上下文，<strong>但是建立上下文不代表能执行</strong>，想要让上下文正确被加载，需要中断返回，当中断返回之后，就进入新加载的程序的上下文中和对应权限下执行了()</li>
</ul>
<p>所以我们先从<code>do_execv</code>函数开始分析(前面一些函数比较简单，就是参数倒来倒去)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// kern/process/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do_execve - call exit_mmap(mm)&amp;put_pgdir(mm) to reclaim memory space of current process</span></span><br><span class="line"><span class="comment">//           - call load_icode to setup new memory space accroding binary prog.</span></span><br><span class="line"><span class="comment">// 真正处理execve系统调用的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">char</span> *binary, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 需要完成从内核态到用户态的转换，所以需要先清空mm</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="comment">// 检查在mm中，从name开始的len个字节是否都能被用户线程访问</span></span><br><span class="line">    <span class="comment">// 而mm是内核栈，所以这些是保险性监测</span></span><br><span class="line">    <span class="comment">// user_mem_check在vmm.c中</span></span><br><span class="line">    <span class="keyword">if</span> (!user_mem_check(mm, (<span class="type">uintptr_t</span>)name, len, <span class="number">0</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (len &gt; PROC_NAME_LEN)</span><br><span class="line">    {</span><br><span class="line">        len = PROC_NAME_LEN;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储副本</span></span><br><span class="line">    <span class="comment">// 猜测原因：因为name可能在用户空间，而用户空间可能会被修改</span></span><br><span class="line">    <span class="type">char</span> local_name[PROC_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(local_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(local_name));</span><br><span class="line">    <span class="built_in">memcpy</span>(local_name, name, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果mm不为空，那么就需要清空mm</span></span><br><span class="line">    <span class="comment">// 因为内核线程常驻内存，所以内核线程的mm为NULL</span></span><br><span class="line">    <span class="comment">// 如果是用户线程的话，因为需要置换，所以mm不为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="comment">// mm的引用计数为0</span></span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        }</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后执行load_icode，这个函数会加载ELF格式的程序</span></span><br><span class="line">    <span class="comment">// 申请内存、建立用户态地址空间、加载程序等等</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode(binary, size)) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> execve_exit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程名字</span></span><br><span class="line">    set_proc_name(current, local_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">execve_exit:</span><br><span class="line">    do_exit(ret);</span><br><span class="line">    panic(<span class="string">"already exit: %e.\n"</span>, ret);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在确定了用户进程的执行代码和数据，以及用户进程的虚拟空间布局后，我们可以来创建用户进程了。在本实验中第一个用户进程是由第二个内核线程initproc通过把hello应用程序执行码覆盖到initproc的用户虚拟内存空间来创建的，期间通过一系列调用，最终通过do_execve函数来完成用户进程的创建工作。此函数的主要工作流程如下：</p>
<ul>
<li>首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。</li>
<li>接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。</li>
</ul>
<p>可以看到，重点其实就是<code>load_icode</code>函数，这也是我们需要实现的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// kern/process/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* load_icode - load the content of binary program(ELF format) as the new content of current process</span></span><br><span class="line"><span class="comment"> * @binary:  the memory addr of the content of binary program</span></span><br><span class="line"><span class="comment"> * @size:  the size of the content of binary program</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 从内存中地址位置为binary的地方加载一个ELF格式的程序，加载到当前进程的内存空间中</span></span><br><span class="line"><span class="comment">// size是binary的大小</span></span><br><span class="line"><span class="comment">// 因为没有文件管理系统，所以只能从内存中加载</span></span><br><span class="line"><span class="comment">// 而应用程序随内核编译，被bootloader加载到内存中(参见实验指导书)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *binary, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 需要保证当前进程的内存空间是空的</span></span><br><span class="line">    <span class="comment">// 这在do_execve中已经保证了</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        panic(<span class="string">"load_icode: current-&gt;mm must be empty.\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="comment">//(1) create a new mm for current process</span></span><br><span class="line">    <span class="comment">// 1. 创建一个新的mm_struct结构体，其实就是为新程序创建地址空间</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line">    <span class="comment">// 2. 创建一个新的页目录表</span></span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process</span></span><br><span class="line">    <span class="comment">// 3. 加载程序，需要解析各种东西</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">//(3.1) get the file header of the bianry program (ELF format)</span></span><br><span class="line">    <span class="comment">// 3.1 获取ELF文件头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span> =</span> (<span class="keyword">struct</span> elfhdr *)binary;</span><br><span class="line">    <span class="comment">//(3.2) get the entry of the program section headers of the bianry program (ELF format)</span></span><br><span class="line">    <span class="comment">// 3.2 获取ELF程序头表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span> =</span> (<span class="keyword">struct</span> proghdr *)(binary + elf-&gt;e_phoff);</span><br><span class="line">    <span class="comment">//(3.3) This program is valid?</span></span><br><span class="line">    <span class="comment">// 3.3 检查ELF文件头是否合法(魔数)</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">    {</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> vm_flags, perm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph_end</span> =</span> ph + elf-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; ph_end; ph++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//(3.4) find every program section headers</span></span><br><span class="line">        <span class="comment">// 3.4 寻找每个程序段</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz)</span><br><span class="line">        {</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//(3.5) call mm_map fun to setup the new vma ( ph-&gt;p_va, ph-&gt;p_memsz)</span></span><br><span class="line">        <span class="comment">// 3.5 设置新的虚拟内存区域</span></span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X)</span><br><span class="line">            vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W)</span><br><span class="line">            vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R)</span><br><span class="line">            vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE)</span><br><span class="line">            perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *from = binary + ph-&gt;p_offset;</span><br><span class="line">        <span class="type">size_t</span> off, size;</span><br><span class="line">        <span class="type">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process's memory (la, la+end)</span></span><br><span class="line">        <span class="comment">// 3.6 分配内存和复制上下文</span></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">        <span class="comment">//(3.6.1) copy TEXT/DATA section of bianry program</span></span><br><span class="line">        <span class="comment">// 3.6.1 复制TEXT/DATA段</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            }</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la)</span><br><span class="line">            {</span><br><span class="line">                size -= la - end;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">memcpy</span>(page2kva(page) + off, from, size);</span><br><span class="line">            start += size, from += size;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(3.6.2) build BSS section of binary program</span></span><br><span class="line">        <span class="comment">// 3.6.2 参数段</span></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; la)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span></span><br><span class="line">            <span class="keyword">if</span> (start == end)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la)</span><br><span class="line">            {</span><br><span class="line">                size -= la - end;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            }</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la)</span><br><span class="line">            {</span><br><span class="line">                size -= la - end;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//(4) build user stack memory</span></span><br><span class="line">    <span class="comment">// 设置用户栈</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    }</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP - PGSIZE, PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP - <span class="number">2</span> * PGSIZE, PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP - <span class="number">3</span> * PGSIZE, PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP - <span class="number">4</span> * PGSIZE, PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(5) set current process's mm, sr3, and set CR3 reg = physical addr of Page Directory</span></span><br><span class="line">    <span class="comment">// 设置当前线程的mm表、cr3寄存器和CR3寄存器</span></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(6) setup trapframe for user environment</span></span><br><span class="line">    <span class="comment">// 设置用户环境的trapframe</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    <span class="comment">// 需要通过中断帧来实现中断返回</span></span><br><span class="line">    <span class="comment">// 这样才能正确切换到目标线程的上下文里</span></span><br><span class="line">    <span class="comment">// 此处修改的是current里的trapframe，即当前线程的tf</span></span><br><span class="line">    <span class="comment">/* LAB5:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment">     * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span></span><br><span class="line"><span class="comment">     * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So</span></span><br><span class="line"><span class="comment">     *          tf_cs should be USER_CS segment (see memlayout.h)</span></span><br><span class="line"><span class="comment">     *          tf_ds=tf_es=tf_ss should be USER_DS segment</span></span><br><span class="line"><span class="comment">     *          tf_esp should be the top addr of user stack (USTACKTOP)</span></span><br><span class="line"><span class="comment">     *          tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span></span><br><span class="line"><span class="comment">     *          tf_eflags should be set to enable computer to produce Interrupt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 用户堆栈</span></span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">    <span class="comment">// 设置下一条指令为程序入口</span></span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>load_icode函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行，完成了如下重要工作：</p>
<ul>
<li>调用<code>mm_create</code>函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化</li>
<li>调用<code>setup_pgdir</code>来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（boot_pgdir所指）的内容拷贝到此新目录表中，最后让mm-&gt;pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间</li>
<li>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用<code>mm_map</code>函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等）的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而<strong>表明了用户进程的合法用户态虚拟地址空间</strong></li>
<li>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此<strong>应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了</strong></li>
<li>需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;–&gt;物理地址映射关系</li>
<li>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm-&gt;pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，<strong>但此时这个用户进程的执行现场还没建立好</strong></li>
<li><strong>先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断</strong></li>
</ul>
<div class="note info">
            <p><strong>当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的</strong></p><ul><li>创建一个新的用户态进程后(<strong>可以参考一下<code>proc:init_main</code></strong>)，内核线程调用<code>schedule</code>函数，schedule函数在proc_list队列中查找下一个处于“就绪”态的用户态进程，然后调用<code>proc_run</code>来运行新进程。</li><li>随后proc_run根据上一个实验的调用流程，找到了kernel_thread_entry。而kernel_thread_entry先将edx保存的输入参数（NULL）压栈，然后通过call指令，跳转到ebx指向的函数，即user_main，user_main先打印userproc的pid和name信息，然后调用<code>kernel_execve</code>。</li><li>kernel_execve调用了exec系统调用，从而转入到了系统调用的处理例程。之后进行正常的中断处理例程，然后控制权转移到了syscall.c中的<code>syscall</code>函数，然后根据系统调用号转移给了<code>sys_exec</code>函数，在该函数中调用了<code>do_execve</code>函数来完成指定应用程序的加载。其调用流程为：vector128-&gt; __alltraps -&gt; trap -&gt; trap_dispatch -&gt; syscall -&gt;sys_exec -&gt; do_execve。</li><li>在do_execve中进行了若干设置，包括推出当前进程的页表，换用内核的PDT，调用<code>load_icode</code>函数完成对整个用户线程内存空间的初始化，包括堆栈的设置以及将ELF可执行文件的加载，之后通过current-&gt;tf指针修改了当前系统调用的trapframe，使得最终中断返回的时候能够切换到用户态，并且同时可以正确地将控制权转移到应用程序的入口处。</li><li>在完成了do_exec函数之后，进行正常的中断返回的流程，由于中断处理例程的栈上面的eip已经被修改成了应用程序的入口处，而CS上的CPL是用户态，因此iret进行中断返回的时候会将堆栈切换到用户的栈，并且完成特权级的切换，并且跳转到要求的应用程序的入口处，开始执行应用程序的第一条代码。</li></ul>
          </div>
<h3 id="x02-父进程复制自己的内存空间给子进程">0X02
父进程复制自己的内存空间给子进程</h3>
<p>创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，我们需要完善这个函数，从而保证复制正常执行。</p>
<p>其调用栈为do_fork()----&gt;copy_mm()----&gt;dup_mmap()----&gt;copy_range()。<strong>在lab4中，copy_mm是空的，因为内核线程常驻内存，不需要mm和调度，所以不需要设置子进程的mm</strong>，但是用户线程需要复制父进程的内存空间。</p>
<p>我们先看一下这些函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// copy_mm - process "proc" duplicate OR share process "current"'s mm according clone_flags</span></span><br><span class="line"><span class="comment">//         - if clone_flags &amp; CLONE_VM, then "share" ; else "duplicate"</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_mm</span><span class="params">(<span class="type">uint32_t</span> clone_flags, <span class="keyword">struct</span> proc_struct *proc)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span> =</span> current-&gt;mm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* current is a kernel thread */</span></span><br><span class="line">    <span class="comment">// 内核线程不需要复制地址空间</span></span><br><span class="line">    <span class="keyword">if</span> (oldmm == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写时复制，目前没有，不会进入此if</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VM)</span><br><span class="line">    {</span><br><span class="line">        mm = oldmm;</span><br><span class="line">        <span class="keyword">goto</span> good_mm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般情况下，进程复制</span></span><br><span class="line">    <span class="type">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">// 创建子进程的mm</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置子进程的页目录</span></span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    lock_mm(oldmm);</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 执行复制</span></span><br><span class="line">        ret = dup_mmap(mm, oldmm);</span><br><span class="line">    }</span><br><span class="line">    unlock_mm(oldmm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_dup_cleanup_mmap;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">good_mm:</span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    proc-&gt;mm = mm;</span><br><span class="line">    proc-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">bad_dup_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制mm的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup_mmap</span><span class="params">(<span class="keyword">struct</span> mm_struct *to, <span class="keyword">struct</span> mm_struct *from)</span></span><br><span class="line">{</span><br><span class="line">    assert(to != <span class="literal">NULL</span> &amp;&amp; from != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">list_entry_t</span> *<span class="built_in">list</span> = &amp;(from-&gt;mmap_list), *le = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span> ((le = list_prev(le)) != <span class="built_in">list</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span>, *<span class="title">nvma</span>;</span></span><br><span class="line">        vma = le2vma(le, list_link);</span><br><span class="line">        nvma = vma_create(vma-&gt;vm_start, vma-&gt;vm_end, vma-&gt;vm_flags);</span><br><span class="line">        <span class="keyword">if</span> (nvma == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        insert_vma_struct(to, nvma);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> share = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 逐个复制其中的每个VMM</span></span><br><span class="line">        <span class="keyword">if</span> (copy_range(to-&gt;pgdir, from-&gt;pgdir, vma-&gt;vm_start, vma-&gt;vm_end, share) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy_range - copy content of memory (start, end) of one process A to another process B</span></span><br><span class="line"><span class="comment"> * @to:    the addr of process B's Page Directory</span></span><br><span class="line"><span class="comment"> * @from:  the addr of process A's Page Directory</span></span><br><span class="line"><span class="comment"> * @share: flags to indicate to dup OR share. We just use dup method, so it didn't be used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CALL GRAPH: copy_mm--&gt;dup_mmap--&gt;copy_range</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_range</span><span class="params">(<span class="type">pde_t</span> *to, <span class="type">pde_t</span> *from, <span class="type">uintptr_t</span> start, <span class="type">uintptr_t</span> end, <span class="type">bool</span> share)</span></span><br><span class="line">{</span><br><span class="line">    assert(start % PGSIZE == <span class="number">0</span> &amp;&amp; end % PGSIZE == <span class="number">0</span>);</span><br><span class="line">    assert(USER_ACCESS(start, end));</span><br><span class="line">    <span class="comment">// copy content by page unit.</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// call get_pte to find process A's pte according to the addr start</span></span><br><span class="line">        <span class="comment">// 从父进程中的页表中找到对应的页表项</span></span><br><span class="line">        <span class="type">pte_t</span> *ptep = get_pte(from, start, <span class="number">0</span>), *nptep;</span><br><span class="line">        <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            start = ROUNDDOWN(start + PTSIZE, PTSIZE);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// call get_pte to find process B's pte according to the addr start. If pte is NULL, just alloc a PT</span></span><br><span class="line">        <span class="comment">// 然后在子进程里找到对应的，找不到就新建一个，然后把父进程的复制过去</span></span><br><span class="line">        <span class="keyword">if</span> (*ptep &amp; PTE_P)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> ((nptep = get_pte(to, start, <span class="number">1</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">uint32_t</span> perm = (*ptep &amp; PTE_USER);</span><br><span class="line">            <span class="comment">// get page from ptep</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep);</span><br><span class="line">            <span class="comment">// alloc a page for process B</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">npage</span> =</span> alloc_page();</span><br><span class="line">            assert(page != <span class="literal">NULL</span>);</span><br><span class="line">            assert(npage != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* LAB5:EXERCISE2 YOUR CODE</span></span><br><span class="line"><span class="comment">             * replicate content of page to npage, build the map of phy addr of nage with the linear addr start</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">             * MACROs or Functions:</span></span><br><span class="line"><span class="comment">             *    page2kva(struct Page *page): return the kernel vritual addr of memory which page managed (SEE pmm.h)</span></span><br><span class="line"><span class="comment">             *    page_insert: build the map of phy addr of an Page with the linear addr la</span></span><br><span class="line"><span class="comment">             *    memcpy: typical memory copy function</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * (1) find src_kvaddr: the kernel virtual address of page</span></span><br><span class="line"><span class="comment">             * (2) find dst_kvaddr: the kernel virtual address of npage</span></span><br><span class="line"><span class="comment">             * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE</span></span><br><span class="line"><span class="comment">             * (4) build the map of phy addr of  nage with the linear addr start</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 复制page的内容到npage，建立npage的物理地址与线性地址开始的映射。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取源(src)页面所在的虚拟地址（注意，此时的PDT是内核状态下的页目录表）</span></span><br><span class="line">            <span class="type">void</span> *kva_src = page2kva(page);</span><br><span class="line">            <span class="comment">// 获取目标(dst)页面所在的虚拟地址</span></span><br><span class="line">            <span class="type">void</span> *kva_dst = page2kva(npage);</span><br><span class="line">            <span class="comment">// 页面数据复制</span></span><br><span class="line">            <span class="built_in">memcpy</span>(kva_dst, kva_src, PGSIZE);</span><br><span class="line">            <span class="comment">// 将该页面设置至对应的PTE中</span></span><br><span class="line">            ret = page_insert(to, npage, start, perm);</span><br><span class="line"></span><br><span class="line">            assert(ret == <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        start += PGSIZE;</span><br><span class="line">    } <span class="keyword">while</span> (start != <span class="number">0</span> &amp;&amp; start &lt; end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实copy_range就是将进程A的内存复制到进程B里，不过这里并不是写时复制，而是全部复制，这样会浪费比较严重。</p>
<h3 id="x03-系统调用函数们">0X03 系统调用函数们</h3>
<ul>
<li>do_fork
<ul>
<li>分配并初始化进程控制块（alloc_proc函数）。</li>
<li>分配并初始化内核栈（setup_stack函数）。</li>
<li>对当前进程等待状态的检查。</li>
<li>根据clone_flag标志复制或共享进程内存管理结构（copy_mm函数）。</li>
<li>设置进程在内核（将来也包括用户态）正常运行和调度所需的中断帧和执行上下文（copy_thread函数）。</li>
<li>把设置好的进程控制块放入hash_list和proc_list两个全局进程链表中，并且设置set_links。</li>
<li>自此，进程已经准备好执行了，把进程状态设置为“就绪”态。</li>
<li>设置返回码为子进程的id号。</li>
</ul></li>
<li>do_execve
<ul>
<li>调用exit_mmap(mm)和put_pgdir(mm)来回收当前进程内存空间的所有资源（仅保留了PCB）。</li>
<li>调用load_icode根据可执行文件分配特定位置的虚拟内存空间。</li>
<li><strong>该函数会释放除了PCB以外所有的原进程的资源</strong></li>
</ul></li>
<li>do_wait
<ul>
<li>检查当前进程分配的内存区域是否正常。</li>
<li>查找特定/所有子进程中是否存在某个等待的父进程回收的子进程（PROC_ZOMBIE状态）。如果有则回收该进程返回，如果没有则设置当前进程为PROC_SLEEPING并执行schedule调度其他进程运行。当前进程的某个子进程结束运行后，当前进程会被唤醒，并在do_wait函数中回收子进程的PCB内存资源。</li>
</ul></li>
<li>do_exit
<ul>
<li>调用exit_mmap，put_pgdir和mm_destroy来释放进程几乎所有的内存空间。</li>
<li>将进程状态设置为僵死模式，然后调用wakeup_proc(parent)来让父进程回收这个进程。</li>
<li>调用scheduler来切换到其他进程。</li>
</ul></li>
</ul>
<p>这些函数是具体处理系统调用的函数，这些系统调用函数都被组织成数组，以快速访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">uint32_t</span> arg[])</span> = {</span><br><span class="line">    [SYS_exit]              sys_exit,</span><br><span class="line">    [SYS_fork]              sys_fork,</span><br><span class="line">    [SYS_wait]              sys_wait,</span><br><span class="line">    [SYS_exec]              sys_exec,</span><br><span class="line">    [SYS_yield]             sys_yield,</span><br><span class="line">    [SYS_kill]              sys_kill,</span><br><span class="line">    [SYS_getpid]            sys_getpid,</span><br><span class="line">    [SYS_putc]              sys_putc,</span><br><span class="line">    [SYS_pgdir]             sys_pgdir,</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当系统调用中断发生后，会执行syscall函数，这个函数会从上述数组中选择出对应的系统调用以执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="type">uint32_t</span> arg[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (syscalls[num] != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            arg[<span class="number">0</span>] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[<span class="number">1</span>] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[<span class="number">2</span>] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[<span class="number">3</span>] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[<span class="number">4</span>] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            <span class="comment">// 从数组中选择出函数并执行</span></span><br><span class="line">            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(<span class="string">"undefined syscall %d, pid = %d, name = %s.\n"</span>,</span><br><span class="line">          num, current-&gt;pid, current-&gt;name);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>等相应的内核函数结束后，程序通过之前保留的trapframe返回用户态。一次系统调用结束。</p>
<ul>
<li>在fork完成后，会修改子进程状态为可执行，但是父进程不变</li>
<li>exec不修改当前进程的状态，但是会替换内存空间的所有数据和代码</li>
<li>wait会先检测是否存在子进程，如果存在僵尸子进程，就回收；否则会阻塞父进程为睡眠状态，并等待子进程唤醒</li>
<li>exit会将当前进程的状态设置为僵尸状态，并唤醒父进程，使其为可运行状态</li>
</ul>
<h3 id="x04-总结">0X04 总结</h3>
<p>通过这个lab5，我们学习了以下内容:</p>
<ul>
<li>学习用户进程和内核进程的区别</li>
<li>了解在没有文件系统的情况下，用户线程是如何加载的(execve)</li>
<li>系统调用的中断的处理，以及系统调用的实现</li>
<li>创建用户子进程时的处理，包括加载用户程序，复制内存空间，复制trapframe等</li>
<li>创建完成后如何进行中断返回从而到的对应的上下文中</li>
<li>fork是复制一个一模一样的线程、execve是执行另一个线程。本lab中是直接在内核线程中加载用户线程并切换到相应的上下文</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>ucore操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>从ucore来总结操作系统(7)----互斥、同步和信号量</title>
    <url>/2023/01/24/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-7/</url>
    <content><![CDATA[<h2 id="互斥同步和信号量">互斥、同步和信号量</h2>
<span id="more"></span>
<h3 id="x00-环境准备">0X00 环境准备</h3>
<p>本lab基于前所有lab，但是需要对其进行一些扩展：</p>
<p>其实就只要修改一个中断函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// kern/trap/trap.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">    ticks++;</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    run_timer_list();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里将原来的函数(调度器的时间片中断函数)修改成<code>run_timer_list</code>。这是因为引入了定时器的原因，我们来看一下这个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// call scheduler to update tick related info, and check the timer is expired? If expired, then wakup proc</span></span><br><span class="line"><span class="comment">// 检查时间片中断时，是否存在timer过期，如果存在，就唤醒对应线程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_timer_list</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    <span class="comment">// 关闭中断</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    {</span><br><span class="line">        <span class="type">list_entry_t</span> *le = list_next(&amp;timer_list);</span><br><span class="line">        <span class="comment">// 找到所有的定时器，并将其递减</span></span><br><span class="line">        <span class="comment">// 如果存在定时器过期，就调度对应的线程</span></span><br><span class="line">        <span class="keyword">if</span> (le != &amp;timer_list)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">timer_t</span> *timer = le2timer(le, timer_link);</span><br><span class="line">            assert(timer-&gt;expires != <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 注意，只有第一个timer会--，其余的不会，这里后面会说明</span></span><br><span class="line">            timer-&gt;expires--;</span><br><span class="line">            <span class="keyword">while</span> (timer-&gt;expires == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                le = list_next(le);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> timer-&gt;proc;</span><br><span class="line">                <span class="keyword">if</span> (proc-&gt;wait_state != <span class="number">0</span>)</span><br><span class="line">                {</span><br><span class="line">                    assert(proc-&gt;wait_state &amp; WT_INTERRUPTED);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    warn(<span class="string">"process %d's wait_state == 0.\n"</span>, proc-&gt;pid);</span><br><span class="line">                }</span><br><span class="line">                wakeup_proc(proc);</span><br><span class="line">                del_timer(timer);</span><br><span class="line">                <span class="keyword">if</span> (le == &amp;timer_list)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                timer = le2timer(le, timer_link);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 然后执行时间片中断函数</span></span><br><span class="line">        sched_class_proc_tick(current);</span><br><span class="line">    }</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note primary">
            <p><strong>注意上面只会对第一个timer--，这是由于timer的构造决定的</strong></p><p>timer_t结构用于存储一个定时器所需要的相关数据，包括倒计时时间以及所绑定的进程。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 过期时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> expires;       <span class="comment">//the expire time</span></span><br><span class="line">    <span class="comment">// timer对应的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span>   <span class="comment">//the proc wait in this timer. If the expire time is end, then this proc will be scheduled</span></span><br><span class="line">    <span class="comment">// timer的链表入口</span></span><br><span class="line">    <span class="type">list_entry_t</span> timer_link;    <span class="comment">//the timer list</span></span><br><span class="line">} <span class="type">timer_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而add_timer用于将某个timer添加进timer列表中。但出于性能考虑，每个新添加的timer都会按照其expires属性的大小排列，同时减去上一个timer的expires(即每个timer都是前缀，这样每次做减法的时候性能大大提升)。<strong>在更新timer_list中的所有timer的expires时，只需递减链首的第一个timer的expire，即可间接达到所有timer的expires减一的目的。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">add_timer(<span class="type">timer_t</span> *timer)</span><br><span class="line">{</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    {</span><br><span class="line">        assert(timer-&gt;expires &gt; <span class="number">0</span> &amp;&amp; timer-&gt;proc != <span class="literal">NULL</span>);</span><br><span class="line">        assert(list_empty(&amp;(timer-&gt;timer_link)));</span><br><span class="line">        <span class="type">list_entry_t</span> *le = list_next(&amp;timer_list);</span><br><span class="line">        <span class="comment">// 先找到正确的位置</span></span><br><span class="line">        <span class="keyword">while</span> (le != &amp;timer_list)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">timer_t</span> *next = le2timer(le, timer_link);</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires &lt; next-&gt;expires)</span><br><span class="line">            {</span><br><span class="line">                next-&gt;expires -= timer-&gt;expires;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            timer-&gt;expires -= next-&gt;expires;</span><br><span class="line">            le = list_next(le);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        list_add_before(le, &amp;(timer-&gt;timer_link));</span><br><span class="line">    }</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>del_timer函数将timer从list中移除。将timer从timer_list中删除的操作比较简单：设置好当前待移除timer的下一个timer-&gt;expires，并将当前timer从链表中移除即可。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_timer</span><span class="params">(<span class="type">timer_t</span> *timer)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;(timer-&gt;timer_link)))</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 当移除一个未过期的定时器时</span></span><br><span class="line">            <span class="comment">// 需要这个未过期的定时的值添加到后面的定时器上</span></span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires != <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="type">list_entry_t</span> *le = list_next(&amp;(timer-&gt;timer_link));</span><br><span class="line">                <span class="keyword">if</span> (le != &amp;timer_list)</span><br><span class="line">                {</span><br><span class="line">                    <span class="type">timer_t</span> *next = le2timer(le, timer_link);</span><br><span class="line">                    next-&gt;expires += timer-&gt;expires;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 否则如果是超时过期，就直接移除就行</span></span><br><span class="line">            list_del_init(&amp;(timer-&gt;timer_link));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>定时器是相当重要的软件结构，为所有的线程提供了一个统一的超时机制。</strong></p>
          </div>
<h3 id="x01-内核级信号量">0X01 内核级信号量</h3>
<p>由于时间片中断可以发生在某个进程执行的任意位置，而时间片中断会引发进程调度，所以可能会引起竞争，这些操作系统书上会讲的比较详细，此处不再赘诉。</p>
<h4 id="信号量">信号量</h4>
<p>为了防止互斥，所以需要支持<strong>信号量</strong>以用来加锁，但是如果进程A在临界区消耗时间过长，则其他需要进入临界区的线程就需要不断等待，为了<strong>避免自旋等待</strong>，所以需要支持<strong>睡眠等待</strong>，因此需要引入<strong>等待队列</strong>。</p>
<p>我们先来看一下信号量，其位于<code>kern/sync/sem.h</code>中，信号量的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 信号量的值</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 信号量对应的等待队列</span></span><br><span class="line">    <span class="type">wait_queue_t</span> wait_queue;</span><br><span class="line">} <span class="type">semaphore_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">semaphore_t</span> *sem, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">// 释放一个信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">// 获取一个信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">// 测试并获取一个信号量</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">try_down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始时，信号量中的值表示可以最多同时支持多少线程进入。当执行<code>down</code>函数时，会尝试将value--，如果value_new
&gt;=
0则说明当前进程可以获取锁，<strong>这些操作都是原子的</strong>。如果value_new
&lt;=
0，则说明当前进程需要等待，所以会将当前进程加入到等待队列中，然后调用<code>schedule</code>函数进行进程调度，直到有其他进程调用<code>up</code>函数，将value++，然后唤醒等待队列中的进程。</p>
<div class="note info">
            <p><strong>原子操作</strong></p><p>由于时间片中断可以发生在某个进程执行的任意位置，那么自然也会发生在尝试对value--的过程中，也就是一个线程在执行<code>down</code>函数时，另一个线程也在执行<code>down</code>函数，这样就会导致value的值不准确，这就引出了<strong>原子操作</strong>。</p><p>在硬件上，中断信号可以发生在任意位置，但是只有CPU执行完一条指令后才会去检查中断信号，所以在执行一条指令时，中断信号是不会发生的，<strong>如果能保证我们某一任务能在一条CPU指令内完成，那么该任务对应的操作就是原子操作，原子操作能从硬件上保证不会发生竞争</strong></p><p>当然除了CPU对应的原子操作外，还有一些<strong>软件构造的原子操作</strong>，比如先关闭中断(关闭中断是硬件上的原子操作)，然后执行一些可能会引起竞争的代码，最后打开中断(同样是硬件上的原子操作)，这样中间部分的代码就不会被中断打断，保证了原子性。</p>
          </div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">semaphore_t</span> *sem, <span class="type">int</span> value)</span></span><br><span class="line">{</span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line">    wait_queue_init(&amp;(sem-&gt;wait_queue));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量的up操作</span></span><br><span class="line"><span class="type">static</span> __noinline <span class="type">void</span> __up(<span class="type">semaphore_t</span> *sem, <span class="type">uint32_t</span> wait_state)</span><br><span class="line">{</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    <span class="comment">// 保证原子性</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    {</span><br><span class="line">        <span class="type">wait_t</span> *wait;</span><br><span class="line">        <span class="comment">// 如果不存在其他需要占用信号量的进程，就对value++</span></span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            sem-&gt;value++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则，需要调度出这个等待队列中的进程，然后唤醒执行</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 保证等待队列中的对应线程的状态是wait_state</span></span><br><span class="line">            <span class="comment">// wait_state是线程的等待原因</span></span><br><span class="line">            assert(wait-&gt;proc-&gt;wait_state == wait_state);</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量的down操作</span></span><br><span class="line"><span class="type">static</span> __noinline <span class="type">uint32_t</span> __down(<span class="type">semaphore_t</span> *sem, <span class="type">uint32_t</span> wait_state)</span><br><span class="line">{</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="comment">// 大于0直接--，然后返回</span></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        sem-&gt;value--;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，需要将当前进程加入到等待队列中</span></span><br><span class="line">    <span class="type">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后调度到其他线程上</span></span><br><span class="line">    schedule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果被V操作唤醒，则把自身关联的wait从等待队列中删除</span></span><br><span class="line">    <span class="comment">// （此过程需要先关中断，完成后开中断）</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    wait_current_del(&amp;(sem-&gt;wait_queue), wait);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果等待线程的状态与预期不符，就返回(最终其实会报错)</span></span><br><span class="line">    <span class="keyword">if</span> (wait-&gt;wakeup_flags != wait_state)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> wait-&gt;wakeup_flags;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span></span><br><span class="line">{</span><br><span class="line">    __up(sem, WT_KSEM);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> flags = __down(sem, WT_KSEM);</span><br><span class="line">    assert(flags == <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取信号量，不会直接阻塞</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">try_down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">bool</span> intr_flag, ret = <span class="number">0</span>;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        sem-&gt;value--, ret = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>信号量的实现还是依赖于等待队列的实现，当信号量down时如果失败会将当前线程加入等待队列，然后调度到其他线程上，当信号量up时会从等待队列中唤醒一个等待线程。</p>
<p><strong>当一个线程加入等待队列时，还需要用一个标志位来注明该线程是因为什么等待</strong>(此处是信号量等待)，<strong>且当一个因信号量等待的线程在唤醒时仍然会执行_down函数中剩余的部分(也就是把自身移除等待队列)</strong>。</p>
<h4 id="等待队列">等待队列</h4>
<p>等待队列也是另一个重要组件，它存储了所有等待中的线程，当一个线程因为某种原因等待时，会将自身加入到等待队列中，同时等待队列也会存储该线程因为什么阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 等待进程的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span>   </span><br><span class="line">    <span class="comment">//进程被放入等待队列的原因标记  </span></span><br><span class="line">    <span class="type">uint32_t</span> wakeup_flags;        </span><br><span class="line">    <span class="comment">//指向此wait结构所属于的wait_queue</span></span><br><span class="line">    <span class="type">wait_queue_t</span> *wait_queue;     </span><br><span class="line">    <span class="comment">//用来组织wait_queue中wait节点的连接</span></span><br><span class="line">    <span class="type">list_entry_t</span> wait_link;       </span><br><span class="line">} <span class="type">wait_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这与run_queue类似，总体结构也十分简单。我们来看一下其相关函数，不过考虑到其函数很多，就。略过简单的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 初始化wait结构体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait_init</span><span class="params">(<span class="type">wait_t</span> *wait, <span class="keyword">struct</span> proc_struct *proc)</span>;</span><br><span class="line"><span class="comment">// 初始化wq中的队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait_queue_init</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="comment">// wq添加</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait_queue_add</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait)</span>;</span><br><span class="line"><span class="comment">// wq删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait_queue_del</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wq查找操作</span></span><br><span class="line"><span class="type">wait_t</span> *<span class="title function_">wait_queue_next</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait)</span>;</span><br><span class="line"><span class="type">wait_t</span> *<span class="title function_">wait_queue_prev</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait)</span>;</span><br><span class="line"><span class="type">wait_t</span> *<span class="title function_">wait_queue_first</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">wait_t</span> *<span class="title function_">wait_queue_last</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wq判断操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">wait_queue_empty</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">wait_in_queue</span><span class="params">(<span class="type">wait_t</span> *wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒与wait关联的进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wakeup_wait</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait, <span class="type">uint32_t</span> wakeup_flags, <span class="type">bool</span> del)</span>;</span><br><span class="line"><span class="comment">// 唤醒wq第一个线程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wakeup_first</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">uint32_t</span> wakeup_flags, <span class="type">bool</span> del)</span>;</span><br><span class="line"><span class="comment">// 唤醒wq所有线程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wakeup_queue</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">uint32_t</span> wakeup_flags, <span class="type">bool</span> del)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让 wait与进程关联，且让当前进程关联的wait进入等待队列queue，当前进程睡眠</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait_current_set</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait, <span class="type">uint32_t</span> wait_state)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面两张是调用关系图:</p>
<img src="/2023/01/24/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-7/pic1.png" class="">
<img src="/2023/01/24/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-7/pic2.png" class="">
<h3 id="x02-内核级条件变量和管程">0X02 内核级条件变量和管程</h3>
<p>之前实现的是信号量，通过信号量能实现简单的线程通信，但是存在以下的局限：</p>
<ul>
<li>信号量有点类似于资源的总数，在生产者-消费者这样的模式下存在同步问题(比如消费者先获取信号量，生产者无法获取，因此无法通知消费者。当然更复杂的逻辑可以实现生-消模式，但是<strong>复杂</strong>)</li>
<li>信号量一次只能唤醒一个线程，但有时我们需要广播(比如actor模式)</li>
<li>信号量内部定义value限制了其局限性，只能对int类型资源同步，但有时想要同步其他类型的资源(比如a队列和b队列长度相等)</li>
</ul>
<p>但是，条件变量是基于信号量实现的，可以看成是对信号量的进一步封装。<strong>信号量=条件变量+互斥锁</strong></p>
<p>管程是一种程序结构，该结构内多个子程序形成多个线程互斥访问共享资源。</p>
<p>条件变量和管程在<code>kern/sync/monitor.c</code>中实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> <span class="title">monitor_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 信号量，用于等待和唤醒</span></span><br><span class="line">    <span class="type">semaphore_t</span> sem;        <span class="comment">// the sem semaphore  is used to down the waiting proc, and the signaling proc should up the waiting proc</span></span><br><span class="line">    <span class="comment">// 条件变量中等待的线程数</span></span><br><span class="line">    <span class="type">int</span> count;              <span class="comment">// the number of waiters on condvar</span></span><br><span class="line">    <span class="comment">// 指向拥有该条件变量的管程</span></span><br><span class="line">    <span class="type">monitor_t</span> * owner;      <span class="comment">// the owner(monitor) of this condvar</span></span><br><span class="line">} <span class="type">condvar_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 管程锁，值应为1</span></span><br><span class="line">    <span class="type">semaphore_t</span> mutex;      <span class="comment">// the mutex lock for going into the routines in monitor, should be initialized to 1</span></span><br><span class="line">    <span class="comment">// 比较复杂，下面说明</span></span><br><span class="line">    <span class="type">semaphore_t</span> next;       <span class="comment">// the next semaphore is used to down the signaling proc itself, and the other OR wakeuped waiting proc should wake up the sleeped signaling proc.</span></span><br><span class="line">    <span class="comment">// 和next一起用</span></span><br><span class="line">    <span class="type">int</span> next_count;         <span class="comment">// the number of of sleeped signaling proc</span></span><br><span class="line">    <span class="comment">// 条件变量(数组)</span></span><br><span class="line">    <span class="type">condvar_t</span> *cv;          <span class="comment">// the condvars in monitor</span></span><br><span class="line">} <span class="type">monitor_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>管程中的成员变量mutex是一个二值信号量，是实现<strong>每次只允许一个进程进入管程的关键元素，确保了互斥访问性质</strong>。管程中的条件变量cv，<strong>某线程通过执行wait_cv，会使得等待某个条件Cond为真的进程能够离开管程并睡眠，且让其他进程进入管程继续执行</strong>；而进入管程的<strong>某进程设置条件Cond为真并执行signal_cv时，能够让等待某个条件Cond为真的睡眠进程被唤醒</strong>，从而继续进入管程中执行。</p>
<p>管程中的成员变量信号量<strong>next</strong>和整型变量<strong>next_count</strong>是配合进程对条件变量cv的操作而设置的，这是由于发出signal_cv的进程A会唤醒由于wait_cv而睡眠的进程B，由于管程中只允许一个进程运行，所以进程B执行会导致唤醒进程B的进程A睡眠，直到进程B离开管程，进程A才能继续执行，<strong>这个同步过程是通过信号量next完成的；而next_count表示了由于发出singal_cv(没写错)而睡眠的进程个数。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Initialize monitor.</span></span><br><span class="line"><span class="comment">// 初始化管程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">monitor_init</span><span class="params">(<span class="type">monitor_t</span> *mtp, <span class="type">size_t</span> num_cv)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    assert(num_cv &gt; <span class="number">0</span>);</span><br><span class="line">    mtp-&gt;next_count = <span class="number">0</span>;</span><br><span class="line">    mtp-&gt;cv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 初始化管程信号量</span></span><br><span class="line">    sem_init(&amp;(mtp-&gt;mutex), <span class="number">1</span>); <span class="comment">// unlocked</span></span><br><span class="line">    sem_init(&amp;(mtp-&gt;next), <span class="number">0</span>);  <span class="comment">// 注意next为0，表示next资源为0</span></span><br><span class="line">    <span class="comment">// 分配当前管程内的条件变量</span></span><br><span class="line">    mtp-&gt;cv = (<span class="type">condvar_t</span> *)kmalloc(<span class="keyword">sizeof</span>(<span class="type">condvar_t</span>) * num_cv);</span><br><span class="line">    assert(mtp-&gt;cv != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_cv; i++)</span><br><span class="line">    {</span><br><span class="line">        mtp-&gt;cv[i].count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化条件变量信号量</span></span><br><span class="line">        sem_init(&amp;(mtp-&gt;cv[i].sem), <span class="number">0</span>);</span><br><span class="line">        mtp-&gt;cv[i].owner = mtp;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock one of threads waiting on the condition variable.</span></span><br><span class="line"><span class="comment">// 当某个线程准备离开临界区、准备释放对应的条件变量时</span></span><br><span class="line"><span class="comment">// 线程会执行函数cond_signal</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cond_signal</span><span class="params">(<span class="type">condvar_t</span> *cvp)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">    cprintf(<span class="string">"cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *      cond_signal(cv) {</span></span><br><span class="line"><span class="comment">     *          if(cv.count&gt;0) {</span></span><br><span class="line"><span class="comment">     *             mt.next_count ++;</span></span><br><span class="line"><span class="comment">     *             signal(cv.sem);</span></span><br><span class="line"><span class="comment">     *             wait(mt.next);</span></span><br><span class="line"><span class="comment">     *             mt.next_count--;</span></span><br><span class="line"><span class="comment">     *          }</span></span><br><span class="line"><span class="comment">     *       }</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 如果该条件变量中等待的线程数大于0</span></span><br><span class="line">    <span class="keyword">if</span> (cvp-&gt;count &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// cvp-&gt;owner是管程，管程中等待的线程数+1(这个+1表示自身将进入等待)</span></span><br><span class="line">        cvp-&gt;owner-&gt;next_count++;</span><br><span class="line">        <span class="comment">// 条件变量中信号量+1，表示解锁一个等待的线程(可能会唤醒一个线程)</span></span><br><span class="line">        up(&amp;(cvp-&gt;sem));</span><br><span class="line">        <span class="comment">// 管程中next信号量-1，由于next初始值为0，所以当前线程会立刻阻塞</span></span><br><span class="line">        <span class="comment">// 这是由于上一步唤醒了一个线程，而管程不允许两个线程运行</span></span><br><span class="line">        <span class="comment">// 所以需要挂起当前线程</span></span><br><span class="line">        down(&amp;(cvp-&gt;owner-&gt;next));</span><br><span class="line">        <span class="comment">// 管程中等待的线程数-1(表示自身已经离开等待)</span></span><br><span class="line">        cvp-&gt;owner-&gt;next_count--;</span><br><span class="line">    }</span><br><span class="line">    cprintf(<span class="string">"cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Suspend calling thread on a condition variable waiting for condition Atomically unlocks</span></span><br><span class="line"><span class="comment">// mutex and suspends calling thread on conditional variable after waking up locks mutex. Notice: mp is mutex semaphore for monitor's procedures</span></span><br><span class="line"><span class="comment">// 当某个线程需要等待锁时，则会执行cond_wait函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cond_wait</span><span class="params">(<span class="type">condvar_t</span> *cvp)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">    cprintf(<span class="string">"cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *         cv.count ++;</span></span><br><span class="line"><span class="comment">     *         if(mt.next_count&gt;0)</span></span><br><span class="line"><span class="comment">     *            signal(mt.next)</span></span><br><span class="line"><span class="comment">     *         else</span></span><br><span class="line"><span class="comment">     *            signal(mt.mutex);</span></span><br><span class="line"><span class="comment">     *         wait(cv.sem);</span></span><br><span class="line"><span class="comment">     *         cv.count --;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 表示自身因等待条件变量而阻塞，因此记录在条件变量中</span></span><br><span class="line">    cvp-&gt;count++;</span><br><span class="line">    <span class="comment">// 如果管程中等待的线程数大于0</span></span><br><span class="line">    <span class="keyword">if</span> (cvp-&gt;owner-&gt;next_count &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 那么就唤醒一个等待的线程</span></span><br><span class="line">        up(&amp;(cvp-&gt;owner-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则释放互斥锁</span></span><br><span class="line">        up(&amp;(cvp-&gt;owner-&gt;mutex));</span><br><span class="line">    <span class="comment">// 阻塞自身</span></span><br><span class="line">    down(&amp;(cvp-&gt;sem));</span><br><span class="line">    <span class="comment">// 至此说明阻塞结束了，因此条件变量中等待的线程数-1</span></span><br><span class="line">    cvp-&gt;count--;</span><br><span class="line">    cprintf(<span class="string">"cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于条件变量依附于管程，而管程和条件变量信号量比较多，下面一一说明：</p>
<ul>
<li>条件变量内的信号量：用于唤醒<strong>等待该条件变量</strong>的线程</li>
<li>条件变量的count：用于记录<strong>等待该条件变量的线程数</strong></li>
<li>管程内的mutex信号量：用于保证<strong>管程中只有一个线程在运行</strong></li>
<li>管程内的next信号量：用于<strong>快速阻塞调用signal_cv的线程，以便唤醒等待该条件变量的线程，从而保证管程只有一个线程在运行</strong></li>
<li>管程内的next_count：用于记录<strong>因调用signal_cv而阻塞的线程数</strong></li>
</ul>
<p>信号量next的初始值为0，所以任何尝试访问该信号量的线程都会阻塞，这是一个用于快速阻塞自身的信号量。一个线程调用signal_cv时，由于会唤醒其他线程，不能保证管程一个线程的限制，所以需要next来阻塞自身。</p>
<p>当一个线程调用wait_cv，等不到条件变量时会阻塞自身，因此先看看管程中是否存在因调用signal_cv而阻塞线程，要是有的话，就直接唤醒一个，由于此时锁没有被释放，而是相当"转移"，所以管程仍然能正常工作。当然，如果没有的话，就释放锁，把管程解放出来，然后阻塞自身，等待条件变量的信号量。</p>
<p>为了让整个管程正常运行，还需在管程中的每个函数的入口和出口增加相关操作，即：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">monitorFunc</span><span class="params">()</span> </span><br><span class="line">{</span><br><span class="line">     down(&amp;(mtp-&gt;mutex));</span><br><span class="line"><span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"><span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">      <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">         up(&amp;(mtp-&gt;next));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         up(&amp;(mtp-&gt;mutex));</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样做的好处有两个：</p>
<ul>
<li>只有一个进程在执行管程中的函数。</li>
<li>避免由于执行了cond_signal函数而睡眠的进程无法被唤醒：
<ul>
<li>管程中wait和signal函数的调用存在时间顺序。例如：当线程1先调用signal唤醒线程2并将自身线程挂起后，线程2在开始执行时将无法唤醒原先的在signal中挂起的线程1。</li>
<li>也就是说，只要存在线程在管程中执行了signal，那么至少存在一个线程在管程中被挂起。</li>
<li>此时，就只能在临界区外唤醒挂起的线程1，而这一步在代码中也得到了实现。</li>
</ul></li>
</ul>
<h3 id="x03-总结">0X03 总结</h3>
<p>通过这个lab7，我们学习了以下内容:</p>
<ul>
<li>软件定时器的实现与功能</li>
<li>信号量的实现方式(基于等待队列)</li>
<li>条件变量和管程(基于信号量)</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>ucore操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(13)--缓存Cache</title>
    <url>/2022/10/21/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-13/</url>
    <content><![CDATA[<h2 id="缓存cache">缓存Cache</h2>
<span id="more"></span>
<div class="note primary">
            <p>源码位置</p><p>include/leveldb/cache.h: 定义Cache接口<br>util/cache.cc: 实现LRU缓存<br>table/table.cc: 读取Data Block时使用缓存<br>db/table_cache.cc：实现一个Table结构的缓存</p>
          </div>
<p>正如存储器山所描述的那样，各个存储器之间的速度差距非常显著。所以对访问速度较慢的部分使用缓存是非常有必要的。</p>
<p>其中在levelDB中，主要有TableCache和BlockCache这两种缓存。TableCache主要是缓存SST文件里面的data
block index，而BlockCache主要是缓存data block。</p>
<p>LevelDB提供了一个Cache接口，用户可以实现自己的缓存方式。默认提供了一个LRU
Cache，缓存最近使用的数据。</p>
<h3 id="缓存的接口">缓存的接口</h3>
<p>我们首先来看一下Cache的接口类，同样，这也是一个纯虚基类，官方默认提供了一个使用LRU策略的Cache。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建一个有固定容量的基于LRU策略的缓存并返回</span></span><br><span class="line"><span class="function">LEVELDB_EXPORT Cache *<span class="title">NewLRUCache</span><span class="params">(<span class="type">size_t</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> Cache</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造析构函数...</span></span><br><span class="line">    <span class="built_in">Cache</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Cache</span>(<span class="type">const</span> Cache &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Cache &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Cache &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// Destroys all existing entries by calling the "deleter"</span></span><br><span class="line">    <span class="comment">// function that was passed to the constructor.</span></span><br><span class="line">    <span class="comment">// 析构函数需要调用deleter函数来销毁所有的entries</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Cache</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cache中的entry的句柄。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Handle</span></span><br><span class="line">    {</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert a mapping from key-&gt;value into the cache and assign it</span></span><br><span class="line">    <span class="comment">// the specified charge against the total cache capacity.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Returns a handle that corresponds to the mapping.  The caller</span></span><br><span class="line">    <span class="comment">// must call this-&gt;Release(handle) when the returned mapping is no</span></span><br><span class="line">    <span class="comment">// longer needed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// When the inserted entry is no longer needed, the key and</span></span><br><span class="line">    <span class="comment">// value will be passed to "deleter".</span></span><br><span class="line">    <span class="comment">// Insert将一个键值对映射插入到cache中，并赋予相应的“费用”charge.</span></span><br><span class="line">    <span class="comment">// Insert返回该映射对应的handle.调用者不再使用时必须调用Release(handle)方法。</span></span><br><span class="line">    <span class="comment">// 当不再需要此entry时，键值对会被传到deleter.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Handle *<span class="title">Insert</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">void</span> *value, <span class="type">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">void</span> (*deleter)(<span class="type">const</span> Slice &amp;key, <span class="type">void</span> *value))</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the cache has no mapping for "key", returns nullptr.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Else return a handle that corresponds to the mapping.  The caller</span></span><br><span class="line">    <span class="comment">// must call this-&gt;Release(handle) when the returned mapping is no</span></span><br><span class="line">    <span class="comment">// longer needed.</span></span><br><span class="line">    <span class="comment">// Lookup返回对应key的handle，如果没有则返回nullptr.</span></span><br><span class="line">    <span class="comment">// 调用者不再使用时必须调用Release(handle)方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Handle *<span class="title">Lookup</span><span class="params">(<span class="type">const</span> Slice &amp;key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release a mapping returned by a previous Lookup().</span></span><br><span class="line">    <span class="comment">// REQUIRES: handle must not have been released yet.</span></span><br><span class="line">    <span class="comment">// REQUIRES: handle must have been returned by a method on *this.</span></span><br><span class="line">    <span class="comment">// Release释放一个mapping.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Release</span><span class="params">(Handle *handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value封装Lookup()返回的handle中的值并返回之。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> *<span class="title">Value</span><span class="params">(Handle *handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Erase将一个entry删去。只有在所有与之关联的handle释放后才会被真正删去。</span></span><br><span class="line">    <span class="comment">// 即引用计数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> Slice &amp;key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return a new numeric id.  May be used by multiple clients who are</span></span><br><span class="line">    <span class="comment">// sharing the same cache to partition the key space.  Typically the</span></span><br><span class="line">    <span class="comment">// client will allocate a new id at startup and prepend the id to</span></span><br><span class="line">    <span class="comment">// its cache keys.</span></span><br><span class="line">    <span class="comment">// 返回一个ID，可能被多个共用相同缓存的客户端同时使用</span></span><br><span class="line">    <span class="comment">// 他们共享同一个cache来划分key space.</span></span><br><span class="line">    <span class="comment">// 通常client会在启动时分配一个新的id，并将其id放到缓存的键里。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除掉所有没有被使用的缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Prune</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前缓存的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这也是一个纯虚基类，定义了接口，下面来具体阐述其接口的含义。</p>
<p>首先，Cache本身作为一个缓存容器，可以被多个客户端调用(或者说多个线程)，考虑到有些线程会把相同的数据放入缓存中，这些相同的数据本身也不需要缓存多分，所以采用引用计数的方式就能对其进行很好的引用和销毁。</p>
<p>其次，作为一个容器，插入(Insert)，查找(Lookup)，销毁(Erase)这些对缓存进行操作的接口是必不可少的。</p>
<p>其中，由于销毁一个缓存涉及到多线程中共享引用的问题，所以只有一个缓存中的引用计数为1(即只被缓存本身引用时)，才会真正销毁。</p>
<p>另外，一般而言，多线程访问同一个数据空间时需要加锁，但是这样会降低效率，所以需要一种更巧妙的方法来实现不加锁的实现。为了区别多个线程所以需要为这些线程分配ID来进行标识(NewId)，至于具体怎么做后面在ShardedLRUCache中会具体阐述。</p>
<p>但是，考虑到一些操作必须进行加锁处理，所以有了加锁后释放的方法(Release)。</p>
<p>以及，缓存大小是有限的，不能无限充，所以扩需要及时检测缓存大小(TotalCharge)，并适时清理不必要的缓存项(Prune)。</p>
<h3 id="默认的lrucache">默认的LRUCache</h3>
<p>levelDB中默认提供的Cache就是LRUCache。不过由于其实现比较多，我们先不看其实现，而是大致描述一下其组成。</p>
<p>LRUCache的实现有以下特点：</p>
<ul>
<li>每一个缓存项都保存在一个LRUHandler里</li>
<li>每一个LRUHandler首先被保存在一个哈希表table_里面，支持根据键快速的查找</li>
<li>LRUCache里面有两个双向循环链表lru_和in_use_，每一个LRUHandler可以在两个链表中的一个里，但是不会同时在两个里，也有可能有些LRUHandler被淘汰出缓存了，不在任何链表上</li>
<li>in_use_保存当前正在被引用的LRUHandler，这个链表主要是为了检查</li>
<li>lru_保存没有被使用的LRUHandler，按照访问顺序来保存，lru_.next保存最旧的，lru_.prev保存最新的，需要淘汰缓存时，会从lru_里的next开始淘汰</li>
<li>当一个LRUHandler被使用时，会从lru_移动到in_use_，使用完成后，会从in_use_重新移动到lru_里</li>
<li>每个LRUCache都有一个容量capacity_，表示这个缓存的大小，每次插入一个项时都会指定这个缓存项的大小，更新usage_字段，当usage_超过capacity_时，就淘汰最旧的缓存项，直到低于capacity_</li>
</ul>
<img src="/2022/10/21/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-13/pic1.jpg" class="">
<p>另外，其使用引用计数来进行管理，具体流程如下：</p>
<ul>
<li>当一个LRUHandler被加入到缓存里面，并且没有被使用时，计数为1</li>
<li>如果客户端需要访问一个缓存，就会找到这个LRUHandler，调用Ref，将计数加1，并且当此时缓存在lru_里，就移动到in_use里</li>
<li>当客户端使用完一个缓存时，调用Unref里，将计数减1，当计数为0时，调用回调函数销毁缓存，当计数为1时，移动到in_use里面</li>
<li>这样可以自动控制缓存的销毁，当一个LRUHandler被移出缓存时，如果还有其他的引用，也不会被销毁</li>
</ul>
<p>查找一个缓存的流程如下：</p>
<ul>
<li>通过哈希表查找对应的LRUHandler</li>
<li>如果找到了，调用Ref，返回缓存项</li>
<li>使用完缓存项后，调用Release释放缓存</li>
</ul>
<p>插入缓存需要将缓存项插入到哈希表以及链表中，并且更新容量，如果缓存容量过多，需要淘汰旧缓存。插入一个缓存项的步骤如下：</p>
<ul>
<li>生成一个LRUHandler保存缓存的内容，计数为1</li>
<li>再将计数加1，表示当前缓存项被当前客户端引用，插入到in_use_链表中</li>
<li>插入时会指定插入项的大小更新usage_字段</li>
<li>插入到哈希表中</li>
<li>如果有相同值旧的缓存项，释放旧项</li>
<li>判断容量是否超标，如果超标，释放最旧的缓存项，直到容量不超标为止</li>
</ul>
<h4 id="lruhandle">LRUHandle</h4>
<p>我们先来看一下LRUHandle，前面也说了，每一个缓存项都保存在LRUHandler中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// 位于一个匿名名称空间中</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// LRU cache implementation</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Cache entries have an "in_cache" boolean indicating whether the cache has a</span></span><br><span class="line">    <span class="comment">// reference on the entry.  The only ways that this can become false without the</span></span><br><span class="line">    <span class="comment">// entry being passed to its "deleter" are via Erase(), via Insert() when</span></span><br><span class="line">    <span class="comment">// an element with a duplicate key is inserted, or on destruction of the cache.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The cache keeps two linked lists of items in the cache.  All items in the</span></span><br><span class="line">    <span class="comment">// cache are in one list or the other, and never both.  Items still referenced</span></span><br><span class="line">    <span class="comment">// by clients but erased from the cache are in neither list.  The lists are:</span></span><br><span class="line">    <span class="comment">// - in-use:  contains the items currently referenced by clients, in no</span></span><br><span class="line">    <span class="comment">//   particular order.  (This list is used for invariant checking.  If we</span></span><br><span class="line">    <span class="comment">//   removed the check, elements that would otherwise be on this list could be</span></span><br><span class="line">    <span class="comment">//   left as disconnected singleton lists.)</span></span><br><span class="line">    <span class="comment">// - LRU:  contains the items not currently referenced by clients, in LRU order</span></span><br><span class="line">    <span class="comment">// Elements are moved between these lists by the Ref() and Unref() methods,</span></span><br><span class="line">    <span class="comment">// when they detect an element in the cache acquiring or losing its only</span></span><br><span class="line">    <span class="comment">// external reference.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// An entry is a variable length heap-allocated structure.  Entries</span></span><br><span class="line">    <span class="comment">// are kept in a circular doubly linked list ordered by access time.</span></span><br><span class="line">    <span class="comment">// 每一个缓存项都保存在一个LRUHandler里</span></span><br><span class="line">    <span class="comment">// 即每个资源都是一个handler</span></span><br><span class="line">    <span class="comment">// 每个handler是变长的堆分配内存</span></span><br><span class="line">    <span class="comment">// handlers会被放置在两个双向循环链表中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LRUHandle</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">void</span> *value;</span><br><span class="line">        <span class="comment">// 数据项被移出缓存时的回调函数，这是一个函数指针</span></span><br><span class="line">        <span class="built_in">void</span> (*deleter)(<span class="type">const</span> Slice &amp;, <span class="type">void</span> *value);</span><br><span class="line">        LRUHandle *next_hash; <span class="comment">// hashtable中下一个handler</span></span><br><span class="line">        LRUHandle *next;      <span class="comment">// 双向链表中下一个</span></span><br><span class="line">        LRUHandle *prev;      <span class="comment">// 双向链表中前一个</span></span><br><span class="line">        <span class="type">size_t</span> charge;        <span class="comment">// 缓存项的大小</span></span><br><span class="line">        <span class="type">size_t</span> key_length;</span><br><span class="line">        <span class="type">bool</span> in_cache;    <span class="comment">// 是否位于缓存中</span></span><br><span class="line">        <span class="type">uint32_t</span> refs;    <span class="comment">// 引用计数</span></span><br><span class="line">        <span class="type">uint32_t</span> hash;    <span class="comment">// key()的哈希值，用于快速查找</span></span><br><span class="line">        <span class="type">char</span> key_data[<span class="number">1</span>]; <span class="comment">// key的开始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="comment">// 只有当链表为空时头指针的next才会指向本身，这是毫无意义的</span></span><br><span class="line">            <span class="built_in">assert</span>(next != <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Slice</span>(key_data, key_length);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其位于一个匿名名称空间中，而且这个结构体长得比较奇怪。还记得前面提到过，每个handler同时存在于一个循环双向链表中和一个哈希表中，所以在一个结构体内存在这么多指针就是为了标识当前handler在两个表中的位置。话说这个结构体是不是没有内存对齐...</p>
<h4 id="handletable">HandleTable</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// 同样是匿名名称空间</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 这里定义HandleTable，其实就是hashtable，因为这会比自带的hashtable快</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">HandleTable</span></span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">HandleTable</span>() : <span class="built_in">length_</span>(<span class="number">0</span>), <span class="built_in">elems_</span>(<span class="number">0</span>), <span class="built_in">list_</span>(<span class="literal">nullptr</span>) { <span class="built_in">Resize</span>(); }</span><br><span class="line">        ~<span class="built_in">HandleTable</span>() { <span class="keyword">delete</span>[] list_; }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找一个key并返回其handler</span></span><br><span class="line">        <span class="function">LRUHandle *<span class="title">Lookup</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">uint32_t</span> hash)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入一个handler到hashtable中，这部分如果看不懂建议去看看hashtable原理</span></span><br><span class="line">        <span class="comment">// insert和remove不涉及内存管理！</span></span><br><span class="line">        <span class="function">LRUHandle *<span class="title">Insert</span><span class="params">(LRUHandle *h)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            LRUHandle **ptr = <span class="built_in">FindPointer</span>(h-&gt;<span class="built_in">key</span>(), h-&gt;hash);</span><br><span class="line">            <span class="comment">// 头插法，快</span></span><br><span class="line">            LRUHandle *old = *ptr;</span><br><span class="line">            h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">            *ptr = h;</span><br><span class="line">            <span class="keyword">if</span> (old == <span class="literal">nullptr</span>)</span><br><span class="line">            {</span><br><span class="line">                ++elems_;</span><br><span class="line">                <span class="keyword">if</span> (elems_ &gt; length_)</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">                    <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">                    <span class="comment">// 如果元素数目比hash长度还要大，就扩容，因为这样hash冲突比较显著</span></span><br><span class="line">                    <span class="built_in">Resize</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除一个handler</span></span><br><span class="line">        <span class="function">LRUHandle *<span class="title">Remove</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">uint32_t</span> hash)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            LRUHandle **ptr = <span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">            LRUHandle *result = *ptr;</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">nullptr</span>)</span><br><span class="line">            {</span><br><span class="line">                *ptr = result-&gt;next_hash;</span><br><span class="line">                --elems_;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">uint32_t</span> length_;  <span class="comment">// hash长度</span></span><br><span class="line">        <span class="type">uint32_t</span> elems_;   <span class="comment">// 数目</span></span><br><span class="line">        LRUHandle **list_; <span class="comment">//指向存放handler*的数组 用于hash冲突</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return a pointer to slot that points to a cache entry that</span></span><br><span class="line">        <span class="comment">// matches key/hash.  If there is no such cache entry, return a</span></span><br><span class="line">        <span class="comment">// pointer to the trailing slot in the corresponding linked list.</span></span><br><span class="line">        <span class="comment">// 通过hash和key来查找handler，因为hash冲突存在，必须要保留key用于验证</span></span><br><span class="line">        <span class="comment">// 如果key不存在，则返回对应的hashtable表项中的最后一个</span></span><br><span class="line">        <span class="comment">// 但是我感觉返回的是null，即超尾元素</span></span><br><span class="line">        <span class="function">LRUHandle **<span class="title">FindPointer</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">uint32_t</span> hash)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            LRUHandle **ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];</span><br><span class="line">            <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;<span class="built_in">key</span>()))</span><br><span class="line">            {</span><br><span class="line">                ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新调整长度，为了减弱hash冲突</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="type">uint32_t</span> new_length = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span> (new_length &lt; elems_)</span><br><span class="line">            {</span><br><span class="line">                new_length *= <span class="number">2</span>; <span class="comment">// 每次扩大2倍的方式移动</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 然后新建一个list并把原来的各个表项进行重映射</span></span><br><span class="line">            LRUHandle **new_list = <span class="keyword">new</span> LRUHandle *[new_length];</span><br><span class="line">            <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="built_in">sizeof</span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">            <span class="type">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++)</span><br><span class="line">            {</span><br><span class="line">                LRUHandle *h = list_[i];</span><br><span class="line">                <span class="keyword">while</span> (h != <span class="literal">nullptr</span>)</span><br><span class="line">                {</span><br><span class="line">                    LRUHandle *next = h-&gt;next_hash;</span><br><span class="line">                    <span class="type">uint32_t</span> hash = h-&gt;hash;</span><br><span class="line">                    LRUHandle **ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">                    h-&gt;next_hash = *ptr;</span><br><span class="line">                    *ptr = h;</span><br><span class="line">                    h = next;</span><br><span class="line">                    count++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">assert</span>(elems_ == count);</span><br><span class="line">            <span class="comment">// 然后删除掉原来的list</span></span><br><span class="line">            <span class="keyword">delete</span>[] list_;</span><br><span class="line">            list_ = new_list;</span><br><span class="line">            length_ = new_length;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个HandleTable也是位于一个匿名的名称空间中。它其实就是一个HashTable，至于为什么要再实现一个HashTable，它也在注释中说了，因为新实现的这个会更快(gcc
-O3相比提升5%左右)。</p>
<p>由于其本身就是一个HashTable了，所以没有什么好说的，本质上还是很简单的。可能唯一要注意的就是元素数目和hash的桶数组长度相同时的扩容操作吧，总感觉这个扩容的函数有点暴力美学了，感觉应该还可以继续优化？</p>
<p>另外，HandleTable不涉及内存管理的操作。</p>
<h4 id="lrucache">LRUCache</h4>
<p>这个LRUCache呢，就可以说是一个实现的比较完整的Cache了。它内部使用了HandleTable、LRUHandle，提供了完整的增删查缓存的能力。但是需要注意的是，这个类没有继承自Cache类，所以它不能使用Cache指针来实现多态。</p>
<p>但实际上，我们没有办法创建一个LRUCache类，因为其位于一个匿名名称空间，且没有提供外部接口来访问它，所以它本质上仍然是不完全体的Cache。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// 位于匿名名称空间</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LRUCache</span></span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造析构函数</span></span><br><span class="line">        <span class="built_in">LRUCache</span>();</span><br><span class="line">        ~<span class="built_in">LRUCache</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置容量大小</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetCapacity</span><span class="params">(<span class="type">size_t</span> capacity)</span> </span>{ capacity_ = capacity; }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入key/hash/value，并返回其handler指针，同时为其增加deleter回调函数</span></span><br><span class="line">        <span class="comment">// 与Cache::Insert类似，只是多了一个hash</span></span><br><span class="line">        <span class="function">Cache::Handle *<span class="title">Insert</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">uint32_t</span> hash, <span class="type">void</span> *value,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> (*deleter)(<span class="type">const</span> Slice &amp;key, <span class="type">void</span> *value))</span></span>;</span><br><span class="line">        <span class="comment">// 查找一个key/hash是否在缓存中，如果在就返回其handler指针</span></span><br><span class="line">        <span class="function">Cache::Handle *<span class="title">Lookup</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">uint32_t</span> hash)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(Cache::Handle *handle)</span></span>;         <span class="comment">// 调用完成后释放</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">uint32_t</span> hash)</span></span>; <span class="comment">// 当引用归零后移除</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Prune</span><span class="params">()</span></span>;                                <span class="comment">// 移除不使用的缓存以释放空间</span></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="type">const</span>                   <span class="comment">// 总的使用空间</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> usage_;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">LRU_Remove</span><span class="params">(LRUHandle *e)</span></span>;                  <span class="comment">// 移除handler</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">LRU_Append</span><span class="params">(LRUHandle *list, LRUHandle *e)</span></span>; <span class="comment">// 添加handler</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Ref</span><span class="params">(LRUHandle *e)</span></span>;                         <span class="comment">// 对handler进行引用计数的俩函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Unref</span><span class="params">(LRUHandle *e)</span></span>;</span><br><span class="line">        <span class="comment">// 完成了移除的收尾工作的函数</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">FinishErase</span><span class="params">(LRUHandle *e)</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> capacity_; <span class="comment">// 容量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// mutex_ protects the following state.</span></span><br><span class="line">        <span class="keyword">mutable</span> port::Mutex mutex_;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> usage_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>; <span class="comment">// 缓存项已占用的容量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dummy head of LRU list.</span></span><br><span class="line">        <span class="comment">// lru.prev is newest entry, lru.next is oldest entry.</span></span><br><span class="line">        <span class="comment">// Entries have refs==1 and in_cache==true.</span></span><br><span class="line">        <span class="function">LRUHandle lru_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>; <span class="comment">// 在LRUCache中但未被引用的缓存项链表头哑结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dummy head of in-use list.</span></span><br><span class="line">        <span class="comment">// Entries are in use by clients, and have refs &gt;= 2 and in_cache==true.</span></span><br><span class="line">        <span class="function">LRUHandle in_use_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>; <span class="comment">// 正在被使用的缓存项链表链表头哑结点</span></span><br><span class="line"></span><br><span class="line">        <span class="function">HandleTable table_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>; <span class="comment">// 用于查找缓存项的哈希表</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    LRUCache::<span class="built_in">LRUCache</span>() : <span class="built_in">capacity_</span>(<span class="number">0</span>), <span class="built_in">usage_</span>(<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 构造一个空的循环双向链表</span></span><br><span class="line">        lru_.next = &amp;lru_;</span><br><span class="line">        lru_.prev = &amp;lru_;</span><br><span class="line">        in_use_.next = &amp;in_use_;</span><br><span class="line">        in_use_.prev = &amp;in_use_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    LRUCache::~<span class="built_in">LRUCache</span>()</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 先判断一下本Cache中in_use中是否没有数据了，即保证所有的项都没有被使用中</span></span><br><span class="line">        <span class="built_in">assert</span>(in_use_.next == &amp;in_use_);</span><br><span class="line">        <span class="keyword">for</span> (LRUHandle *e = lru_.next; e != &amp;lru_;)</span><br><span class="line">        {</span><br><span class="line">            LRUHandle *next = e-&gt;next;</span><br><span class="line">            <span class="built_in">assert</span>(e-&gt;in_cache);</span><br><span class="line">            e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">assert</span>(e-&gt;refs == <span class="number">1</span>); <span class="comment">// 只有LURCache引用了它</span></span><br><span class="line">            <span class="built_in">Unref</span>(e);             <span class="comment">// 释放掉</span></span><br><span class="line">            e = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LRUCache::Ref</span><span class="params">(LRUHandle *e)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;refs == <span class="number">1</span> &amp;&amp; e-&gt;in_cache)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 如果在lru_list中，就移动到in_use中</span></span><br><span class="line">            <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">            <span class="built_in">LRU_Append</span>(&amp;in_use_, e);</span><br><span class="line">        }</span><br><span class="line">        e-&gt;refs++; <span class="comment">// 增加引用计数</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少引用计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LRUCache::Unref</span><span class="params">(LRUHandle *e)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">assert</span>(e-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">        e-&gt;refs--;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;refs == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 没有东西在引用他，就直接销毁，调用其deleter</span></span><br><span class="line">            <span class="built_in">assert</span>(!e-&gt;in_cache);</span><br><span class="line">            (*e-&gt;deleter)(e-&gt;<span class="built_in">key</span>(), e-&gt;value);</span><br><span class="line">            <span class="built_in">free</span>(e);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;in_cache &amp;&amp; e-&gt;refs == <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 不在使用就移动至lru_list中</span></span><br><span class="line">            <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">            <span class="built_in">LRU_Append</span>(&amp;lru_, e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除一个handler</span></span><br><span class="line">    <span class="comment">// 并不是销毁，主要用于在两个链表之间移动handler</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LRUCache::LRU_Remove</span><span class="params">(LRUHandle *e)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        e-&gt;next-&gt;prev = e-&gt;prev;</span><br><span class="line">        e-&gt;prev-&gt;next = e-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到指定的链表中，同样是移动操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LRUCache::LRU_Append</span><span class="params">(LRUHandle *list, LRUHandle *e)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 按照头插入法进行插入</span></span><br><span class="line">        <span class="comment">// 保证prev是最新的，next是最旧的</span></span><br><span class="line">        e-&gt;next = list;</span><br><span class="line">        e-&gt;prev = list-&gt;prev;</span><br><span class="line">        e-&gt;prev-&gt;next = e;</span><br><span class="line">        e-&gt;next-&gt;prev = e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作</span></span><br><span class="line">    <span class="function">Cache::Handle *<span class="title">LRUCache::Lookup</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">uint32_t</span> hash)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>; <span class="comment">// 锁</span></span><br><span class="line">        LRUHandle *e = table_.<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">Ref</span>(e); <span class="comment">// 查找到就移动至in_usr并增加引用计数</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;Cache::Handle *&gt;(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LRUCache::Release</span><span class="params">(Cache::Handle *handle)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>; <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="built_in">Unref</span>(<span class="built_in">reinterpret_cast</span>&lt;LRUHandle *&gt;(handle));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="function">Cache::Handle *<span class="title">LRUCache::Insert</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">uint32_t</span> hash, <span class="type">void</span> *value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">void</span> (*deleter)(<span class="type">const</span> Slice &amp;key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">void</span> *value))</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 同样需要加锁</span></span><br><span class="line">        <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">        LRUHandle *e =</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;LRUHandle *&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">        e-&gt;value = value;</span><br><span class="line">        e-&gt;deleter = deleter;</span><br><span class="line">        e-&gt;charge = charge;</span><br><span class="line">        e-&gt;key_length = key.<span class="built_in">size</span>();</span><br><span class="line">        e-&gt;hash = hash;</span><br><span class="line">        e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">        e-&gt;refs = <span class="number">1</span>; <span class="comment">// for the returned handle.</span></span><br><span class="line">        std::<span class="built_in">memcpy</span>(e-&gt;key_data, key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (capacity_ &gt; <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            e-&gt;refs++; <span class="comment">// for the cache's reference.</span></span><br><span class="line">            e-&gt;in_cache = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">LRU_Append</span>(&amp;in_use_, e);</span><br><span class="line">            usage_ += charge;</span><br><span class="line">            <span class="built_in">FinishErase</span>(table_.<span class="built_in">Insert</span>(e));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 没有容量就表示不缓存，所以自然也不会位于缓存表中</span></span><br><span class="line">            e-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果超过使用空间就进行释放</span></span><br><span class="line">        <span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_)</span><br><span class="line">        {</span><br><span class="line">            LRUHandle *old = lru_.next;</span><br><span class="line">            <span class="built_in">assert</span>(old-&gt;refs == <span class="number">1</span>);</span><br><span class="line">            <span class="type">bool</span> erased = <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(old-&gt;<span class="built_in">key</span>(), old-&gt;hash));</span><br><span class="line">            <span class="keyword">if</span> (!erased)</span><br><span class="line">            { <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">                <span class="built_in">assert</span>(erased);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;Cache::Handle *&gt;(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成了移除的收尾工作的函数</span></span><br><span class="line">    <span class="comment">// 从lru中移除，并保证其引用计数归零</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">LRUCache::FinishErase</span><span class="params">(LRUHandle *e)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">assert</span>(e-&gt;in_cache);</span><br><span class="line">            <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">            e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">            usage_ -= e-&gt;charge;</span><br><span class="line">            <span class="built_in">Unref</span>(e);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> e != <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其实就是加锁然后从hashtable中移除，并调用FinishErase彻底移除</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LRUCache::Erase</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">uint32_t</span> hash)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">        <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(key, hash));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放空间，跟Insert里面那个差不多</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LRUCache::Prune</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (lru_.next != &amp;lru_)</span><br><span class="line">        {</span><br><span class="line">            LRUHandle *e = lru_.next;</span><br><span class="line">            <span class="built_in">assert</span>(e-&gt;refs == <span class="number">1</span>);</span><br><span class="line">            <span class="type">bool</span> erased = <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(e-&gt;<span class="built_in">key</span>(), e-&gt;hash));</span><br><span class="line">            <span class="keyword">if</span> (!erased)</span><br><span class="line">            { <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">                <span class="built_in">assert</span>(erased);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LRUCache类实现的已经比较完整了。需要注意的是，其使用两个双向链表存储handler，每个handler只会位于一个双向链表中。且由于双向链表始终是头插入，所以head-&gt;prev就是最新进入链表的，head-&gt;next就是最老进入链表的。当缓存空间占用超过限制时，可以从head-&gt;next开始清理空间。</p>
<p>另外，这个类中还涉及到了很多锁的概念，因为我不是特别清楚，只是大致了解锁的作用，所以就浅浅掠过吧。</p>
<h4 id="shardedlrucache">ShardedLRUCache</h4>
<p>如果说LRUCache是一个相对完整的半成品Cache，那么ShardedLRUCache就是完成品了。虽然它也位于一个匿名名称空间中，但是其对外提供了创建接口。</p>
<p>它相对于LRUCache的主要改进是：由于LRUCache使用锁导致多线程时性能下降，所以ShardedLRUCache采用一些方案来弥补锁带来的阻塞。方法是将一个大的Cache分成若干个小的Cache，然后每个线程固定访问一个Cache，这样就算有锁，也只会在每个小Cache上阻塞，大大提升了并发能力。</p>
<img src="/2022/10/21/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-13/pic2.jpg" class="">
<p>这个ShardedLRUCache继承自Cache，所以有Cache的全部接口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// 匿名空间</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ShardedLRUCache</span> : <span class="keyword">public</span> Cache</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        LRUCache shard_[kNumShards];</span><br><span class="line">        port::Mutex id_mutex_;</span><br><span class="line">        <span class="type">uint64_t</span> last_id_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算hash值的函数</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">HashSlice</span><span class="params">(<span class="type">const</span> Slice &amp;s)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Hash</span>(s.<span class="built_in">data</span>(), s.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截取分片</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title">Shard</span><span class="params">(<span class="type">uint32_t</span> hash)</span> </span>{ <span class="keyword">return</span> hash &gt;&gt; (<span class="number">32</span> - kNumShardBits); }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数，为每个Cache设置大小</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ShardedLRUCache</span><span class="params">(<span class="type">size_t</span> capacity)</span> : last_id_(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">        {</span></span><br><span class="line">            <span class="type">const</span> <span class="type">size_t</span> per_shard = (capacity + (kNumShards - <span class="number">1</span>)) / kNumShards;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++)</span><br><span class="line">            {</span><br><span class="line">                shard_[s].<span class="built_in">SetCapacity</span>(per_shard);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 析构函数，为空</span></span><br><span class="line">        ~<span class="built_in">ShardedLRUCache</span>() <span class="keyword">override</span> {}</span><br><span class="line">        <span class="comment">// 插入一个key到缓存中</span></span><br><span class="line">        <span class="function">Handle *<span class="title">Insert</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">void</span> *value, <span class="type">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">void</span> (*deleter)(<span class="type">const</span> Slice &amp;key, <span class="type">void</span> *value))</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="type">const</span> <span class="type">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">            <span class="keyword">return</span> shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Insert</span>(key, hash, value, charge, deleter);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 查找一个缓存</span></span><br><span class="line">        <span class="function">Handle *<span class="title">Lookup</span><span class="params">(<span class="type">const</span> Slice &amp;key)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="type">const</span> <span class="type">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">            <span class="keyword">return</span> shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 释放handler</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(Handle *handle)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            LRUHandle *h = <span class="built_in">reinterpret_cast</span>&lt;LRUHandle *&gt;(handle);</span><br><span class="line">            shard_[<span class="built_in">Shard</span>(h-&gt;hash)].<span class="built_in">Release</span>(handle);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 移除</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> Slice &amp;key)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="type">const</span> <span class="type">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">            shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Erase</span>(key, hash);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        <span class="function"><span class="type">void</span> *<span class="title">Value</span><span class="params">(Handle *handle)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;LRUHandle *&gt;(handle)-&gt;value;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 创建一个id</span></span><br><span class="line">        <span class="function"><span class="type">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;id_mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> ++(last_id_);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 清理空间</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Prune</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++)</span><br><span class="line">            {</span><br><span class="line">                shard_[s].<span class="built_in">Prune</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 总占用</span></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++)</span><br><span class="line">            {</span><br><span class="line">                total += shard_[s].<span class="built_in">TotalCharge</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">} <span class="comment">// end anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部接口</span></span><br><span class="line"><span class="function">Cache *<span class="title">NewLRUCache</span><span class="params">(<span class="type">size_t</span> capacity)</span> </span>{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ShardedLRUCache</span>(capacity); }</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个类主要就是使用LRUCache，由于LRUCache中实现已经很完善了，所以这个类就相对简单一些，主要特性就是上面描述的那些。</p>
<h2 id="缓存的使用">缓存的使用</h2>
<h3 id="tablecache">TableCache</h3>
<p>LevelDB里SSTable在内存中是以Table结构存在的，要使用一个SSTable，必须先进行Open操作，会将Index
Block和Filter Data都读取到内存里，保存在Table里，但是Data
Block依然保存在磁盘上。在缓存的时候也只会缓存索引，和指向数据的迭代器，在TableCache中不会缓存数据本身。</p>
<ul>
<li>每个Table结构都要占据一定的内存，被打开的Table放在一个缓存中，缓存一定数量的Table，当数量太多时，有一些Table需要被驱逐出内存，这样当需要再次访问这些Table时需要再次被打开</li>
<li>每个Table的Data
Block可以被缓存，这样再次访问相同的数据时，不需要读磁盘</li>
</ul>
<p>我们只关注一下TableCache类的关键的几个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TableAndFile</span></span><br><span class="line">{</span><br><span class="line">    RandomAccessFile *file;</span><br><span class="line">    Table *table;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个handler时的回调函数</span></span><br><span class="line"><span class="comment">// 用于管理内存的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DeleteEntry</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    TableAndFile *tf = <span class="built_in">reinterpret_cast</span>&lt;TableAndFile *&gt;(value);</span><br><span class="line">    <span class="keyword">delete</span> tf-&gt;table;</span><br><span class="line">    <span class="keyword">delete</span> tf-&gt;file;</span><br><span class="line">    <span class="keyword">delete</span> tf;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从TableCache中查找Table缓存的函数</span></span><br><span class="line"><span class="function">Status <span class="title">TableCache::FindTable</span><span class="params">(<span class="type">uint64_t</span> file_number, <span class="type">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Cache::Handle **handle)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Status s;</span><br><span class="line">    <span class="type">char</span> buf[<span class="built_in">sizeof</span>(file_number)];</span><br><span class="line">    <span class="built_in">EncodeFixed64</span>(buf, file_number);</span><br><span class="line">    <span class="function">Slice <span class="title">key</span><span class="params">(buf, <span class="keyword">sizeof</span>(buf))</span></span>; <span class="comment">// 查找时的key为filenumber的编码</span></span><br><span class="line">    *handle = cache_-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (*handle == <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        std::string fname = <span class="built_in">TableFileName</span>(dbname_, file_number);</span><br><span class="line">        RandomAccessFile *file = <span class="literal">nullptr</span>;</span><br><span class="line">        Table *table = <span class="literal">nullptr</span>;</span><br><span class="line">        s = env_-&gt;<span class="built_in">NewRandomAccessFile</span>(fname, &amp;file);</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            std::string old_fname = <span class="built_in">SSTTableFileName</span>(dbname_, file_number);</span><br><span class="line">            <span class="keyword">if</span> (env_-&gt;<span class="built_in">NewRandomAccessFile</span>(old_fname, &amp;file).<span class="built_in">ok</span>())</span><br><span class="line">            {</span><br><span class="line">                s = Status::<span class="built_in">OK</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            s = Table::<span class="built_in">Open</span>(options_, file, file_size, &amp;table);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">assert</span>(table == <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">delete</span> file;</span><br><span class="line">            <span class="comment">// We do not cache error results so that if the error is transient,</span></span><br><span class="line">            <span class="comment">// or somebody repairs the file, we recover automatically.</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            TableAndFile *tf = <span class="keyword">new</span> TableAndFile;</span><br><span class="line">            tf-&gt;file = file;</span><br><span class="line">            tf-&gt;table = table;</span><br><span class="line">            *handle = cache_-&gt;<span class="built_in">Insert</span>(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个函数的作用是查找一个Table，我们注意到，查找的时候使用的是Table的file_number。即Table就是用这个file_number作为键来缓存的。用一个结构体缓存了Table类和一个文件读取迭代器，并把这个结构体插入到TableCache类中的hardedLRUCache对象中。</p>
<h3 id="blockcache">BlockCache</h3>
<p>之前也提到过，TableCache是不会缓存具体的数据而是缓存索引，而BlcokCache的存在就是为了缓存数据，即缓存DataBlock。</p>
<p>每个Table打开的时候，都会指定一个cache_id，这是一个单调递增的整数，每个Table都有一个唯一的cache_id。在每一个SSTable里面，每一个Data
Block都有一个固定的文件偏移offset。所以每一个Data
Block都可以由cache_id和offset来唯一标识，也就是根据这两个值生成一个键，来插入和查找缓存。</p>
<p>BlockCache被Table调用，当读取block时会优先从缓存中读取，如果缓存中没有就需要从文件中读取，然后将其放到缓存上。其中BlockCache的缓存的key是由cache_id和block的offset共同组成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 删除BlcokCache的回调函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DeleteCachedBlock</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Block *block = <span class="built_in">reinterpret_cast</span>&lt;Block *&gt;(value);</span><br><span class="line">    <span class="keyword">delete</span> block;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert an index iterator value (i.e., an encoded BlockHandle)</span></span><br><span class="line"><span class="comment">// into an iterator over the contents of the corresponding block.</span></span><br><span class="line"><span class="function">Iterator *<span class="title">Table::BlockReader</span><span class="params">(<span class="type">void</span> *arg, <span class="type">const</span> ReadOptions &amp;options,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> Slice &amp;index_value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Table *table = <span class="built_in">reinterpret_cast</span>&lt;Table *&gt;(arg);</span><br><span class="line">    Cache *block_cache = table-&gt;rep_-&gt;options.block_cache;</span><br><span class="line">    Block *block = <span class="literal">nullptr</span>;</span><br><span class="line">    Cache::Handle *cache_handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    BlockHandle handle;</span><br><span class="line">    Slice input = index_value;</span><br><span class="line">    Status s = handle.<span class="built_in">DecodeFrom</span>(&amp;input);</span><br><span class="line">    <span class="comment">// We intentionally allow extra stuff in index_value so that we</span></span><br><span class="line">    <span class="comment">// can add more features in the future.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        BlockContents contents;</span><br><span class="line">        <span class="comment">// BlockCache在这里</span></span><br><span class="line">        <span class="comment">// 根据block handle，首先尝试从blockcache中直接取出block，不在blockcache中则</span></span><br><span class="line">        <span class="comment">// 调用ReadBlock从文件读取，读取成功后，根据option尝试将block加入到blockcache中。</span></span><br><span class="line">        <span class="comment">// 并在Insert的时候注册了释放函数DeleteCachedBlock。</span></span><br><span class="line">        <span class="keyword">if</span> (block_cache != <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">char</span> cache_key_buffer[<span class="number">16</span>];</span><br><span class="line">            <span class="built_in">EncodeFixed64</span>(cache_key_buffer, table-&gt;rep_-&gt;cache_id);</span><br><span class="line">            <span class="built_in">EncodeFixed64</span>(cache_key_buffer + <span class="number">8</span>, handle.<span class="built_in">offset</span>());</span><br><span class="line">            <span class="function">Slice <span class="title">key</span><span class="params">(cache_key_buffer, <span class="keyword">sizeof</span>(cache_key_buffer))</span></span>;</span><br><span class="line">            <span class="comment">// 先查一下缓存，key是由cache_id和handler的偏移值共同组成</span></span><br><span class="line">            cache_handle = block_cache-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (cache_handle != <span class="literal">nullptr</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 查找到就优先从缓存中返回</span></span><br><span class="line">                block = <span class="built_in">reinterpret_cast</span>&lt;Block *&gt;(block_cache-&gt;<span class="built_in">Value</span>(cache_handle));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 否则就添加到缓存</span></span><br><span class="line">                s = <span class="built_in">ReadBlock</span>(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">                {</span><br><span class="line">                    block = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line">                    <span class="keyword">if</span> (contents.cachable &amp;&amp; options.fill_cache)</span><br><span class="line">                    {</span><br><span class="line">                        cache_handle = block_cache-&gt;<span class="built_in">Insert</span>(key, block, block-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                                           &amp;DeleteCachedBlock);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            s = <span class="built_in">ReadBlock</span>(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">            {</span><br><span class="line">                block = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回block的迭代器</span></span><br><span class="line">    Iterator *iter;</span><br><span class="line">    <span class="keyword">if</span> (block != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        iter = block-&gt;<span class="built_in">NewIterator</span>(table-&gt;rep_-&gt;options.comparator);</span><br><span class="line">        <span class="keyword">if</span> (cache_handle == <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            iter-&gt;<span class="built_in">RegisterCleanup</span>(&amp;DeleteBlock, block, <span class="literal">nullptr</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            iter-&gt;<span class="built_in">RegisterCleanup</span>(&amp;ReleaseBlock, block_cache, cache_handle);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        iter = <span class="built_in">NewErrorIterator</span>(s);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="缓存使用上的总结">缓存使用上的总结</h3>
<p>levelDB默认提供了一个完整的可用缓存为ShardedLRUCache，后续所有的缓存使用都是基于此类来实现的。这个类继承自Cache类，拥有所有的接口。</p>
<p>TableCache类缓存索引项，是Table类的一个友元。而Table类用于读取一个被持久到文件的sstable，所以Table类存在xxxblock和footer等。Table在不缓存的条件下必须经过磁盘来读取DataBlock</p>
<p>BlockCache实际上是Table内部的组成，用于缓存DataBlock。</p>
<p>查找某个Table中的某一条数据的流程如下：</p>
<ul>
<li>将Table的file_number作为键，通过TableCache类来查找这个Table。如果存在就返回，否则就需要调用Table::Open()函数来从文件中读取它，并放入缓存。</li>
<li>拿到Table后，先通过其索引来确定这条数据位于哪个Block。使用cache_id和offset来构造键，通过全局的一个BlockCache(定义在options中)，来查找这个Block，如果找到就返回，否则就从文件打开并添加到缓存中。</li>
</ul>
<div class="note info">
            <p>TableCache被定义成了Table的友元类是因为索引项比较多，且索引都存储在Table中。</p><p>BlockCache甚至都不存在这样一个类，是因为Block比较简单，本质上就是一个数组，能够直接用于Cache。</p><p>另外一方面的原因就是，xxx类的缓存会包含很多个xxx类。Table与Block刚好构成这样一个关系。</p>
          </div>
<h2 id="总结">总结</h2>
<ul>
<li>使用匿名名称空间来隐藏类</li>
<li>使用override来显示指示出函数需要重写</li>
<li>使用回调函数来管理内存</li>
</ul>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(15)--数据库的版本管理</title>
    <url>/2022/12/19/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-15/</url>
    <content><![CDATA[<h2 id="数据库版本管理">数据库版本管理</h2>
<span id="more"></span>
<div class="note primary">
            <p>源码位置与说明</p><p>version_edit.h version_edit.cc: 实现VersionEdit<br>version_set.h version_set.cc：实现Version、VersionSet和Builder</p>
          </div>
<p>版本其实就是LevelDB数据库的元数据，之前提到过，在MemTable读取不到键时，需要去SSTable读取。SSTable的文件有哪些，每一个文件分别在哪一个Level上面，每个文件里面包含的键的最小值最大值是什么。需要知道这些信息，才可以快速的从SSTable里读取出相应的键的值。而版本就保存了这些信息，让我们通过版本读取SSTable。</p>
<p>那么为什么要版本管理呢？在数据不断写入后，MemTable写满了，这时候就会转换为Level
0的一个SSTable，或者Level n的一个文件和Level n +
1的多个文件进行Compaction，会转换成Level n +
1的多个文件。这会使SSTable文件数量改变，文件内容改变，也就是版本信息改变了，所以需要管理版本。</p>
<p>那么有一个版本就够了吗？在文件数量和内容改变时，修改当前的版本就行了。但是并不是，假设使用了整个数据库的迭代器，LevelDB在迭代数据库时，是提供了一个一致性的视图，也就是只能看到迭代前的写入，而迭代后的写入是看不到，在实现的时候，迭代器会引用这个版本，以及里面的SSTable，直到迭代结束。如果在迭代过程中，有文件删除了，那么就无法引用到这个文件了，就会出错。所以需要多个版本，有一个版本是当前版本，当新生成版本后，旧的版本如果有被其它线程引用，也需要保留，直到不被引用后，才会被删除，所以一个时刻可能有多个版本存在。</p>
<img src="/2022/12/19/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-15/1.jpg" class="">
<p>先看看LevelDB的版本管理架构图，可以看到主要用到了4个类:</p>
<ul>
<li>Version标识了一个版本，主要信息是这个版本包含的SSTable信息</li>
<li>VersionSet是一个版本集，里面保存了Version的一个双链表，其中有一个Version是当前版本，因为只有一个实例，还保存了其它的一些全局的元数据，Dummy
Version是链表头</li>
<li>VersionEdit保存了要对Version做的修改，在一个Version上应用一个VersionEdit，可以生成一个新的Version</li>
<li>Builder是一个帮助类，帮助Version上应用VersionEdit，生成新版本</li>
</ul>
<p>版本管理的基本工作流程如下：</p>
<ul>
<li>VersionSet里保存着当前版本，以及被引用的历史版本</li>
<li>当有Compaction发生时，会将更改的内容写入到一个VersionEdit中</li>
<li>利用Builder将VersionEdit应用到当前版本上面生成一个新的版本</li>
<li>将新版本链接到VersionSet的双链表上面</li>
<li>将新的版本设置为当前版本</li>
<li>将旧的当前版本Unref，就是引用计数减1</li>
</ul>
<p>版本控制中使用了引用计数来管理历史版本：</p>
<ul>
<li>假设一个没有被访问的数据库，这时候只有一个版本，也就是当前版本v1，它的引用计数是1</li>
<li>假设有一个迭代器开始访问数据库，这时候它会对当前版本v1
Ref，引用计数变成了2</li>
<li>其它线程不断写入，导致了Compaction的生成，这时候生成了一个新的版本v2成为了当前版本，引用计数为1，然后对v1
Unref，这时候v1的引用计数为1</li>
<li>因为v1的引用计数为1，所以不会被删除，迭代器线程还可以继续访问v1</li>
<li>迭代器结束后，对v1进行Unref，这时候v1的引用计数变为0，就会从链表上删除了，这时候又只剩下v2版本了</li>
<li>版本里面的SSTable也是采用引用计数来管理的，每个版本引用一个SSTable会Ref，删除版本时会Unref，如果一个SSTable的计数为0，那么这个SSTable就可以被删除了</li>
</ul>
<img src="/2022/12/19/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-15/pic2.jpg" class="">
<h3 id="version">Version</h3>
<p>我们首先来看一下Version这个类。Version这个类标识了一个版本，读取数据库时都需要使用Version里面的版本信息，主要保存的是SSTable的文件信息。</p>
<p>先来看一下头文件部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Version</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Compaction</span>; <span class="comment">// 压缩线程友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">VersionSet</span>; <span class="comment">// 版本集合友元类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LevelFileNumIterator</span>; <span class="comment">// 用于迭代某一层的迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，不允许直接创建此类，只能被友元创建</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Version</span><span class="params">(VersionSet *vset)</span></span></span><br><span class="line"><span class="function">        : vset_(vset),</span></span><br><span class="line"><span class="function">          next_(this),</span></span><br><span class="line"><span class="function">          prev_(this),</span></span><br><span class="line"><span class="function">          refs_(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">          file_to_compact_(nullptr),</span></span><br><span class="line"><span class="function">          file_to_compact_level_(<span class="number">-1</span>),</span></span><br><span class="line"><span class="function">          compaction_score_(<span class="number">-1</span>),</span></span><br><span class="line"><span class="function">          compaction_level_(<span class="number">-1</span>)</span></span><br><span class="line"><span class="function">    {</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Version</span>(<span class="type">const</span> Version &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Version &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Version &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Version</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个双层迭代器，第一层用来遍历对应level的所有文件</span></span><br><span class="line">    <span class="comment">// 第二层用来遍历某个文件的cache中的k-v，使用此双层迭代器</span></span><br><span class="line">    <span class="comment">// 可以方便的遍历一个level中所有的k-v</span></span><br><span class="line">    <span class="function">Iterator *<span class="title">NewConcatenatingIterator</span><span class="params">(<span class="type">const</span> ReadOptions &amp;, <span class="type">int</span> level)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call func(arg, level, f) for every file that overlaps user_key in</span></span><br><span class="line">    <span class="comment">// order from newest to oldest.  If an invocation of func returns</span></span><br><span class="line">    <span class="comment">// false, makes no more calls.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// REQUIRES: user portion of internal_key == user_key.</span></span><br><span class="line">    <span class="comment">// 对于所有包含user-key的file，按照从新到旧的顺序，应用func函数</span></span><br><span class="line">    <span class="comment">// 直到func返回为false</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key, <span class="type">void</span> *arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">bool</span> (*func)(<span class="type">void</span> *, <span class="type">int</span>, FileMetaData *))</span></span>;</span><br><span class="line"></span><br><span class="line">    VersionSet *vset_; <span class="comment">// 当前版本所在的版本集合</span></span><br><span class="line">    Version *next_;    <span class="comment">// 下一个版本实例的指针</span></span><br><span class="line">    Version *prev_;    <span class="comment">// 前一个版本实例的指针</span></span><br><span class="line">    <span class="type">int</span> refs_;         <span class="comment">// 引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SSTable的信息，每一项代表相应Level的SSTable信息</span></span><br><span class="line">    <span class="comment">// 除了Level 0外，每个Level里的文件都是按照最小键的顺序排列的，并且没有重叠</span></span><br><span class="line">    <span class="comment">// 通过这个数据项，搜索SSTable时，就可以从Level 0开始搜索</span></span><br><span class="line">    std::vector&lt;FileMetaData *&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个需要压缩的文件</span></span><br><span class="line">    FileMetaData *file_to_compact_;</span><br><span class="line">    <span class="type">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line">    <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></span><br><span class="line">    <span class="comment">// are initialized by Finalize().</span></span><br><span class="line">    <span class="type">double</span> compaction_score_;</span><br><span class="line">    <span class="type">int</span> compaction_level_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取sstable文件信息的结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">GetStats</span></span><br><span class="line">    {</span><br><span class="line">        FileMetaData *seek_file;</span><br><span class="line">        <span class="type">int</span> seek_file_level;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append to *iters a sequence of iterators that will</span></span><br><span class="line">    <span class="comment">// yield the contents of this Version when merged together.</span></span><br><span class="line">    <span class="comment">// REQUIRES: This version has been saved (see VersionSet::SaveTo)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddIterators</span><span class="params">(<span class="type">const</span> ReadOptions &amp;, std::vector&lt;Iterator *&gt; *iters)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lookup the value for key.  If found, store it in *val and</span></span><br><span class="line">    <span class="comment">// return OK.  Else return a non-OK status.  Fills *stats.</span></span><br><span class="line">    <span class="comment">// REQUIRES: lock is not held</span></span><br><span class="line">    <span class="comment">// 获取值</span></span><br><span class="line">    <span class="function">Status <span class="title">Get</span><span class="params">(<span class="type">const</span> ReadOptions &amp;, <span class="type">const</span> LookupKey &amp;key, std::string *val,</span></span></span><br><span class="line"><span class="params"><span class="function">               GetStats *stats)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds "stats" into the current state.  Returns true if a new</span></span><br><span class="line">    <span class="comment">// compaction may need to be triggered, false otherwise.</span></span><br><span class="line">    <span class="comment">// REQUIRES: lock is held</span></span><br><span class="line">    <span class="comment">// 将stats 更新到version，stats记录了seek的结果，包括sts文件信息和seek的level</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">UpdateStats</span><span class="params">(<span class="type">const</span> GetStats &amp;stats)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record a sample of bytes read at the specified internal key.</span></span><br><span class="line">    <span class="comment">// Samples are taken approximately once every config::kReadBytesPeriod</span></span><br><span class="line">    <span class="comment">// bytes.  Returns true if a new compaction may need to be triggered.</span></span><br><span class="line">    <span class="comment">// REQUIRES: lock is held</span></span><br><span class="line">    <span class="comment">// 取样式get一个key，通过get，来判断当前是否需要触发compact</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">RecordReadSample</span><span class="params">(Slice key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数相关</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Ref</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unref</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有某层中超过范围的文件保存在input中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetOverlappingInputs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> level,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> InternalKey *begin, <span class="comment">// nullptr means before all keys</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> InternalKey *end,   <span class="comment">// nullptr means after all keys</span></span></span></span><br><span class="line"><span class="params"><span class="function">        std::vector&lt;FileMetaData *&gt; *inputs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当某层中存在文件的键的范围超过限制，就返回1</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OverlapInLevel</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> Slice *smallest_user_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> Slice *largest_user_key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当memtable中的key范围是[smallest_user_key,largest_user_key]时，</span></span><br><span class="line">    <span class="comment">// 应该将其压缩到那一层中（一般是在第0层，最高会堆到第2层）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">PickLevelForMemTableOutput</span><span class="params">(<span class="type">const</span> Slice &amp;smallest_user_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> Slice &amp;largest_user_key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumFiles</span><span class="params">(<span class="type">int</span> level)</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> files_[level].<span class="built_in">size</span>(); }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一条人类可读的字符串来描述当前版本的信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，我们仔细观察一下其私有成员部分，就能发现，它含有类似于双向量表中结点的前驱后继。<strong>实际上，VersuionSet可以看成是一个双向链表，而Version则是其中的结点。</strong></p>
<p>每个Version中，还会将所有的此版本中的SSTable存放在一个vector数组中，每一层对应一个下标。</p>
<p>可以看到Version是比较简单的，最重要的信息就是这个版本包含的SSTable的信息。通过这些信息，版本提供了接口Status
Version::Get(const ReadOptions&amp;, const LookupKey&amp; key,
std::string* val, GetStats*
stats)，可以在这些SSTable里读取出相应的键的值。</p>
<p>我们这里来看一下Version::Get接口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Version::Get</span><span class="params">(<span class="type">const</span> ReadOptions &amp;options, <span class="type">const</span> LookupKey &amp;k,</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::string *value, GetStats *stats)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stats-&gt;seek_file = <span class="literal">nullptr</span>;</span><br><span class="line">    stats-&gt;seek_file_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义状态结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">State</span></span><br><span class="line">    {</span><br><span class="line">        Saver saver;</span><br><span class="line">        GetStats *stats;</span><br><span class="line">        <span class="type">const</span> ReadOptions *options;</span><br><span class="line">        Slice ikey;</span><br><span class="line">        FileMetaData *last_file_read;</span><br><span class="line">        <span class="type">int</span> last_file_read_level;</span><br><span class="line"></span><br><span class="line">        VersionSet *vset;</span><br><span class="line">        Status s;</span><br><span class="line">        <span class="type">bool</span> found;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Match</span><span class="params">(<span class="type">void</span> *arg, <span class="type">int</span> level, FileMetaData *f)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            State *state = <span class="built_in">reinterpret_cast</span>&lt;State *&gt;(arg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">                state-&gt;last_file_read != <span class="literal">nullptr</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">                state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">                state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            state-&gt;last_file_read = f;</span><br><span class="line">            state-&gt;last_file_read_level = level;</span><br><span class="line"></span><br><span class="line">            state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;<span class="built_in">Get</span>(*state-&gt;options, f-&gt;number,</span><br><span class="line">                                                      f-&gt;file_size, state-&gt;ikey,</span><br><span class="line">                                                      &amp;state-&gt;saver, SaveValue);</span><br><span class="line">            <span class="keyword">if</span> (!state-&gt;s.<span class="built_in">ok</span>())</span><br><span class="line">            {</span><br><span class="line">                state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">switch</span> (state-&gt;saver.state)</span><br><span class="line">            {</span><br><span class="line">            <span class="keyword">case</span> kNotFound:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// Keep searching in other files</span></span><br><span class="line">            <span class="keyword">case</span> kFound:</span><br><span class="line">                state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> kDeleted:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> kCorrupt:</span><br><span class="line">                state-&gt;s =</span><br><span class="line">                    Status::<span class="built_in">Corruption</span>(<span class="string">"corrupted key for "</span>, state-&gt;saver.user_key);</span><br><span class="line">                state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Not reached. Added to avoid false compilation warnings of</span></span><br><span class="line">            <span class="comment">// "control reaches end of non-void function".</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    State state;</span><br><span class="line">    state.found = <span class="literal">false</span>;</span><br><span class="line">    state.stats = stats;</span><br><span class="line">    state.last_file_read = <span class="literal">nullptr</span>;</span><br><span class="line">    state.last_file_read_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    state.options = &amp;options;</span><br><span class="line">    state.ikey = k.<span class="built_in">internal_key</span>();</span><br><span class="line">    state.vset = vset_;</span><br><span class="line"></span><br><span class="line">    state.saver.state = kNotFound;</span><br><span class="line">    state.saver.ucmp = vset_-&gt;icmp_.<span class="built_in">user_comparator</span>();</span><br><span class="line">    state.saver.user_key = k.<span class="built_in">user_key</span>();</span><br><span class="line">    state.saver.value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在每层内将每个受当前版本管理的sstable中进行查找</span></span><br><span class="line">    <span class="comment">// 就相当于sstable的查找</span></span><br><span class="line">    <span class="built_in">ForEachOverlapping</span>(state.saver.user_key, state.ikey, &amp;state, &amp;State::Match);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> state.found ? state.s : Status::<span class="built_in">NotFound</span>(<span class="built_in">Slice</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Version::ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key, <span class="type">void</span> *arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">bool</span> (*func)(<span class="type">void</span> *, <span class="type">int</span>, FileMetaData *))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> Comparator *ucmp = vset_-&gt;icmp_.<span class="built_in">user_comparator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第0层的查找，每个都查找</span></span><br><span class="line">    std::vector&lt;FileMetaData *&gt; tmp;</span><br><span class="line">    tmp.<span class="built_in">reserve</span>(files_[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        FileMetaData *f = files_[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">if</span> (ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;smallest.<span class="built_in">user_key</span>()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;largest.<span class="built_in">user_key</span>()) &lt;= <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(f);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!tmp.<span class="built_in">empty</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 由新到旧排序，并比对返回数据</span></span><br><span class="line">        std::<span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), NewestFirst);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (!(*func)(arg, <span class="number">0</span>, tmp[i]))</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找其他层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">1</span>; level &lt; config::kNumLevels; level++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">size_t</span> num_files = files_[level].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (num_files == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="type">uint32_t</span> index = <span class="built_in">FindFile</span>(vset_-&gt;icmp_, files_[level], internal_key);</span><br><span class="line">        <span class="keyword">if</span> (index &lt; num_files)</span><br><span class="line">        {</span><br><span class="line">            FileMetaData *f = files_[level][index];</span><br><span class="line">            <span class="keyword">if</span> (ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;smallest.<span class="built_in">user_key</span>()) &lt; <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// All of "f" is past any data for user_key</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (!(*func)(arg, level, f))</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于每个版本负责管理一系列的SSTable，所以对于这一系列的SSTable的查找也是通过Version来实现的。其中还是要考虑到第0层和其他层查找的差异性。</p>
<h3 id="versionset">VersionSet</h3>
<p>VersionSet就是一个Version的集合，里面包含了一个当前存活的Version的双链表。不过除了Version以外，VersionSet还保存了一些全局的只有一份的元数据。VersionSet只有一个实例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VersionSet</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Builder</span>; <span class="comment">// 辅助构建类。主要用于保存中间变量相关等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Compaction</span>; <span class="comment">// 友元类，压缩线程</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Version</span>;    <span class="comment">// 友元类，版本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复Manifest文件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ReuseManifest</span><span class="params">(<span class="type">const</span> std::string &amp;dscname, <span class="type">const</span> std::string &amp;dscbase)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算得到Size Compaction的最佳level和比率score</span></span><br><span class="line">    <span class="comment">// 用于压缩</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Finalize</span><span class="params">(Version *v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有input中的key最小最大</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetRange</span><span class="params">(<span class="type">const</span> std::vector&lt;FileMetaData *&gt; &amp;inputs, InternalKey *smallest,</span></span></span><br><span class="line"><span class="params"><span class="function">                  InternalKey *largest)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetRange2</span><span class="params">(<span class="type">const</span> std::vector&lt;FileMetaData *&gt; &amp;inputs1,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> std::vector&lt;FileMetaData *&gt; &amp;inputs2,</span></span></span><br><span class="line"><span class="params"><span class="function">                   InternalKey *smallest, InternalKey *largest)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在指定的level+1中选择那些key range与input _[0]中所有文件key range重合的文件填入input_[1]</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetupOtherInputs</span><span class="params">(Compaction *c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存快照</span></span><br><span class="line">    <span class="function">Status <span class="title">WriteSnapshot</span><span class="params">(log::Writer *log)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让版本v成为当前版本</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendVersion</span><span class="params">(Version *v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**一些变量**/</span></span><br><span class="line">    Env *<span class="type">const</span> env_;                   <span class="comment">// 环境</span></span><br><span class="line">    <span class="type">const</span> std::string dbname_;         <span class="comment">// 数据库名字</span></span><br><span class="line">    <span class="type">const</span> Options *<span class="type">const</span> options_;     <span class="comment">// 选项</span></span><br><span class="line">    TableCache *<span class="type">const</span> table_cache_;    <span class="comment">// 缓存</span></span><br><span class="line">    <span class="type">const</span> InternalKeyComparator icmp_; <span class="comment">// 比较器</span></span><br><span class="line">    <span class="type">uint64_t</span> next_file_number_;        <span class="comment">// 下一个序列号</span></span><br><span class="line">    <span class="type">uint64_t</span> manifest_file_number_;    <span class="comment">// manifest的序列号</span></span><br><span class="line">    <span class="type">uint64_t</span> last_sequence_;           <span class="comment">// 上一个序列号</span></span><br><span class="line">    <span class="type">uint64_t</span> log_number_;              <span class="comment">// 日志号</span></span><br><span class="line">    <span class="type">uint64_t</span> prev_log_number_;         <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Opened lazily</span></span><br><span class="line">    WritableFile *descriptor_file_; <span class="comment">// 文件写入</span></span><br><span class="line">    log::Writer *descriptor_log_;   <span class="comment">// 日志写入</span></span><br><span class="line">    Version dummy_versions_;        <span class="comment">// 双向链表头结点</span></span><br><span class="line">    Version *current_;              <span class="comment">// == dummy_versions_.prev_</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是用来记录Compact的进度，Compact总是从某一Level的最小的键开始到某个键结束，</span></span><br><span class="line">    <span class="comment">// 下次再从下一个键开始，所以这个就是下一次这个Level从哪个键开始Compact</span></span><br><span class="line">    std::string compact_pointer_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造析构函数</span></span><br><span class="line">    <span class="built_in">VersionSet</span>(<span class="type">const</span> std::string &amp;dbname, <span class="type">const</span> Options *options,</span><br><span class="line">               TableCache *table_cache, <span class="type">const</span> InternalKeyComparator *);</span><br><span class="line">    <span class="built_in">VersionSet</span>(<span class="type">const</span> VersionSet &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    VersionSet &amp;<span class="keyword">operator</span>=(<span class="type">const</span> VersionSet &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">VersionSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply *edit to the current version to form a new descriptor that</span></span><br><span class="line">    <span class="comment">// is both saved to persistent state and installed as the new</span></span><br><span class="line">    <span class="comment">// current version.  Will release *mu while actually writing to the file.</span></span><br><span class="line">    <span class="comment">// REQUIRES: *mu is held on entry.</span></span><br><span class="line">    <span class="comment">// REQUIRES: no other thread concurrently calls LogAndApply()</span></span><br><span class="line">    <span class="comment">// 将根据前面记录的版本修改信息更新当前版本，得到一个新的版本信息</span></span><br><span class="line">    <span class="comment">// 同时把这个新的版本信息设置成当前VersionSet的current_，并连入版本集合的链表中</span></span><br><span class="line">    <span class="function">Status <span class="title">LogAndApply</span><span class="params">(VersionEdit *edit, port::Mutex *mu)</span></span></span><br><span class="line"><span class="function">        <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mu)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复用</span></span><br><span class="line">    <span class="function">Status <span class="title">Recover</span><span class="params">(<span class="type">bool</span> *save_manifest)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前版本</span></span><br><span class="line">    <span class="function">Version *<span class="title">current</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> current_; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前文件号</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">ManifestFileNumber</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> manifest_file_number_; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配并返回新的文件号</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">NewFileNumber</span><span class="params">()</span> </span>{ <span class="keyword">return</span> next_file_number_++; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arrange to reuse "file_number" unless a newer file number has</span></span><br><span class="line">    <span class="comment">// already been allocated.</span></span><br><span class="line">    <span class="comment">// REQUIRES: "file_number" was returned by a call to NewFileNumber().</span></span><br><span class="line">    <span class="comment">// 复用文件号，仅当新的文件号被占用时才会调用此函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReuseFileNumber</span><span class="params">(<span class="type">uint64_t</span> file_number)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (next_file_number_ == file_number + <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            next_file_number_ = file_number;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回某一层的文件数目</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumLevelFiles</span><span class="params">(<span class="type">int</span> level)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回某一层的文件字节数目</span></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">NumLevelBytes</span><span class="params">(<span class="type">int</span> level)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最后序列号</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">LastSequence</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> last_sequence_; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置最后序列号为s</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLastSequence</span><span class="params">(<span class="type">uint64_t</span> s)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">assert</span>(s &gt;= last_sequence_);</span><br><span class="line">        last_sequence_ = s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记一个序列号为已使用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MarkFileNumberUsed</span><span class="params">(<span class="type">uint64_t</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前log编号</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">LogNumber</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> log_number_; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the log file number for the log file that is currently</span></span><br><span class="line">    <span class="comment">// being compacted, or zero if there is no such log file.</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">PrevLogNumber</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> prev_log_number_; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick level and inputs for a new compaction.</span></span><br><span class="line">    <span class="comment">// Returns nullptr if there is no compaction to be done.</span></span><br><span class="line">    <span class="comment">// Otherwise returns a pointer to a heap-allocated object that</span></span><br><span class="line">    <span class="comment">// describes the compaction.  Caller should delete the result.</span></span><br><span class="line">    <span class="comment">// 选择一层来执行新的压缩，若没有需要进行的压缩，则返回空</span></span><br><span class="line">    <span class="comment">// 否则返回一个堆分配内存来描述压缩结果，需要调用者来释放</span></span><br><span class="line">    <span class="comment">// 这个选择是选择实现计算出来下次需要压缩的文件</span></span><br><span class="line">    <span class="function">Compaction *<span class="title">PickCompaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return a compaction object for compacting the range [begin,end] in</span></span><br><span class="line">    <span class="comment">// the specified level.  Returns nullptr if there is nothing in that</span></span><br><span class="line">    <span class="comment">// level that overlaps the specified range.  Caller should delete</span></span><br><span class="line">    <span class="comment">// the result.</span></span><br><span class="line">    <span class="comment">// 压缩指定层中的指定范围，不重叠的话就没有压缩</span></span><br><span class="line">    <span class="function">Compaction *<span class="title">CompactRange</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> InternalKey *begin,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> InternalKey *end)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the maximum overlapping data (in bytes) at next level for any</span></span><br><span class="line">    <span class="comment">// file at a level &gt;= 1.</span></span><br><span class="line">    <span class="comment">// 返回最大重叠数据</span></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">MaxNextLevelOverlappingBytes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create an iterator that reads over the compaction inputs for "*c".</span></span><br><span class="line">    <span class="comment">// The caller should delete the iterator when no longer needed.</span></span><br><span class="line">    <span class="comment">// 返回一个可以从N个SSTable中提取出来不重复key的迭代器。</span></span><br><span class="line">    <span class="function">Iterator *<span class="title">MakeInputIterator</span><span class="params">(Compaction *c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true iff some level needs a compaction.</span></span><br><span class="line">    <span class="comment">// 是否存在某些层需要压缩</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Version *v = current_;</span><br><span class="line">        <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add all files listed in any live version to *live.</span></span><br><span class="line">    <span class="comment">// May also mutate some internal state.</span></span><br><span class="line">    <span class="comment">// 把所有存活版本中的文件记录到集合中(即记录所有存活文件)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddLiveFiles</span><span class="params">(std::set&lt;<span class="type">uint64_t</span>&gt; *live)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the approximate offset in the database of the data for</span></span><br><span class="line">    <span class="comment">// "key" as of version "v".</span></span><br><span class="line">    <span class="comment">// 返回在版本v中，key的大致偏移</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">ApproximateOffsetOf</span><span class="params">(Version *v, <span class="type">const</span> InternalKey &amp;key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return a human-readable short (single-line) summary of the number</span></span><br><span class="line">    <span class="comment">// of files per level.  Uses *scratch as backing store.</span></span><br><span class="line">    <span class="comment">// 返回人类可读的总结</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LevelSummaryStorage</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">LevelSummary</span><span class="params">(LevelSummaryStorage *scratch)</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，VersionSet除了保存了Version的双链表以外，还保存了其它的一些元数据。有些元数据，比如当前的版本，当数据库关闭后，再次打开的时候还是需要的，这些信息就持久化到MANIFEST文件中。</p>
<p>当然，还涉及到一些压缩相关的内容，这个在后面深入学习。</p>
<h3 id="versionedit">VersionEdit</h3>
<p>VersionEdit记录了一次版本变更有哪些改变。即有<strong>Version(旧) +
VersionEdit(修改部分) =
Version(新)</strong>，其中对于加号是Builder的体现，后面再说。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VersionEdit</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">VersionSet</span>; <span class="comment">// 因为需要从VersionSet中来修改Version</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">uint64_t</span>&gt;&gt; DeletedFileSet; <span class="comment">// 删除掉的文件集合别名</span></span><br><span class="line"></span><br><span class="line">    std::string comparator_;       <span class="comment">// 比较器名字</span></span><br><span class="line">    <span class="type">uint64_t</span> log_number_;          <span class="comment">// 日志号</span></span><br><span class="line">    <span class="type">uint64_t</span> prev_log_number_;     <span class="comment">// 上一个ldb、log和manifset文件编号</span></span><br><span class="line">    <span class="type">uint64_t</span> next_file_number_;    <span class="comment">// 下一个编号</span></span><br><span class="line">    SequenceNumber last_sequence_; <span class="comment">// 上一个序列号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> has_comparator_; <span class="comment">// 记录上面对应内容是否存在，存在才会持久化的MANIFEST中的一些字段</span></span><br><span class="line">    <span class="type">bool</span> has_log_number_;</span><br><span class="line">    <span class="type">bool</span> has_prev_log_number_;</span><br><span class="line">    <span class="type">bool</span> has_next_file_number_;</span><br><span class="line">    <span class="type">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和VersionSet里面的compact_pointers_相同</span></span><br><span class="line">    <span class="comment">// 用来记录Compact的进度，Compact总是从某一Level的最小的键开始到某个键结束</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line">    <span class="comment">// 有哪些文件被删除，就是Version里哪些SSTable被删除</span></span><br><span class="line">    DeletedFileSet deleted_files_;</span><br><span class="line">    <span class="comment">// 有哪些文件被增加，pair的第一个参数是Level，第二个参数是文件的元信息</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, FileMetaData&gt;&gt; new_files_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VersionEdit</span>() { <span class="built_in">Clear</span>(); }</span><br><span class="line">    ~<span class="built_in">VersionEdit</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下列函数就是在设置私有成员中的值的接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetComparatorName</span><span class="params">(<span class="type">const</span> Slice &amp;name)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        has_comparator_ = <span class="literal">true</span>;</span><br><span class="line">        comparator_ = name.<span class="built_in">ToString</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLogNumber</span><span class="params">(<span class="type">uint64_t</span> num)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        has_log_number_ = <span class="literal">true</span>;</span><br><span class="line">        log_number_ = num;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetPrevLogNumber</span><span class="params">(<span class="type">uint64_t</span> num)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        has_prev_log_number_ = <span class="literal">true</span>;</span><br><span class="line">        prev_log_number_ = num;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNextFile</span><span class="params">(<span class="type">uint64_t</span> num)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        has_next_file_number_ = <span class="literal">true</span>;</span><br><span class="line">        next_file_number_ = num;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLastSequence</span><span class="params">(SequenceNumber seq)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        has_last_sequence_ = <span class="literal">true</span>;</span><br><span class="line">        last_sequence_ = seq;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetCompactPointer</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> InternalKey &amp;key)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        compact_pointers_.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(level, key));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the specified file at the specified number.</span></span><br><span class="line">    <span class="comment">// REQUIRES: This version has not been saved (see VersionSet::SaveTo)</span></span><br><span class="line">    <span class="comment">// REQUIRES: "smallest" and "largest" are smallest and largest keys in file</span></span><br><span class="line">    <span class="comment">// 在某一层中新增文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddFile</span><span class="params">(<span class="type">int</span> level, <span class="type">uint64_t</span> file, <span class="type">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> InternalKey &amp;smallest, <span class="type">const</span> InternalKey &amp;largest)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        FileMetaData f;</span><br><span class="line">        f.number = file;</span><br><span class="line">        f.file_size = file_size;</span><br><span class="line">        f.smallest = smallest;</span><br><span class="line">        f.largest = largest;</span><br><span class="line">        new_files_.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(level, f));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete the specified "file" from the specified "level".</span></span><br><span class="line">    <span class="comment">// 删除某一层的文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveFile</span><span class="params">(<span class="type">int</span> level, <span class="type">uint64_t</span> file)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        deleted_files_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(level, file));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码解码</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EncodeTo</span><span class="params">(std::string *dst)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Status <span class="title">DecodeFrom</span><span class="params">(<span class="type">const</span> Slice &amp;src)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回人类可读字串</span></span><br><span class="line">    <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到VersionEdit类中基本上就是一些私有成员，这些信息主要是为了持久化到MANIFEST，其中对SSTable文件的修改则通过对应的增加删除函数来完成。</p>
<p>VersionEdit主要有两个作用一个就是应用到版本上作版本变迁，这个就是Builder做的事情，这主要发生在内存的数据结构中。另外一个作用就是持久化到MANIFEST记录版本变迁的内容，这里会记录更多的内容，包括last_sequence_、next_file_number等，由VersionEdit::EncodeTo完成。</p>
<p>主要有两个地方需要持久化：</p>
<ul>
<li>初始写入，需要写入当前数据状态的信息</li>
<li>版本变迁写入，写入的是每一次版本变化的写入</li>
</ul>
<p>初始写入，是由VersionSet::WriteSnapshot完成，当打开一个已存在的数据库，读取完现有的MANIFEST后，如果要新建一个MANIFEST替换现有的MANIFEST，就要先调用这个函数，将现有的数据库状态写入，主要包括三部分内容：</p>
<ul>
<li>比较器的名称</li>
<li>compact_pointer_数组，可能有多条记录，有Level和对应的Internal
Key，表示Size Compaction的进程</li>
<li>当前存在的SSTable文件，包含元数据，包括在哪一Level，文件编号，文件大小，里面的最小键和最大键</li>
</ul>
<img src="/2022/12/19/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-15/pic3.jpg" class="">
<p>版本变迁写入，就是当需要生成一个新版本时，都会向MANIFEST写入一条新纪录，记录了新版本相对旧版本有哪些变化，和旧版本合并后可以得出当前的状态，主要包括以下几部分：</p>
<ul>
<li>写入时刻的日志编号</li>
<li>写入时刻下个可用文件的编号</li>
<li>写入时刻上一个用掉的SequenceNumber</li>
<li>compact_pointer_数组，可能有多条记录，有Level和对应的Internal
Key</li>
<li>记录删除了哪些文件，只记录了Level和对应的file number</li>
<li>当前存在的SSTable文件，包含元数据，包括在哪一Level，文件编号，文件大小，里面的最小键和最大键</li>
</ul>
<img src="/2022/12/19/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-15/pic4.jpg" class="">
<p>这部分是其持久化时的源码，很简单。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Tag</span></span><br><span class="line">{</span><br><span class="line">    kComparator = <span class="number">1</span>,     <span class="comment">// 记录Comparator的名字</span></span><br><span class="line">    kLogNumber = <span class="number">2</span>,      <span class="comment">// 记录当前时刻的log_number</span></span><br><span class="line">    kNextFileNumber = <span class="number">3</span>, <span class="comment">// 记录当前时刻的next_file_number_</span></span><br><span class="line">    kLastSequence = <span class="number">4</span>,   <span class="comment">// 记录当前时刻的last_sequence</span></span><br><span class="line">    kCompactPointer = <span class="number">5</span>, <span class="comment">// 记录compact_pointer</span></span><br><span class="line">    kDeletedFile = <span class="number">6</span>,    <span class="comment">// 记录删除的文件信息</span></span><br><span class="line">    kNewFile = <span class="number">7</span>         <span class="comment">// 记录新增的文件信息</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VersionEdit::EncodeTo</span><span class="params">(std::string *dst)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (has_comparator_)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">PutVarint32</span>(dst, kComparator);</span><br><span class="line">        <span class="built_in">PutLengthPrefixedSlice</span>(dst, comparator_);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (has_log_number_)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">PutVarint32</span>(dst, kLogNumber);</span><br><span class="line">        <span class="built_in">PutVarint64</span>(dst, log_number_);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (has_prev_log_number_)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">PutVarint32</span>(dst, kPrevLogNumber);</span><br><span class="line">        <span class="built_in">PutVarint64</span>(dst, prev_log_number_);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (has_next_file_number_)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">PutVarint32</span>(dst, kNextFileNumber);</span><br><span class="line">        <span class="built_in">PutVarint64</span>(dst, next_file_number_);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (has_last_sequence_)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">PutVarint32</span>(dst, kLastSequence);</span><br><span class="line">        <span class="built_in">PutVarint64</span>(dst, last_sequence_);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; compact_pointers_.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">PutVarint32</span>(dst, kCompactPointer);</span><br><span class="line">        <span class="built_in">PutVarint32</span>(dst, compact_pointers_[i].first); <span class="comment">// level</span></span><br><span class="line">        <span class="built_in">PutLengthPrefixedSlice</span>(dst, compact_pointers_[i].second.<span class="built_in">Encode</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;deleted_file_kvp : deleted_files_)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">PutVarint32</span>(dst, kDeletedFile);</span><br><span class="line">        <span class="built_in">PutVarint32</span>(dst, deleted_file_kvp.first);  <span class="comment">// level</span></span><br><span class="line">        <span class="built_in">PutVarint64</span>(dst, deleted_file_kvp.second); <span class="comment">// file number</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; new_files_.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">const</span> FileMetaData &amp;f = new_files_[i].second;</span><br><span class="line">        <span class="built_in">PutVarint32</span>(dst, kNewFile);</span><br><span class="line">        <span class="built_in">PutVarint32</span>(dst, new_files_[i].first); <span class="comment">// level</span></span><br><span class="line">        <span class="built_in">PutVarint64</span>(dst, f.number);</span><br><span class="line">        <span class="built_in">PutVarint64</span>(dst, f.file_size);</span><br><span class="line">        <span class="built_in">PutLengthPrefixedSlice</span>(dst, f.smallest.<span class="built_in">Encode</span>());</span><br><span class="line">        <span class="built_in">PutLengthPrefixedSlice</span>(dst, f.largest.<span class="built_in">Encode</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="builder">Builder</h3>
<p>前面也提到过，Version(旧) + VersionEdit(修改部分) =
Version(新)，而其中的加号就是Builder。</p>
<p>我们可能会问为什么还需要Builder，当有VersionEdit改变版本时，直接引用到当前的Version生成一个新的Version即可。这其实是为了效率，才引入了Builder。正常情况下，一次Compaction或者MemTable写入后，会产生一个VersionEdit，将这个VersionEdit应用到当前Version上生成一个新的Version，这没有什么问题。不过在版本变更时，也会将VersionEdit的内容写入MANIFEST中。当重新打开一个数据库时，需要读取MANIFEST重新构造版本信息，这个版本信息由初始的Version和多个VersionEdit生成，如果直接用VersionEdit应用会生成多个版本，降低了效率。所以使用了Builder，将多个VersionEdit的内容累积到Builder上，然后一次性应用到当前Version即可生成新的Version。</p>
<img src="/2022/12/19/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-15/pic5.jpg" class="">
<p>过程大致如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">VersionSet::Builder <span class="title">builder</span><span class="params">(&amp;vset, curr_version)</span></span>;  <span class="comment">// 创建一个builder</span></span><br><span class="line">builder.<span class="built_in">Apply</span>(version_edit1);                      <span class="comment">// 应用VersionEdit，可应用多个</span></span><br><span class="line">builder.<span class="built_in">Apply</span>(version_edit2);</span><br><span class="line">Version new_version;               </span><br><span class="line">builder.<span class="built_in">SaveTo</span>(&amp;new_version);                      <span class="comment">// 将之前的Version和VersionEdit生成一个新的Version</span></span><br><span class="line">vset.<span class="built_in">AppendVersion</span>(new_version);                   <span class="comment">// 将新Version添加到VersionSet</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们来看一下Builder类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VersionSet</span>::Builder</span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Helper to sort by v-&gt;files_[file_number].smallest</span></span><br><span class="line">    <span class="comment">// 用来辅助将v-&gt;files_[file_number].smallest进行排序</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BySmallestKey</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">const</span> InternalKeyComparator *internal_comparator;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FileMetaData *f1, FileMetaData *f2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="type">int</span> r = internal_comparator-&gt;<span class="built_in">Compare</span>(f1-&gt;smallest, f2-&gt;smallest);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> (r &lt; <span class="number">0</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// Break ties by file number</span></span><br><span class="line">                <span class="built_in">return</span> (f1-&gt;number &lt; f2-&gt;number);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> std::set&lt;FileMetaData *, BySmallestKey&gt; FileSet;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LevelState</span></span><br><span class="line">    {</span><br><span class="line">        std::set&lt;<span class="type">uint64_t</span>&gt; deleted_files;</span><br><span class="line">        FileSet *added_files;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    VersionSet *vset_; <span class="comment">// 所属的集合</span></span><br><span class="line">    Version *base_;    <span class="comment">// 旧Version</span></span><br><span class="line">    LevelState levels_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Initialize a builder with the files from *base and other info from *vset</span></span><br><span class="line">    <span class="built_in">Builder</span>(VersionSet *vset, Version *base) : <span class="built_in">vset_</span>(vset), <span class="built_in">base_</span>(base)</span><br><span class="line">    {</span><br><span class="line">        base_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">        BySmallestKey cmp;</span><br><span class="line">        cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++)</span><br><span class="line">        {</span><br><span class="line">            levels_[level].added_files = <span class="keyword">new</span> <span class="built_in">FileSet</span>(cmp);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数，需要对文件解除引用，也需要对版本解除引用</span></span><br><span class="line">    ~<span class="built_in">Builder</span>()</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">const</span> FileSet *added = levels_[level].added_files;</span><br><span class="line">            std::vector&lt;FileMetaData *&gt; to_unref;</span><br><span class="line">            to_unref.<span class="built_in">reserve</span>(added-&gt;<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span> (FileSet::const_iterator it = added-&gt;<span class="built_in">begin</span>(); it != added-&gt;<span class="built_in">end</span>();</span><br><span class="line">                 ++it)</span><br><span class="line">            {</span><br><span class="line">                to_unref.<span class="built_in">push_back</span>(*it);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">delete</span> added;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; to_unref.<span class="built_in">size</span>(); i++)</span><br><span class="line">            {</span><br><span class="line">                FileMetaData *f = to_unref[i];</span><br><span class="line">                f-&gt;refs--;</span><br><span class="line">                <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">delete</span> f;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        base_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用VersionEdit到当前版本上</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Apply</span><span class="params">(<span class="type">const</span> VersionEdit *edit)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 首先更新comact_pointer_，这个直接在VersionSet里更新，因为这个的信息只有一份</span></span><br><span class="line">        <span class="comment">// 新版本肯定是覆盖旧版本的，所以直接更新即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.<span class="built_in">size</span>(); i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">            vset_-&gt;compact_pointer_[level] =</span><br><span class="line">                edit-&gt;compact_pointers_[i].second.<span class="built_in">Encode</span>().<span class="built_in">ToString</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把VersionEdit里删除的文件插入到levels_相应Level里面去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;deleted_file_set_kvp : edit-&gt;deleted_files_)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">            <span class="type">const</span> <span class="type">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">            levels_[level].deleted_files.<span class="built_in">insert</span>(number);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把VersionEdit里添加的文件插入到levels_相应的Level里去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.<span class="built_in">size</span>(); i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">            <span class="comment">// 因为是新文件，构造一个FileMetaData</span></span><br><span class="line">            FileMetaData *f = <span class="keyword">new</span> <span class="built_in">FileMetaData</span>(edit-&gt;new_files_[i].second);</span><br><span class="line">            f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We arrange to automatically compact this file after</span></span><br><span class="line">            <span class="comment">// a certain number of seeks.  Let's assume:</span></span><br><span class="line">            <span class="comment">//   (1) One seek costs 10ms</span></span><br><span class="line">            <span class="comment">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span></span><br><span class="line">            <span class="comment">//   (3) A compaction of 1MB does 25MB of IO:</span></span><br><span class="line">            <span class="comment">//         1MB read from this level</span></span><br><span class="line">            <span class="comment">//         10-12MB read from next level (boundaries may be misaligned)</span></span><br><span class="line">            <span class="comment">//         10-12MB written to next level</span></span><br><span class="line">            <span class="comment">// This implies that 25 seeks cost the same as the compaction</span></span><br><span class="line">            <span class="comment">// of 1MB of data.  I.e., one seek costs approximately the</span></span><br><span class="line">            <span class="comment">// same as the compaction of 40KB of data.  We are a little</span></span><br><span class="line">            <span class="comment">// conservative and allow approximately one seek for every 16KB</span></span><br><span class="line">            <span class="comment">// of data before triggering a compaction.</span></span><br><span class="line">            f-&gt;allowed_seeks = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>));</span><br><span class="line">            <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>)</span><br><span class="line">                f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">            levels_[level].deleted_files.<span class="built_in">erase</span>(f-&gt;number);</span><br><span class="line">            levels_[level].added_files-&gt;<span class="built_in">insert</span>(f);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新版本存储到版本v中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SaveTo</span><span class="params">(Version *v)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        BySmallestKey cmp;</span><br><span class="line">        cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Merge the set of added files with the set of pre-existing files.</span></span><br><span class="line">            <span class="comment">// Drop any deleted files.  Store the result in *v.</span></span><br><span class="line">            <span class="comment">// 拿出原本Version里的文件，以及Builder里累积的，添加的文件</span></span><br><span class="line">            <span class="type">const</span> std::vector&lt;FileMetaData *&gt; &amp;base_files = base_-&gt;files_[level];</span><br><span class="line">            std::vector&lt;FileMetaData *&gt;::const_iterator base_iter = base_files.<span class="built_in">begin</span>();</span><br><span class="line">            std::vector&lt;FileMetaData *&gt;::const_iterator base_end = base_files.<span class="built_in">end</span>();</span><br><span class="line">            <span class="type">const</span> FileSet *added_files = levels_[level].added_files;</span><br><span class="line">            v-&gt;files_[level].<span class="built_in">reserve</span>(base_files.<span class="built_in">size</span>() + added_files-&gt;<span class="built_in">size</span>());</span><br><span class="line">            <span class="comment">// 按顺序进行合并</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;added_file : *added_files)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// Add all smaller files listed in base_</span></span><br><span class="line">                <span class="comment">// 找到base里面比added_file小的文件，添加到新的Version里</span></span><br><span class="line">                <span class="comment">// 采用MaybeAddFile，让被删除的文件无法添加</span></span><br><span class="line">                <span class="keyword">for</span> (std::vector&lt;FileMetaData *&gt;::const_iterator bpos =</span><br><span class="line">                         std::<span class="built_in">upper_bound</span>(base_iter, base_end, added_file, cmp);</span><br><span class="line">                     base_iter != bpos; ++base_iter)</span><br><span class="line">                {</span><br><span class="line">                    <span class="built_in">MaybeAddFile</span>(v, level, *base_iter);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="built_in">MaybeAddFile</span>(v, level, added_file);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add remaining base files</span></span><br><span class="line">            <span class="keyword">for</span> (; base_iter != base_end; ++base_iter)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">MaybeAddFile</span>(v, level, *base_iter);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">            <span class="comment">// Make sure there is no overlap in levels &gt; 0</span></span><br><span class="line">            <span class="keyword">if</span> (level &gt; <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">1</span>; i &lt; v-&gt;files_[level].<span class="built_in">size</span>(); i++)</span><br><span class="line">                {</span><br><span class="line">                    <span class="type">const</span> InternalKey &amp;prev_end = v-&gt;files_[level][i - <span class="number">1</span>]-&gt;largest;</span><br><span class="line">                    <span class="type">const</span> InternalKey &amp;this_begin = v-&gt;files_[level][i]-&gt;smallest;</span><br><span class="line">                    <span class="keyword">if</span> (vset_-&gt;icmp_.<span class="built_in">Compare</span>(prev_end, this_begin) &gt;= <span class="number">0</span>)</span><br><span class="line">                    {</span><br><span class="line">                        std::<span class="built_in">fprintf</span>(stderr, <span class="string">"overlapping ranges in same level %s vs. %s\n"</span>,</span><br><span class="line">                                     prev_end.<span class="built_in">DebugString</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">                                     this_begin.<span class="built_in">DebugString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">                        std::<span class="built_in">abort</span>();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MaybeAddFile</span><span class="params">(Version *v, <span class="type">int</span> level, FileMetaData *f)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (levels_[level].deleted_files.<span class="built_in">count</span>(f-&gt;number) &gt; <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// File is deleted: do nothing</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            std::vector&lt;FileMetaData *&gt; *files = &amp;v-&gt;files_[level];</span><br><span class="line">            <span class="keyword">if</span> (level &gt; <span class="number">0</span> &amp;&amp; !files-&gt;<span class="built_in">empty</span>())</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// Must not overlap</span></span><br><span class="line">                <span class="built_in">assert</span>(vset_-&gt;icmp_.<span class="built_in">Compare</span>((*files)[files-&gt;<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;largest,</span><br><span class="line">                                            f-&gt;smallest) &lt; <span class="number">0</span>);</span><br><span class="line">            }</span><br><span class="line">            f-&gt;refs++;</span><br><span class="line">            files-&gt;<span class="built_in">push_back</span>(f);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中apply函数是负责将修改记录VersionEdit应用，saveto是将应用过若干版本修改的最终版本保存到一个新版本上。</p>
<h3 id="版本变迁">版本变迁</h3>
<p>版本变迁是通过VersionSet中的LogAndApply来完成的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 输入参数edit表示的是改变的内容，比如一次Compaction可以得到edit</span></span><br><span class="line"><span class="function">Status <span class="title">VersionSet::LogAndApply</span><span class="params">(VersionEdit *edit, port::Mutex *mu)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 前面是对edit进行赋值</span></span><br><span class="line">    <span class="keyword">if</span> (edit-&gt;has_log_number_)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">assert</span>(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">        <span class="built_in">assert</span>(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        edit-&gt;<span class="built_in">SetLogNumber</span>(log_number_);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_)</span><br><span class="line">    {</span><br><span class="line">        edit-&gt;<span class="built_in">SetPrevLogNumber</span>(prev_log_number_);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    edit-&gt;<span class="built_in">SetNextFile</span>(next_file_number_);</span><br><span class="line">    edit-&gt;<span class="built_in">SetLastSequence</span>(last_sequence_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新版本，新版本是current_和edit的结合</span></span><br><span class="line">    Version *v = <span class="keyword">new</span> <span class="built_in">Version</span>(<span class="keyword">this</span>);</span><br><span class="line">    {</span><br><span class="line">        <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">        builder.<span class="built_in">Apply</span>(edit);</span><br><span class="line">        builder.<span class="built_in">SaveTo</span>(v);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Finalize</span>(v); <span class="comment">// 对v进行可能的压缩</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">    <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">    std::string new_manifest_file;</span><br><span class="line">    Status s;</span><br><span class="line">    <span class="comment">// 这里只有Open数据库的时候才会走到，如果需要保存新的MANIFEST，此时这个变量为null</span></span><br><span class="line">    <span class="comment">// 会创建一个新的MANIFEST，然后将当前的状态写入</span></span><br><span class="line">    <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">        <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">        <span class="built_in">assert</span>(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">        new_manifest_file = <span class="built_in">DescriptorFileName</span>(dbname_, manifest_file_number_);</span><br><span class="line">        s = env_-&gt;<span class="built_in">NewWritableFile</span>(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            descriptor_log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(descriptor_file_);</span><br><span class="line">            s = <span class="built_in">WriteSnapshot</span>(descriptor_log_);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">    {</span><br><span class="line">        mu-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            std::string record;</span><br><span class="line">            edit-&gt;<span class="built_in">EncodeTo</span>(&amp;record);</span><br><span class="line">            s = descriptor_log_-&gt;<span class="built_in">AddRecord</span>(record);</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">            {</span><br><span class="line">                s = descriptor_file_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">ok</span>())</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">Log</span>(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">        <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; !new_manifest_file.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            s = <span class="built_in">SetCurrentFile</span>(env_, dbname_, manifest_file_number_);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        mu-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装新版本，会把v放到VersionSet的链表中，然后将当前Version指向v</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">AppendVersion</span>(v);</span><br><span class="line">        log_number_ = edit-&gt;log_number_;</span><br><span class="line">        prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">delete</span> v;</span><br><span class="line">        <span class="keyword">if</span> (!new_manifest_file.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">            <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">            descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">            descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">            env_-&gt;<span class="built_in">RemoveFile</span>(new_manifest_file);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>版本变迁基本的流程如下：</p>
<ul>
<li>首先有了一个准备好的VersionEdit实例，包含了版本变迁的内容，然后设置其它的一些字段</li>
<li>然后生成一个新的Version，使用Builder将当前的版本和VersionEdit应用生成一个新的Version</li>
<li>如果当前MANIFEST的描述符不存在，新生成一个MANIFEST文件，将当前状态写入</li>
<li>将VersionEdit的内容写入到MANIFEST文件</li>
<li>将新生成的Version加入到VersionSet，替换当前的Version</li>
</ul>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>从ucore来总结操作系统(1)----操作系统的镜像、引导和内核调试</title>
    <url>/2023/01/14/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/</url>
    <content><![CDATA[<h2 id="操作系统的镜像引导和内核调试">操作系统的镜像、引导和内核调试</h2>
<span id="more"></span>
<p>最近看完了《现代操作系统》一书，想着顺便找个lab做做看，体验一下写操作系统的快乐，同时加深一下对操作系统的理解。然后就看到了清华大学的ucore
lab，这个lab是清华大学操作系统课程的lab，是一个很好的入门lab，所以就决定做做这个lab玩一玩。</p>
<div class="note primary">
            <p>下面给出这个lab对应的视频、github仓库和实验指导书</p><ul><li>视频 : <a href="https://www.bilibili.com/video/BV1uW411f72n/"><font color="#0000ff">清华操作系统原理</font></a></li><li>Github : <a href="https://github.com/kiukotsu/ucore"><font color="#0000ff">ucore_lab</font></a></li><li>实验指导书 : <a href="https://objectkuan.gitbooks.io/ucore-docs/content/lab0/lab0_1_goals.html"><font color="#0000ff">ucore_lab_guide</font></a></li></ul>
          </div>
<div class="note warning">
            <p>另外，需要注意的一点就是，这个仓库的代码是存在一些问题的，如果在比较新版本的GCC下运行，容易出现以下<a href="https://github.com/chyyuu/os_kernel_lab/pull/22"><font color="#0000ff">两个问题</font></a>:</p><ul><li>生成的bootloader超过一个扇区，导致无法生成镜像</li><li>内核初始化在lgdt函数中无限循环</li></ul><p>原因是-fPIC在 GCC 的较新版本 (&gt;=7)中默认启用，会生成位置无关的代码，导致出错。</p><p><strong>解决方法是：修改每个Lab中的MakeFile，为两处CFLAG添加<code>-fno-PIC</code>选项</strong></p><p><img src="/2023/01/14/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/pic0.png" class=""></p>
          </div>
<h3 id="x00-环境准备">0X00 环境准备</h3>
<p>先把ucore的代码拉下来，装好对应的环境。这里要注意的，不带GUI的linux似乎是不可以的(得用X11转发，我觉得挺麻烦的，没弄)。我一开始打算直接vscode+remote
ssh来做，然后在make
debug的时候报错。猜测是使用QEMU硬件模拟器的问题。</p>
<p>ucore就是一个简单的操作系统，真实操作系统的部分它一个不少，但是它的目的是让我们学习操作系统的原理，所以它的代码量是很少的。同时呢，它也避开了各种先进CPU的奇奇怪怪的特性，针对的是i386这种比较简单的CPU。</p>
<p>但是很明显，我们很难找到一台i386的机器，所以我们需要一个模拟器来模拟这个CPU。这里我们使用的是QEMU，它是一个开源的模拟器，可以模拟很多CPU，包括i386。但是，QEMU是一个硬件模拟器，它模拟的是CPU、内存、硬盘、网卡等等，而不是一个操作系统。</p>
<p>因此，想要运行ucore这个操作系统，就只需要把它制作成一个镜像，然后使用QEMU来运行这个镜像就可以了。</p>
<h3 id="x01-ucore的镜像">0X01 ucore的镜像</h3>
<p>其实，ucore的镜像制作并不需要我们去实现，进入到lab1文件夹中，执行<code>make</code>就会在<code>./bin/</code>中编译出多个程序，其中就包括<code>ucore.img</code>这个镜像文件。我们主要就是来分析一下这个镜像文件是怎么做的，这也是lab1中练习1的内容。</p>
<p>其实只要执行<code>make V=</code>就能更清楚的看到编译的过程，这里就不贴出来了。</p>
<p>我画了一个流程图来表示生成过程</p>
<img src="/2023/01/14/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/pic1.jpg" class="">
<p>上图中的蓝色的表示为源文件，黄色的为最终<code>bin</code>目录中存在的文件。</p>
<p>制作一个镜像，首先需要编译出整个系统，因此需要把<code>kern/*</code>的文件全部编译出来，这个目录下的文件涉及到了操作系统的内核，包括进程管理、内存管理、中断处理、调试和驱动等等。<strong>其中中断处理用到的中断向量表是由<code>tools/vector.c</code>编译的程序动态生成的，因为中断向量表重复性很高。</strong>最终，就能得到一个操作系统的内核，也就是<code>bin/kernel</code>这个文件。</p>
<p>但是仅有一个操作系统内核文件是不够的。系统启动时，BIOS会调用bootloader来负责将内核加载到内存中，然后跳转到内核的入口地址执行。因此，我们还需要一个bootloader，目录<code>boot/</code>下的文件就是用于生成这个bootloader的。<strong>有一个硬性要求是这个bootloader程序被编译后的大小不能超过512-2个字节</strong>，其中512个字节是一个扇区的大小(也就是扇区0，主引导扇区)，剩下两个字节是一个符合规范的硬盘主引导扇区的固定标志位，还有一个要求是代码的起始段地址为0x7c00，这个要求在编译时就能满足。</p>
<p>由于主引导扇区存在上述限制，而我们直接编译出来的bootloader显然不一定符合，我们需要一个程序来检查这个bootloader大小是否满足要求，同时再将固定位置的两个字节填上。这个程序就是<code>tools/sign.c</code>编译得到的。</p>
<p>但是们编译的可执行文件是ELF格式，存在各个段，这些段会显著增加大小，而且我们实际上也用不到这些段，所以要去掉这些段，去除的指令为<code>objcopy -S -O binary obj/bootblock.o obj/bootblock.out</code>。我们来看一下去除前后文件大小的比对</p>
<img src="/2023/01/14/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/pic2.jpg" class="">
<p>显然，去除前足足由4.1Kb，远远超过了限制。在去除之后就小于512B了，可以放到一个扇区内了。</p>
<p>再使用sign处理之后，就得到了一个<strong>512B的符合规范的主引导扇区了</strong>，这个二进制文件就是<code>bin/bootblock</code>。</p>
<p>现在我们得到了存有bootloader的<code>bootblock</code>，同时也得到了一个操作系统内核<code>kernel</code>，然后就可以开始正式组装镜像了。首先使用<code>dd</code>命令创建一个含有1000个块的文件，每个块大小512字节。然后把<code>bootblock</code>放到第一块里面，从第二个块开始，放入<code>kernel</code>。最后就得到了需要的镜像<code>ucore.img</code>了。</p>
<h3 id="x02-ucore的引导">0X02 ucore的引导</h3>
<p>接下来，我们使用QEMU来模拟一个硬件，并在模拟的硬件平台上使用镜像来运行操作系统，同时通过GDB来监测运行情况。</p>
<p>首先先改写MakeFile，让QEMU将运行的汇编指令保存</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">debug: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(TERMINAL)</span> -e <span class="string">"<span class="variable">$(QEMU)</span> -S -s -d in_asm -D <span class="variable">$(BINDIR)</span>/q.log -parallel stdio -hda <span class="variable">$&lt;</span> -serial null"</span></span><br><span class="line">	<span class="variable">$(V)</span>sleep 2</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(TERMINAL)</span> -e <span class="string">"gdb -q -tui -x tools/gdbinit"</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改<code>tools/gdbinit</code>如下，使得GDB进去后立马进入调试，不需要其默认运行到0x7c00，我们从上电后的代码开始看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">target remote :1234</span><br><span class="line">set architecture i8086</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后执行<code>make debug</code>来进行调试</p>
<p>执行<code>b *0x7c00</code>来设置一个断点，然后执行<code>c</code>来继续执行到断点，执行<code>layout asm</code>来显示汇编，再执行若干条代码后退出即可。</p>
<p>我们来看一下记录的汇编指令</p>
<img src="/2023/01/14/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/pic3.png" class="">
<p>可以看到，<strong>CPU上电后，指令指针寄存器的值为0xffff
fff0</strong>，且对应位置是一条长跳转指令。然后剩下的这些代码是BIOS，负责检查硬件、初始化一类的，在我们的模拟中占据了绝大篇幅，我们不必细究，<strong>只需要知道BIOS在执行完后会固定跳转到0x7c00处</strong>，这个位置就是我们的bootloader。</p>
<img src="/2023/01/14/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/pic4.png" class="">
<p>我们可以对比一下日志中记录的0x7c00处的汇编和<code>boot/asm.s</code>文件中的代码段，两者其实是一样的，这更加说明了0x7c00处的代码就是我们的bootloader。</p>
<div class="note info">
            <p>在调试过程中，可以执行<code>layout asm</code>来显示汇编。但是可以发现BIOS部分的日志中执行的汇编和GDB调试的时候显示的汇编是对不上的。</p><p>这是因为BIOS首先运行在16位实模式下，而gdb默认是32bit线性地址模式，调试BIOS的16bit代码（段地址）需要手动计算地址，计算公式如下：</p><p><strong>Linear Addr = ( cs &lt;&lt; 4 ) + ip</strong></p><p>如果 CS=0x0000，EIP=0xffff，则 Linear Address=0xffff0</p><p>可以使用<code>info register</code>查看寄存器</p><p>另外，为了正确反汇编16bit指令，可能需要在GDB中执行一下<code>set architecture i8086</code></p>
          </div>
<p>下面给出CPU上电后对镜像的引导过程：</p>
<ul>
<li>首先，CPU上电后处于<strong>实模式</strong>下，也就是直接引用物理内存，执行的第一条指令位置为0xFFFFFFF0，是一条长跳转指令，会继续执行BIOS中的代码</li>
<li>BIOS会做相当长的自检之类的功能，最后会跳转到0x7c00处，这个位置就是我们的bootloader，也就是<strong>主引导扇区的代码</strong></li>
<li>bootloader会进入到<strong>保护模式</strong>(下面会分析源码)，然后加载内核镜像到内存中，然后跳转到内核镜像的入口处，开始执行内核代码</li>
</ul>
<div class="note info">
            <p>实模式就是采用CS:IP这样寻址，寻得是物理地址，共20位(就是8086那种寻址)</p><p>保护模式是使用GDT表，寻得是32位地址，可以寻址4G内存(本质上也是寻物理地址)</p><p><strong>保护二字体现在CPU会在硬件上自动根据GDT、段选择子等信息，来判断访问的内存是否存在、是否合法</strong></p>
          </div>
<h3 id="x03-bootloader的工作">0X03 Bootloader的工作</h3>
<p>因此，系统加载的关键就是这个512字节的Bootloader，它从BIOS手上接下控制权，并转入保护模式运行；它将内核加载到内存中，并将控制权交给内核。这个过程我们称之为<strong>引导</strong>。</p>
<p>我们的Bootloader主要就是<code>boot/bootasm.s</code>和<code>boot/bootmain.c</code>两个文件，下面我们来分析一下这两个文件。首先，先概述一下这两个文件的功能：</p>
<ul>
<li>boot/bootasm.s 是汇编代码，主要是切换到保护模式</li>
<li>boot/bootmain.c
是C代码，主要是加载内核镜像到内存中，负责解析ELF格式的内核镜像</li>
</ul>
<div class="note primary">
            <p><strong>A20开关</strong></p><p>地址线的第21位，也就是A20比较特殊。因为早期的8086只有20根地址线，寻址1Mb空间(也就是CS:IP，只有IP时只能寻址64k)。</p><p>后续的CPU，比如80396，有32根地址线，可以寻址4G空间。但是为了兼容早期的CPU，所以在80386中，<strong>引入了A20地址线，用来控制是否开启高位地址</strong>。</p><p>更具体的说，<strong>A20只是一个开关，当它打开的时候，A20线既可以为0，也可以为1，也就是正常工作；而当它关闭时，A20线只能为0</strong>。</p><p>所以，为了能让地址线全部正常工作，需要打开A20这个开关</p><p>但是由于历史原因，A20地址位由键盘控制器芯片8042管理。所以要给8042发命令激活A20。</p><p>给8042发命令时，先发送要写哪里，再发送要写什么。所以要两次写入，同时为了避免总线冲突，所以需要在汇编中存在一些循环重复测试</p>
          </div>
<div class="note info">
            <p><strong>保护模式与A20</strong></p><p>CR0是控制寄存器，其中包含了6个预定义标志，0位是保护允许位PE(ProtedtedEnable)，用于启动保护模式。如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。</p><p>也就是说，<strong>保护模式和A20开关没有必然的关系</strong>，即使不打开A20开关也是可以开启保护模式的，只是此时无法寻址一部分空间而已。</p><p>打开A20开关只是为了在保护模式时能够"满血"寻址所有的地址位。</p>
          </div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># boot/bootasm.s</span><br><span class="line"></span><br><span class="line">#include &lt;asm.h&gt;</span><br><span class="line"></span><br><span class="line">#Start the CPU : switch to 32 - bit protected mode, jump into C.</span><br><span class="line">#The BIOS loads this code from the first sector of the hard disk into</span><br><span class="line">#memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="line">#with % cs = 0 % ip = 7c00.</span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector</span><br><span class="line">.set CR0_PE_ON,             0x1                     # protected mode enable flag</span><br><span class="line"></span><br><span class="line">#start address should be 0 : 7c00, in real mode, the beginning address of the running bootloader</span><br><span class="line">.globl start</span><br><span class="line"></span><br><span class="line">########################## 从这里开始 ##########################</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">.code16                                             # Assemble for 16-bit mode</span><br><span class="line">    # 关闭中断</span><br><span class="line">    cli                                             # Disable interrupts</span><br><span class="line">    cld                                             # String operations increment</span><br><span class="line"></span><br><span class="line">#Set up the important data segment registers(DS, ES, SS).</span><br><span class="line">    # 将flag置0和将段寄存器置0</span><br><span class="line">    xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">#Enable A20:</span><br><span class="line">#For backwards compatibility with the earliest PCs, physical</span><br><span class="line">#address line 20 is tied low, so that addresses higher than</span><br><span class="line"># 1MB wrap around to zero by default.This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line">    # 先等待8042键盘控制器不忙</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    # 发送写8042输出端口的指令</span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    # 这里的意思是下面写8042的P2端口</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    # 等待8042键盘控制器不忙</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    # 打开A20</span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    # 这里的意思是传入8042的P2端口的具体数值，其实也就是把A20打开了</span><br><span class="line">    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1</span><br><span class="line"></span><br><span class="line">#Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">#and segment translation that makes virtual addresses</span><br><span class="line">#identical to physical addresses, so that the</span><br><span class="line">#effective memory map does not change during the switch.</span><br><span class="line">    # 初始化GDT表：一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可</span><br><span class="line">    lgdt gdtdesc</span><br><span class="line">    # 这里开启保护模式，先把cr0存入eax中，然后把eax的第0位置1，然后再把eax存入cr0中</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line">    # 至此，开启了保护模式</span><br><span class="line"></span><br><span class="line">#Jump to next instruction, but in 32 - bit code segment.</span><br><span class="line">#Switches processor into 32 - bit mode.</span><br><span class="line">    # 通过长跳转更新cs的基地址，这样就可以进入32位模式了</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line"></span><br><span class="line">.code32                                             # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">#Set up the protected - mode data segment registers</span><br><span class="line">    # 设置段寄存器，并建立堆栈</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">#Set up the stack pointer and call into C.The stack region is from 0 --start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    # 转到保护模式完成，进入bootmain中</span><br><span class="line">    call bootmain</span><br><span class="line"></span><br><span class="line">#If bootmain returns(it shouldn't), loop.</span><br><span class="line"># 如果bootmain返回了，就表示存在错误，就进入到一个死循环中</span><br><span class="line">spin:</span><br><span class="line">    jmp spin</span><br><span class="line"></span><br><span class="line">#Bootstrap GDT</span><br><span class="line"># GDT表</span><br><span class="line">.p2align 2                                          # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     # null seg</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word 0x17                                      # sizeof(gdt) - 1</span><br><span class="line">    .long gdt                                       # address gdt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// boot/bootmain.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;elf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *********************************************************************</span></span><br><span class="line"><span class="comment"> * This a dirt simple boot loader, whose sole job is to boot</span></span><br><span class="line"><span class="comment"> * an ELF kernel image from the first IDE hard disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DISK LAYOUT</span></span><br><span class="line"><span class="comment"> *  * This program(bootasm.S and bootmain.c) is the bootloader.</span></span><br><span class="line"><span class="comment"> *    It should be stored in the first sector of the disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The 2nd sector onward holds the kernel image.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The kernel image must be in ELF format.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BOOT UP STEPS</span></span><br><span class="line"><span class="comment"> *  * when the CPU boots it loads the BIOS into memory and executes it</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * the BIOS intializes devices, sets of the interrupt routines, and</span></span><br><span class="line"><span class="comment"> *    reads the first sector of the boot device(e.g., hard-drive)</span></span><br><span class="line"><span class="comment"> *    into memory and jumps to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * Assuming this boot loader is stored in the first sector of the</span></span><br><span class="line"><span class="comment"> *    hard-drive, this code takes over...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * control starts in bootasm.S -- which sets up protected mode,</span></span><br><span class="line"><span class="comment"> *    and a stack so C code then run, then calls bootmain()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SECTSIZE = <span class="number">512</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">ELFHDR</span> =</span> ((<span class="keyword">struct</span> elfhdr *)<span class="number">0x10000</span>); <span class="comment">// scratch space</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* waitdisk - wait for disk ready */</span></span><br><span class="line"><span class="comment">// 自旋，直到磁盘就绪</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">waitdisk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* readsect - read a single sector at @secno into @dst */</span></span><br><span class="line"><span class="comment">// 读取扇区secno到dst处</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">readsect</span><span class="params">(<span class="type">void</span> *dst, <span class="type">uint32_t</span> secno)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    <span class="comment">// 等待磁盘就绪</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些硬编码，用于读取扇区，控制磁盘驱动器的一些代码</span></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>); <span class="comment">// count = 1</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>); <span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    <span class="comment">// 读取到dst位置</span></span><br><span class="line">    <span class="comment">// 作用为从0x1F0 IO端口读取SECTSIZE / 4个双字 (4Byte)大小的数据到基址为dst的内存中</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * readseg - read @count bytes at @offset from kernel into virtual address @va,</span></span><br><span class="line"><span class="comment"> * might copy more than asked.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="comment">// 从偏移offset处读取count字节，加载到虚拟内存va处</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">readseg</span><span class="params">(<span class="type">uintptr_t</span> va, <span class="type">uint32_t</span> count, <span class="type">uint32_t</span> offset)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 结束时的虚拟地址</span></span><br><span class="line">    <span class="type">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary</span></span><br><span class="line">    <span class="comment">// 从偏移offset处开始读取，向下取整到扇区边界</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    <span class="comment">// 计算读取的开始时的扇区号</span></span><br><span class="line">    <span class="type">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="comment">// 调用readsect不断读取</span></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno++)</span><br><span class="line">    {</span><br><span class="line">        readsect((<span class="type">void</span> *)va, secno);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bootmain - the entry of bootloader */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// read the 1st page off disk</span></span><br><span class="line">    <span class="comment">// 读取ELF格式文件的第一个块</span></span><br><span class="line">    readseg((<span class="type">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is this a valid ELF?</span></span><br><span class="line">    <span class="comment">// 通过魔数来判断是否是ELF格式</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">    <span class="comment">// ELF头部有描述ELF文件应加载到内存什么位置的描述表，</span></span><br><span class="line">    <span class="comment">// 先将描述表的头地址存在ph中，然后将描述表的尾地址存在eph中，</span></span><br><span class="line">    ph = (<span class="keyword">struct</span> proghdr *)((<span class="type">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="comment">// 按照描述表将ELF文件中数据载入内存</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    {</span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">    <span class="comment">// note: does not return</span></span><br><span class="line">    <span class="comment">// 根据ELF头部储存的入口信息，找到内核的入口</span></span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，两个文件做的事情都相当简单，无非就是打开保护，解析内核的ELF文件并进入内核。</p>
<h3 id="x04-内核调试之函数调用堆栈跟踪函数">0X04
内核调试之函数调用堆栈跟踪函数</h3>
<p>这个其实是lab1的练习5，就是实现一下<code>kern/debug/kdebug.c</code>中的<code>print_stackframe</code>函数，这个函数的作用是打印函数调用堆栈的信息，包括函数名，函数参数，函数返回地址等等。</p>
<p>在实现之前，文档还贴心的介绍了一下CPU相关的寄存器：</p>
<ul>
<li>esp 栈指针寄存器(extended stack
pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</li>
<li>ebp 基址指针寄存器(extended base
pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</li>
<li>eip 指令指针寄存器(extended instruction
pointer)，永远指向当前执行的指令的内存地址。</li>
</ul>
<img src="/2023/01/14/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/pic5.png" class="">
<p>ebp指向的堆栈位置储存着caller的ebp，以此为线索可以得到所有使用堆栈的函数ebp。而ebp+4指向的是调用时的eip，也就是返回地址。ebp+8、+12这些则是可能的参数。</p>
<p><strong>虽然它要求编程，但是lab中的文件不是已经编好了嘛...所以就分析一下叭。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_stackframe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">    <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">     * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">     * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">     *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">     *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">     *    (3.3) cprintf("\n");</span></span><br><span class="line"><span class="comment">     *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">     *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">     *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">     *                   the calling funciton's ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 先读取ebp和eip的值，分别是栈底和当前指令地址</span></span><br><span class="line">    <span class="type">uint32_t</span> ebp = read_ebp();</span><br><span class="line">    <span class="type">uint32_t</span> eip = read_eip();</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="comment">// 没有超过最大调用深度或者是ebp不为0的时候，就一直循环</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; STACKFRAME_DEPTH &amp;&amp; ebp != <span class="number">0</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 16进制输出ebp和eip的值</span></span><br><span class="line">        cprintf(<span class="string">"ebp:0x%08x eip:0x%08x"</span>, ebp, eip);</span><br><span class="line">        <span class="comment">// 读取ebp+2(32位数据的+2，对应了字节+8)的值，也就是第一个参数的值</span></span><br><span class="line">        <span class="type">uint32_t</span> *arg = (<span class="type">uint32_t</span> *)ebp + <span class="number">2</span>;</span><br><span class="line">        cprintf(<span class="string">" arg:"</span>);</span><br><span class="line">        <span class="comment">// 从ebp+8开始，输出4个参数的值</span></span><br><span class="line">        <span class="comment">// 注意小端存储哦</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        {</span><br><span class="line">            cprintf(<span class="string">"0x%08x "</span>, arg[j]);</span><br><span class="line">        }</span><br><span class="line">        cprintf(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="comment">// 打印调用函数的行数和函数名</span></span><br><span class="line">        print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 重复获取上一次的ebp和eip</span></span><br><span class="line">        eip = ((<span class="type">uint32_t</span> *)ebp)[<span class="number">1</span>];</span><br><span class="line">        ebp = ((<span class="type">uint32_t</span> *)ebp)[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是我的一次调用结果</p>
<img src="/2023/01/14/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/pic6.png" class="">
<p>下面解释一下最后一行</p>
<p>此时ebp的值是kern_init函数的栈顶地址，从前面练习我们知道，整个栈的栈顶地址为0x00007c00，ebp指向的栈位置存放调用者的ebp寄存器的值，ebp+4指向的栈位置存放返回地址的值，这意味着kern_init函数的调用者（也就是bootmain函数）没有传递任何输入参数给它！因为单是存放旧的ebp、返回地址已经占用8字节了。</p>
<p>eip的值是kern_init函数的返回地址，也就是bootmain函数调用kern_init对应的指令的下一条指令的地址，反汇编bootmain函数证实了这个判断。</p>
<img src="/2023/01/14/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/pic7.png" class="">
<p>args:0xc031fcfa 0xc08ed88e 0x64e4d08e
0xfa7502a8：一般来说，args存放的4个元素是对应4个输入参数的值。但这里比较特殊，由于bootmain函数调用kern_init并没传递任何输入参数，并且栈顶的位置恰好在bootloader第一条指令存放的地址的上面，而args恰好是kern_int的ebp寄存器指向的栈顶往上第2~5个单元，因此args存放的就是bootloader指令的前16个字节。</p>
<p>(需要注意下图中的数据都是小端存储的，因此每个字节需要反过来看)<br>
<img src="/2023/01/14/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/pic8.png" class=""></p>
<h3 id="x05-内核调试之中断初始化和处理">0X05
内核调试之中断初始化和处理</h3>
<p>众所周知，中断信号发生后，需要传递中断号，然后内核根据中断号来在中断向量表中查找的对应的中断处理函数，然后执行中断处理函数。</p>
<div class="note info">
            <p><strong>BIOS中断、DOS中断、Linux中断的区别</strong></p><ul><li>BIOS和DOS都存在于<strong>实模式</strong>下，由它们建立的中断调用都是建立在中断向量表（InterruptVector Table，IVT）中的，都是通过软中断指令 int 中断号来调用。</li><li>BIOS中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。</li><li>DOS是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和BIOS的不能冲突。</li><li>Linux内核是在进入<strong>保护模式</strong>后才建立中断例程的，<strong>不过在保护模式下，中断向量表已经不存在了</strong>，取而代之的是<strong>中断描述符表</strong>（InterruptDescriptor Table，IDT）。Linux的系统调用和DOS中断调用类似，不过Linux是通过int0x80指令进入一个中断程序后再根据eax寄存器的值来调用不同的子功能函数的。</li></ul>
          </div>
<p>而中断向量表是在内核初始化的时候建立的。在ucore中，对于中断描述符表IDT的初始化，是在kern_init总控函数中通过idt_init函数进行的。</p>
<div class="note primary">
            <p>中断描述符IDT表示一个系统表，它与中断或异常向量相联系。每一个中断或异常向量在这个系统表中有对应的中断或异常处理程序入口地址。中断描述符的表每一项对应一个中断或异常向量，每个向量由8个字节组成。因此，最多需要256*8=2048字节来存放IDT。</p>
          </div>
<p>当中断发生时，cpu会得到一个中断向量号，作为IDT（中断描述符表）的索引，IDT表起始地址由IDTR寄存器存储，cpu会从IDT表中找到该中断向量号相应的中断服务程序入口地址，跳转到中断处理程序处执行，并保存当前现场；当中断程序执行完毕，恢复现场，跳转到原中断点处继续执行。而IDT的表项为中断描述符，主要类型有<strong>中断门、陷阱门、任务门</strong>。</p>
<img src="/2023/01/14/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/pic9.png" class="">
<div class="note info">
            <p>中断门：包含段选择符和中断或异常处理程序的段内偏移量，当控制权转移到一个适当的段时，处理器清IF标志，从而关闭将来会发生的可屏蔽中断</p><p>陷阱门：陷阱门是一种特殊的中断门，与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志</p><p>任务门：当中断信号发生时，必须取代当前进程的那个进程的TSS选择符存放在任务门中。</p><p><em>以上内容来自百度</em></p>
          </div>
<p>这些门的描述符格式比较固定，在<code>kern/mm/mmh.c</code>中有一些宏可以直接设置：</p>
<ul>
<li>SETGATE(gate, istrap, sel, off, dpl) : 设置中断、陷阱门描述符</li>
<li>SETCALLGATE(gate, ss, off, dpl) : 设置任务门描述符</li>
</ul>
<p>而且内核所有需要用到的中断函数都被<code>tools/vector.c</code>程序动态生成了，所以只需要把这些写入到IDT表中就可以了。</p>
<p>我们先来看一下生成的<code>kern/trap/vector.s</code>中断表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl __alltraps</span><br><span class="line">.globl vector0</span><br><span class="line">vector0:</span><br><span class="line">  pushl $0</span><br><span class="line">  pushl $0</span><br><span class="line">  jmp __alltraps</span><br><span class="line"></span><br><span class="line">...省略一部分</span><br><span class="line"></span><br><span class="line">vector255:</span><br><span class="line">  pushl $0</span><br><span class="line">  pushl $255</span><br><span class="line">  jmp __alltraps</span><br><span class="line"></span><br><span class="line"># vector table</span><br><span class="line">.data</span><br><span class="line">.globl __vectors</span><br><span class="line">__vectors:</span><br><span class="line">  .long vector0</span><br><span class="line">  .long vector1</span><br><span class="line"></span><br><span class="line">...剩下的省略</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，前面是中断号对应的处理程序，后面是一个__vectors数组，数组中给出了对应中断号的中断处理程序的位置。而中断处理程序只是把中断号压栈，然后跳转到<code>__alltraps</code>函数，这个函数在<code>kern/trap/trapentry.S</code>中定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;memlayout.h&gt;</span><br><span class="line"></span><br><span class="line"># vectors.S sends all traps here.</span><br><span class="line">.text</span><br><span class="line">.globl __alltraps</span><br><span class="line">__alltraps:</span><br><span class="line">    # push registers to build a trap frame</span><br><span class="line">    # therefore make the stack look like a struct trapframe</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushl %fs</span><br><span class="line">    pushl %gs</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    # load GD_KDATA into %ds and %es to set up data segments for kernel</span><br><span class="line">    movl $GD_KDATA, %eax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line"></span><br><span class="line">    # push %esp to pass a pointer to the trapframe as an argument to trap()</span><br><span class="line">    pushl %esp</span><br><span class="line"></span><br><span class="line">    # call trap(tf), where tf=%esp</span><br><span class="line">    # 调用trap函数</span><br><span class="line">    call trap</span><br><span class="line"></span><br><span class="line">    # pop the pushed stack pointer</span><br><span class="line">    popl %esp</span><br><span class="line"></span><br><span class="line">    # return falls through to trapret...</span><br><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs and %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    iret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，这个函数就是构造一个trapframe结构体，然后调用trap函数，trap函数在<code>kern/trap/trap.c</code>中定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// dispatch based on what type of trap occurred</span></span><br><span class="line">    trap_dispatch(tf);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>显然，<strong>ucore的所有中断都会由trap_dispatch进行实际上的处理</strong>，这个函数在<code>kern/trap/trap.c</code>中定义。如果我们需要修改对某个中断的处理函数，实际上也只需要在trap_dispatch函数中进行修改即可。</p>
<img src="/2023/01/14/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/pic10.png" class="">
<h3 id="x06-通过中断进行权限切换">0x06 通过中断进行权限切换</h3>
<p>这个实验是一个challenge的实验，就是完成通过中断从用户态(ring
3)切换到内核态(ring
0)的功能。需要先把<code>kern/init:kern_init()</code>中的<code>switch_test()</code>解注释，然后完成<code>kern/init:lab1_switch_to_user()</code>和<code>kern/init:lab1_switch_to_kernel()</code>这两个函数。</p>
<div class="note info">
            <p><strong>CPL、DPL、RPL与IOPL</strong></p><p>DPL存储于段描述符中，<strong>规定访问该段的权限级别</strong>(DescriptorPrivilege Level)，每个段的DPL固定。<br>当进程访问一个段时，需要进程特权级检查。</p><p>CPL存在于CS寄存器的低两位，即CPL是CS段描述符的DPL，<strong>是当前代码的权限级别</strong>(CurrentPrivilege Level)。</p><p>RPL存在于段选择子中，<strong>说明的是进程对段访问的请求权限</strong>(RequestPrivilegeLevel)，是对于段选择子而言的，每个段选择子有自己的RPL。而且RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样它对该段仍然只有特权为3的访问权限。</p><p>IOPL(I/O PrivilegeLevel)即I/O特权标志，位于eflag寄存器中，用两位二进制位来表示，也称为I/O特权级字段。<strong>该字段指定了要求执行I/O指令的特权级</strong>。如果当前的特权级别在数值上小于等于IOPL的值，那么，该I/O指令可执行，否则将发生一个保护异常。</p><p><strong>只有当CPL=0时，可以改变IOPL的值，当CPL&lt;=IOPL时，可以改变IF标志位。</strong></p>
          </div>
<div class="note primary">
            <p><strong>特权级检查</strong></p><p>在下述的特权级比较中，需要注意特权级越低，其ring值越大。</p><p>访问门时（中断、陷入、异常），要求DPL[目标代码段] &lt;= CPL &lt;=DPL[门]</p><p><strong>访问门的代码权限比门的特权级要高，因为这样才能访问门。</strong></p><p><strong>但访问门的代码权限比被访问的段的权限要低，因为通过门的目的是访问特权级更高的段，这样就可以达到低权限应用程序使用高权限内核服务的目的。</strong></p><p>访问段时，要求DPL[段] &gt;= max {CPL, RPL}</p><p><strong>只能使用CPL, RPL中最低的权限来访问段数据</strong></p>
          </div>
<p>在之前提到的中断描述符中，有一个DPL位，表示门权限，或者说，只有不低于门的权限的代码才能通过门。要实现从r3到r0的提权，需要先保证有一个中断门在r3就能执行，且该中断门的目标代码段在r0，这样就实现了提权。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kern/trap/trap.c</span></span><br><span class="line"><span class="comment">// 先设置一个提权用的中断门</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uintptr_t</span> __vectors[];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="number">256</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 这里设置一个提权用的门</span></span><br><span class="line">    SETGATE(idt[T_SWITCH_TOK], <span class="number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外还需要一个TSS(Task State Segment)
，<strong>它是操作系统在进行进程切换时保存进程现场信息的段，CPU能够理解TSS段，是硬件结构，需要用软件来初始化</strong>，负责保留ring0、ring1、ring2的栈(ss、esp寄存器值)。当用户程序从ring3跳至ring0时(例如执行中断)，此时的栈就会从用户栈切换到内核栈。切换栈的操作从开始中断的那一瞬间（例如：从int
0x78到中断处理例程之间）就已完成。<strong>切换栈的操作为修改esp和ss寄存器。CPU会自动从TSS读取并修改</strong>而同时TSS段的段描述符保存在GDT中，其ring0的栈会在初始化GDT时被一起设置。<strong>TR寄存器会保存当前TSS的段描述符</strong>，以提高索引速度。</p>
<p>那么切换栈是由谁来完成的呢？这个程序我们之前也见过，只是没有具体分析代码含义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># kern/trap/trapentry.s</span><br><span class="line"></span><br><span class="line">#include &lt;memlayout.h&gt;</span><br><span class="line"></span><br><span class="line"># vectors.S sends all traps here.</span><br><span class="line">.text</span><br><span class="line">.globl __alltraps</span><br><span class="line">__alltraps:</span><br><span class="line">    # push registers to build a trap frame</span><br><span class="line">    # therefore make the stack look like a struct trapframe</span><br><span class="line">    # 保护现场</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushl %fs</span><br><span class="line">    pushl %gs</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    # load GD_KDATA into %ds and %es to set up data segments for kernel</span><br><span class="line">    # 内核区的数据段</span><br><span class="line">    movl $GD_KDATA, %eax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line"></span><br><span class="line">    # push %esp to pass a pointer to the trapframe as an argument to trap()</span><br><span class="line">    # 放入trapframe的地址，调用trap函数来处理中断</span><br><span class="line">    pushl %esp</span><br><span class="line"></span><br><span class="line">    # call trap(tf), where tf=%esp</span><br><span class="line">    call trap</span><br><span class="line"></span><br><span class="line">    # pop the pushed stack pointer</span><br><span class="line">    popl %esp</span><br><span class="line"></span><br><span class="line">    # return falls through to trapret...</span><br><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs and %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    iret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p><strong>优先级切换中堆栈处理步骤</strong>：</p><ol type="1"><li>准备调用门</li><li>加载TSS，因为总共有4个优先级（ring0~3),所以每个优先级下面都对应一个堆栈。加载了TSS,就能够根据目标优先级而从TSS中获取想对应的堆栈地址</li><li>临时性保存当前，未切换前的SS_old和ESP_old的值</li><li>根据目标优先级从TSS中获取对应的对应得堆栈地址SS_new和ESP_new，并加载。（因为CPU只有一个SS和一个ESP寄存器，所以，所谓的加载，只是把新的SS_new和ESP_new的地址赋给CPU的SS和ESP寄存器）</li><li>将已经临时保存的SS_old和ESP_old的值保存到新堆栈中</li><li>将当前的CS_old和EIP_old保存入新堆栈</li><li>加载调用门中指定的新的CS和EIP,开始执行被调用者过程</li></ol><p><strong>优先级切换返回过程堆栈处理步骤：</strong></p><ol type="1"><li>加载被调用者堆栈上的CS_old和EIP_old</li><li>加载SS_old和ESP_old，切换到调用者堆栈，被调用者的SS_new和ESP_new被丢弃</li></ol>
          </div>
<p><strong>特权级的转变，就是改段寄存器的selecter，还有进行堆栈的变化。CPU认为只有之前发生特权级变化时才会额外压入ss、esp，所以中断返回时如果发现弹出的cs与当前cs不一致时，除了恢复之前栈上的cs(也恢复了CPL)，同时会额外的弹出esp、ss。通过这个机制我们也能欺骗机器进行堆栈的转换</strong></p>
<p>当通过陷入门从ring3切换至ring0（特权提升）时：</p>
<ul>
<li>在陷入的一瞬间，CPU会因为特权级的改变，索引TSS，切换ss和esp为内核栈，并按顺序自动压入user_ss、user_esp、user_eflags、user_cs、old_eip以及err。(需要注意的是，CPU先切换到内核栈，此时的esp与ss不再指向用户栈。但此时CPU却可以再将用户栈地址存入内核栈。这种操作可能是依赖硬件来完成的。)</li>
<li>之后CPU会在中断处理例程入口处，先将剩余的段寄存器以及所有的通用寄存器压栈，构成一个trapframe。然后将该trapframe传入给真正的中断处理例程并执行</li>
<li>该处理例程会判断传入的中断数(trapno)并执行特定的代码。在提升特权级的代码中，程序会处理传入的trapframe信息中的CS、DS、eflags寄存器，修改上面的DPL、CPL与IOPL以达到提升特权的目的</li>
<li>将修改后的trapframe压入用户栈（这一步没有修改user_esp寄存器），并设置中断处理例程结束后将要弹出esp寄存器的值为用户栈的新地址（<strong>与刚刚不同，这一步修改了将要恢复的user_esp寄存器</strong>）。（这样在退出中断处理程序，准备恢复上下文的时候，首先弹出的栈寄存器值是修改后的用户栈地址，其次弹出的通用寄存器、段寄存器等等都是存储于用户栈中的trapframe。）</li>
</ul>
<p>通过陷入门从ring0切换至ring3（特权降低）
的过程与特权提升的操作基本一样，不过有几个不同点需要注意一下：</p>
<ul>
<li>与ring3调用中断不同，当ring0调用中断时，进入中断前和进入中断后的这个过程，栈不发生改变</li>
<li>因为在调用中断前的权限已经处于ring0了，而中断处理程序里的权限也是ring0，所以这一步陷入操作的特权级没有发生改变，故不需要访问TSS并重新设置ss
、esp寄存器。</li>
<li>修改后的trapFrame不需要像上面那样保存至将要使用的栈，因为当前环境下iret前后特权级会发生改变，执行该命令会弹出ss和esp，所以可以通过iret来设置返回时的栈地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// kern/init/init.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lab1_switch_to_user</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="comment">//LAB1 CHALLENGE 1 : TODO</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">	    <span class="string">"sub $0x8, %%esp \n"</span></span></span><br><span class="line"><span class="params">	    <span class="string">"int %0 \n"</span></span></span><br><span class="line"><span class="params">	    <span class="string">"movl %%ebp, %%esp"</span></span></span><br><span class="line"><span class="params">	    : </span></span><br><span class="line"><span class="params">	    : <span class="string">"i"</span>(T_SWITCH_TOU)</span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lab1_switch_to_kernel</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="comment">//LAB1 CHALLENGE 1 :  TODO</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">	    <span class="string">"int %0 \n"</span></span></span><br><span class="line"><span class="params">	    <span class="string">"movl %%ebp, %%esp \n"</span></span></span><br><span class="line"><span class="params">	    : </span></span><br><span class="line"><span class="params">	    : <span class="string">"i"</span>(T_SWITCH_TOK)</span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/trap/trap.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">switchk2u</span>, *<span class="title">switchu2k</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOU:</span><br><span class="line">        <span class="keyword">if</span> (tf-&gt;tf_cs != USER_CS) {</span><br><span class="line">            switchk2u = *tf;</span><br><span class="line">            switchk2u.tf_cs = USER_CS;</span><br><span class="line">            switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;</span><br><span class="line">            switchk2u.tf_esp = (<span class="type">uint32_t</span>)tf + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe) - <span class="number">8</span>;</span><br><span class="line">		</span><br><span class="line">            <span class="comment">// set eflags, make sure ucore can use io under user mode.</span></span><br><span class="line">            <span class="comment">// if CPL &gt; IOPL, then cpu will generate a general protection.</span></span><br><span class="line">            switchk2u.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">		</span><br><span class="line">            <span class="comment">// set temporary stack</span></span><br><span class="line">            <span class="comment">// then iret will jump to the right stack</span></span><br><span class="line">            *((<span class="type">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="type">uint32_t</span>)&amp;switchk2u;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">        <span class="keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) {</span><br><span class="line">            tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">            tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">            tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">            switchu2k = (<span class="keyword">struct</span> trapframe *)(tf-&gt;tf_esp - (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe) - <span class="number">8</span>));</span><br><span class="line">            memmove(switchu2k, tf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe) - <span class="number">8</span>);</span><br><span class="line">            *((<span class="type">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="type">uint32_t</span>)switchu2k;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="x07-总结">0X07 总结</h3>
<p>通过这个lab1，我们学习了以下内容:</p>
<ul>
<li>操作系统的镜像是如何制作的：第一个扇区是什么、剩下的扇区是什么、bootloader去段的处理、bootloader的大小限制</li>
<li>操作系统是如何启动的：BIOS什么模式、BIOS结束时如何进入bootloader、bootloader两个功能(保护模式、ELF)、bootloader如何进入内核</li>
<li>内核的中断、中断描述符、各种门、在ucore中断函数的实现方法</li>
<li>段和门权限的表示方法，通过中断提权</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>ucore操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>从ucore来总结操作系统(8)----文件系统</title>
    <url>/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/</url>
    <content><![CDATA[<h2 id="文件系统">文件系统</h2>
<span id="more"></span>
<div class="note warning">
            <p>关于ucore的文件系统，可以参考<a href="https://nankai.gitbook.io/ucore-os-on-risc-v64/lab8/wen-jian-xi-tong-jie-shao"><font color="#0x0000ff">ucore的risc-v的实验指导书</font></a>，写的很有逻辑且详细</p>
          </div>
<h3 id="x00-环境准备">0X00 环境准备</h3>
<p>本lab基于前所有lab，但是需要对其进行一些扩展：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct *<span class="title function_">alloc_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 初始化 PCB 下的 fs(进程相关的文件信息)</span></span><br><span class="line">    proc-&gt;filesp = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_fork</span><span class="params">(<span class="type">uint32_t</span> clone_flags, <span class="type">uintptr_t</span> <span class="built_in">stack</span>, <span class="keyword">struct</span> trapframe *tf)</span> </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 使用 copy_files()函数复制父进程的fs到子进程中</span></span><br><span class="line">    <span class="keyword">if</span> (copy_files(clone_flags, proc) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为proc_struct新增了一个文件相关的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">filesp</span>;</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 当前工作目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// inode of present working directory</span></span><br><span class="line">    <span class="comment">// 文件描述符(数组)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// opened files array</span></span><br><span class="line">    <span class="comment">// 打开的文件数目</span></span><br><span class="line">    <span class="type">int</span> files_count;        <span class="comment">// the number of opened files</span></span><br><span class="line">    <span class="comment">// 用于文件加锁的信号量</span></span><br><span class="line">    <span class="type">semaphore_t</span> files_sem;  <span class="comment">// lock protect sem</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于文件系统比较复杂，我们还是先来通过<strong>实验指导书</strong>来宏观对ucore的文件系统做初步了解。</p>
<h4 id="总体介绍">总体介绍</h4>
<p>ucore的文件系统架构主要由四部分组成：</p>
<ul>
<li><strong>通用文件系统访问接口层</strong>：该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。</li>
<li><strong>文件系统抽象层</strong>：向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。</li>
<li><strong>Simple
FS文件系统层</strong>：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口</li>
<li><strong>外设接口层</strong>：向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。</li>
</ul>
<p>对照上面的层次我们再大致介绍一下文件系统的访问处理过程，加深对文件系统的总体理解。假如应用程序操作文件（打开/创建/删除/读写），<strong>首先需要通过文件系统的通用文件系统访问接口层</strong>给用户空间提供的访问接口进入文件系统内部，<strong>接着由文件系统抽象层把访问请求转发给某一具体文件系统</strong>（比如SFS文件系统），具体文件系统（<strong>Simple
FS文件系统层</strong>）把应用程序的访问请求转化为对磁盘上的block的处理请求，<strong>并通过外设接口层交给磁盘驱动例程来完成具体的磁盘操作</strong>。结合用户态写文件函数write的整个执行过程，我们可以比较清楚地看出ucore文件系统架构的层次和依赖关系。</p>
<img src="/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/pic1.png" class="">
<p>从ucore操作系统不同的角度来看，ucore中的文件系统架构包含四类主要的数据结构,
它们分别是：</p>
<ul>
<li>超级块（SuperBlock）：它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li>
<li>索引节点（inode）它主要从文件系统的单个文件的角度它描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li>
<li>目录项（dentry）：它主要从文件系统的文件路径的角度描述了文件路径中的一个特定的目录项（注：一系列目录项形成目录/文件路径）。它的作用范围是整个OS空间。对于SFS而言，inode(具体为struct
sfs_disk_inode)对应于物理磁盘上的具体对象，dentry（具体为struct
sfs_disk_entry）是一个内存实体，其中的ino成员指向对应的inode
number，另外一个成员是file name(文件名).</li>
<li>文件（file），它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li>
</ul>
<p>如果一个用户进程打开了一个文件，那么在ucore中涉及的相关数据结构和关系如下图所示：</p>
<img src="/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/pic2.png" class="">
<h4 id="层次结构">层次结构</h4>
<h5 id="通用文件系统访问接口层">通用文件系统访问接口层</h5>
<p>我们把上面刚出现的proc_struct和files_struct重新看一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">filesp</span>;</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 当前工作目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// inode of present working directory</span></span><br><span class="line">    <span class="comment">// 文件描述符(数组)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// opened files array</span></span><br><span class="line">    <span class="comment">// 打开的文件数目</span></span><br><span class="line">    <span class="type">int</span> files_count;        <span class="comment">// the number of opened files</span></span><br><span class="line">    <span class="comment">// 用于文件加锁的信号量</span></span><br><span class="line">    <span class="type">semaphore_t</span> files_sem;  <span class="comment">// lock protect sem</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>prco结构体</code>中的<code>files_struct结构体</code>指针指向当前程序打开的所有文件，因此files_struct结构体用于描述多个打开的文件。而在files_struct结构体内部，存在一个<code>file结构体</code>数组用于存放打开的所有文件，也存在一个<code>inode结构体</code>指针指向当前工作目录。</p>
<p>如果将proc结构体看作是一个一个线程、那么files_struct结构体就可以看成是<strong>通用文件系统访问接口层的抽象</strong>，基于此，用户(线程)可以使用open、close等通用系统调用接口来管理文件。</p>
<details>
<summary>
<code>通用文件系统访问接口层的抽象</code>(大致看一下就行)
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uint32_t</span> open_flags)</span>;        <span class="comment">// Open or create a file. FLAGS/MODE per the syscall.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_close</span><span class="params">(<span class="type">int</span> fd)</span>;                                      <span class="comment">// Close a vnode opened  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *base, <span class="type">size_t</span> len)</span>;               <span class="comment">// Read file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *base, <span class="type">size_t</span> len)</span>;              <span class="comment">// Write file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_seek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> pos, <span class="type">int</span> whence)</span>;                <span class="comment">// Seek file  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *stat)</span>;                   <span class="comment">// Stat file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_fsync</span><span class="params">(<span class="type">int</span> fd)</span>;                                      <span class="comment">// Sync file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;                            <span class="comment">// change DIR  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;                            <span class="comment">// create DIR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path1, <span class="type">const</span> <span class="type">char</span> *path2)</span>;         <span class="comment">// set a path1's link as path2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path1, <span class="type">const</span> <span class="type">char</span> *path2)</span>;       <span class="comment">// rename file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;                           <span class="comment">// unlink a path</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span>;                      <span class="comment">// get current working directory</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_getdirentry</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> dirent *direntp)</span>;        <span class="comment">// get the file entry in DIR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_dup</span><span class="params">(<span class="type">int</span> fd1, <span class="type">int</span> fd2)</span>;                              <span class="comment">// duplicate file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_pipe</span><span class="params">(<span class="type">int</span> *fd_store)</span>;                                <span class="comment">// build PIPE</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfile_mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> open_flags)</span>;      <span class="comment">// build named PIPE</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>
<code>通用文件系统访问接口层的抽象(更底层API)</code>(大致看一下就行)
</summary>
<p>在这些sysfile_xx函数中，调用的下一层函数分别是封装好的各个file_xx函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_open</span><span class="params">(<span class="type">char</span> *path, <span class="type">uint32_t</span> open_flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *base, <span class="type">size_t</span> len, <span class="type">size_t</span> *copied_store)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *base, <span class="type">size_t</span> len, <span class="type">size_t</span> *copied_store)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_seek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> pos, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *stat)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_getdirentry</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> dirent *dirent)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_dup</span><span class="params">(<span class="type">int</span> fd1, <span class="type">int</span> fd2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_pipe</span><span class="params">(<span class="type">int</span> fd[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">file_mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">uint32_t</span> open_flags)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h5 id="文件系统抽象层">文件系统抽象层</h5>
<p>文件系统抽象层是把不同文件系统的对外共性接口提取出来，形成一个函数指针数组，这样，通用文件系统访问接口层只需访问文件系统抽象层，而不需关心具体文件系统的实现细节和接口。</p>
<p>系统接口再下一层就到了VFS虚拟文件系统。VFS函数涉及到了文件结构体file和inode结构体。</p>
<p>然后我们看一下file结构体和inode结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 状态值，描述文件打开、关闭、初始化等</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">    {</span></span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    } status;</span><br><span class="line">    <span class="comment">// 读写权限</span></span><br><span class="line">    <span class="type">bool</span> readable;</span><br><span class="line">    <span class="type">bool</span> writable;</span><br><span class="line">    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 下一次写入的起始位置</span></span><br><span class="line">    <span class="type">off_t</span> pos; </span><br><span class="line">    <span class="comment">// 文件的i结点数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="comment">// 打开此文件的次数</span></span><br><span class="line">    <span class="type">int</span> open_count;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 包含不同文件系统特定inode信息的union成员变量</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">    {</span>                     </span><br><span class="line">        <span class="comment">//设备文件系统内存inode信息            </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span>       </span><br><span class="line">        <span class="comment">//SFS文件系统内存inode信息   </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span>    </span><br><span class="line">    } in_info;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此inode所属文件系统类型</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">    {</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    } in_type;              </span><br><span class="line">    <span class="comment">// 此inode的引用计数            </span></span><br><span class="line">    <span class="type">atomic_t</span> ref_count;    </span><br><span class="line">    <span class="comment">// 打开此inode对应文件的个数             </span></span><br><span class="line">    <span class="type">atomic_t</span> open_count;              </span><br><span class="line">    <span class="comment">// 抽象的文件系统，包含访问文件系统的函数指针  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span>                   </span><br><span class="line">    <span class="comment">// 抽象的inode操作，包含访问inode的函数指针     </span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span>     </span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>file结构体指定了文件的相关类型，包括读写权限，文件描述符fd，当前读取到的位置pos，文件系统中与硬盘特定区域所对应的结点node，以及打开的引用次数open_count。index
node是位于内存的索引节点，它是VFS结构中的重要数据结构，因为它实际负责把不同文件系统的特定索引节点信息（甚至不能算是一个索引节点）统一封装起来，避免了进程直接访问具体文件系统。</p>
<p>inode结构体中存放了info、类型type、引用次数ref_count、打开次数open_count、相关联的文件系统in_fs以及当前结构所对应的操作集合in_ops。<strong>该结构与硬盘上对应区域相关联，从而便于对硬盘进行操作。</strong></p>
<p>inode_ops成员是对常规文件、目录、设备文件所有操作的一个抽象函数表示。对于某一具体的文件系统中的文件或目录，只需实现相关的函数，就可以被用户进程访问具体的文件了，且用户进程无需了解具体文件系统的实现细节。</p>
<details>
<summary>
<code>file结构体对应的接口</code>(大致看一下就行)
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Virtual File System layer functions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The VFS layer translates operations on abstract on-disk files or</span></span><br><span class="line"><span class="comment"> * pathnames to operations on specific files on specific filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vfs_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vfs_cleanup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vfs_devlist_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer low-level operations.</span></span><br><span class="line"><span class="comment"> * See inode.h for direct operations on inodes.</span></span><br><span class="line"><span class="comment"> * See fs.h for direct operations on filesystems/devices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_set_curdir   - change current directory of current thread by inode</span></span><br><span class="line"><span class="comment"> *    vfs_get_curdir   - retrieve inode of current directory of current thread</span></span><br><span class="line"><span class="comment"> *    vfs_get_root     - get root inode for the filesystem named DEVNAME</span></span><br><span class="line"><span class="comment"> *    vfs_get_devname  - get mounted device name for the filesystem passed in</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_set_curdir</span><span class="params">(<span class="keyword">struct</span> inode *dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_get_curdir</span><span class="params">(<span class="keyword">struct</span> inode **dir_store)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_get_root</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname, <span class="keyword">struct</span> inode **root_store)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">vfs_get_devname</span><span class="params">(<span class="keyword">struct</span> fs *fs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer high-level operations on pathnames</span></span><br><span class="line"><span class="comment"> * Because namei may destroy pathnames, these all may too.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_open         - Open or create a file. FLAGS/MODE per the syscall.</span></span><br><span class="line"><span class="comment"> *    vfs_close  - Close a inode opened with vfs_open. Does not fail.</span></span><br><span class="line"><span class="comment"> *                 (See vfspath.c for a discussion of why.)</span></span><br><span class="line"><span class="comment"> *    vfs_link         - Create a hard link to a file.</span></span><br><span class="line"><span class="comment"> *    vfs_symlink      - Create a symlink PATH containing contents CONTENTS.</span></span><br><span class="line"><span class="comment"> *    vfs_readlink     - Read contents of a symlink into a uio.</span></span><br><span class="line"><span class="comment"> *    vfs_mkdir        - Create a directory. MODE per the syscall.</span></span><br><span class="line"><span class="comment"> *    vfs_unlink       - Delete a file/directory.</span></span><br><span class="line"><span class="comment"> *    vfs_rename       - rename a file.</span></span><br><span class="line"><span class="comment"> *    vfs_chdir  - Change current directory of current thread by name.</span></span><br><span class="line"><span class="comment"> *    vfs_getcwd - Retrieve name of current directory of current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_open</span><span class="params">(<span class="type">char</span> *path, <span class="type">uint32_t</span> open_flags, <span class="keyword">struct</span> inode **inode_store)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_close</span><span class="params">(<span class="keyword">struct</span> inode *node)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_link</span><span class="params">(<span class="type">char</span> *old_path, <span class="type">char</span> *new_path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_symlink</span><span class="params">(<span class="type">char</span> *old_path, <span class="type">char</span> *new_path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_readlink</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> iobuf *iob)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_mkdir</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_unlink</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_rename</span><span class="params">(<span class="type">char</span> *old_path, <span class="type">char</span> *new_path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_chdir</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_getcwd</span><span class="params">(<span class="keyword">struct</span> iobuf *iob)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer mid-level operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_lookup     - Like VOP_LOOKUP, but takes a full device:path name,</span></span><br><span class="line"><span class="comment"> *                     or a name relative to the current directory, and</span></span><br><span class="line"><span class="comment"> *                     goes to the correct filesystem.</span></span><br><span class="line"><span class="comment"> *    vfs_lookparent - Likewise, for VOP_LOOKPARENT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Both of these may destroy the path passed in.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_lookup</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> inode **node_store)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_lookup_parent</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> inode **node_store, <span class="type">char</span> **endp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Misc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_set_bootfs - Set the filesystem that paths beginning with a</span></span><br><span class="line"><span class="comment"> *                    slash are sent to. If not set, these paths fail</span></span><br><span class="line"><span class="comment"> *                    with ENOENT. The argument should be the device</span></span><br><span class="line"><span class="comment"> *                    name or volume name for the filesystem (such as</span></span><br><span class="line"><span class="comment"> *                    "lhd0:") but need not have the trailing colon.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_get_bootfs - return the inode of the bootfs filesystem.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_add_fs     - Add a hardwired filesystem to the VFS named device</span></span><br><span class="line"><span class="comment"> *                    list. It will be accessible as "devname:". This is</span></span><br><span class="line"><span class="comment"> *                    intended for filesystem-devices like emufs, and</span></span><br><span class="line"><span class="comment"> *                    gizmos like Linux procfs or BSD kernfs, not for</span></span><br><span class="line"><span class="comment"> *                    mounting filesystems on disk devices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_add_dev    - Add a device to the VFS named device list. If</span></span><br><span class="line"><span class="comment"> *                    MOUNTABLE is zero, the device will be accessible</span></span><br><span class="line"><span class="comment"> *                    as "DEVNAME:". If the mountable flag is set, the</span></span><br><span class="line"><span class="comment"> *                    device will be accessible as "DEVNAMEraw:" and</span></span><br><span class="line"><span class="comment"> *                    mountable under the name "DEVNAME". Thus, the</span></span><br><span class="line"><span class="comment"> *                    console, added with MOUNTABLE not set, would be</span></span><br><span class="line"><span class="comment"> *                    accessed by pathname as "con:", and lhd0, added</span></span><br><span class="line"><span class="comment"> *                    with mountable set, would be accessed by</span></span><br><span class="line"><span class="comment"> *                    pathname as "lhd0raw:" and mounted by passing</span></span><br><span class="line"><span class="comment"> *                    "lhd0" to vfs_mount.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_mount      - Attempt to mount a filesystem on a device. The</span></span><br><span class="line"><span class="comment"> *                    device named by DEVNAME will be looked up and</span></span><br><span class="line"><span class="comment"> *                    passed, along with DATA, to the supplied function</span></span><br><span class="line"><span class="comment"> *                    MOUNTFUNC, which should create a struct fs and</span></span><br><span class="line"><span class="comment"> *                    return it in RESULT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_unmount    - Unmount the filesystem presently mounted on the</span></span><br><span class="line"><span class="comment"> *                    specified device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_unmountall - Unmount all mounted filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_set_bootfs</span><span class="params">(<span class="type">char</span> *fsname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_get_bootfs</span><span class="params">(<span class="keyword">struct</span> inode **node_store)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_add_fs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname, <span class="keyword">struct</span> fs *fs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_add_dev</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname, <span class="keyword">struct</span> inode *devnode, <span class="type">bool</span> mountable)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname, <span class="type">int</span> (*mountfunc)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> fs **fs_store))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_unmount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_unmount_all</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vfs中更为底层的函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> {</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vop_magic;</span><br><span class="line">    <span class="type">int</span> (*vop_open)(<span class="keyword">struct</span> inode *node, <span class="type">uint32_t</span> open_flags);</span><br><span class="line">    <span class="type">int</span> (*vop_close)(<span class="keyword">struct</span> inode *node);</span><br><span class="line">    <span class="type">int</span> (*vop_read)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_write)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_fstat)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> stat *stat);</span><br><span class="line">    <span class="type">int</span> (*vop_fsync)(<span class="keyword">struct</span> inode *node);</span><br><span class="line">    <span class="type">int</span> (*vop_namefile)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_getdirentry)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_reclaim)(<span class="keyword">struct</span> inode *node);</span><br><span class="line">    <span class="type">int</span> (*vop_gettype)(<span class="keyword">struct</span> inode *node, <span class="type">uint32_t</span> *type_store);</span><br><span class="line">    <span class="type">int</span> (*vop_tryseek)(<span class="keyword">struct</span> inode *node, <span class="type">off_t</span> pos);</span><br><span class="line">    <span class="type">int</span> (*vop_truncate)(<span class="keyword">struct</span> inode *node, <span class="type">off_t</span> len);</span><br><span class="line">    <span class="type">int</span> (*vop_create)(<span class="keyword">struct</span> inode *node, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">bool</span> excl, <span class="keyword">struct</span> inode **node_store);</span><br><span class="line">    <span class="type">int</span> (*vop_lookup)(<span class="keyword">struct</span> inode *node, <span class="type">char</span> *path, <span class="keyword">struct</span> inode **node_store);</span><br><span class="line">    <span class="type">int</span> (*vop_ioctl)(<span class="keyword">struct</span> inode *node, <span class="type">int</span> op, <span class="type">void</span> *data);</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<p>文件系统抽象层VFS提供了file接口、dir接口、inode接口、fs接口以及外设接口。而这些接口在sfs中被具体实现。</p>
<h5 id="simple-fs-文件系统层">Simple FS 文件系统层</h5>
<p>ucore内核把所有文件都看作是字节流，任何内部逻辑结构都是专用的，由应用程序负责解释。但是ucore区分文件的物理结构。ucore目前支持如下几种类型的文件：</p>
<ul>
<li><strong>常规文件</strong>：文件中包括的内容信息是由应用程序输入。SFS文件系统在普通文件上不强加任何内部结构，把其文件内容信息看作为字节。</li>
<li><strong>目录</strong>：包含一系列的entry，每个entry包含文件名和指向与之相关联的索引节点（index
node）的指针。目录是按层次结构组织的。</li>
<li><strong>链接文件</strong>：实际上一个链接文件是一个已经存在的文件的另一个可选择的文件名。</li>
<li><strong>设备文件</strong>：不包含数据，但是提供了一个映射物理设备（如串口、键盘等）到一个文件名的机制。可通过设备文件访问外围设备。</li>
<li><strong>管道</strong>：管道是进程间通讯的一个基础设施。管道缓存了其输入端所接受的数据，以便在管道输出端读的进程能一个先进先出的方式来接受数据。</li>
</ul>
<p>SFS文件系统中目录和常规文件具有共同的属性，而这些属性保存在索引节点中。SFS通过索引节点来管理目录和常规文件，索引节点包含操作系统所需要的关于某个文件的关键信息，比如文件的属性、访问许可权以及其它控制信息都保存在索引节点中。可以有多个文件名可指向一个索引节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Abstract filesystem. (Or device accessible as a file.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Information:</span></span><br><span class="line"><span class="comment"> *      fs_info   : filesystem-specific data (sfs_fs)</span></span><br><span class="line"><span class="comment"> *      fs_type   : filesystem type</span></span><br><span class="line"><span class="comment"> * Operations:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      fs_sync       - Flush all dirty buffers to disk.</span></span><br><span class="line"><span class="comment"> *      fs_get_root   - Return root inode of filesystem.</span></span><br><span class="line"><span class="comment"> *      fs_unmount    - Attempt unmount of filesystem.</span></span><br><span class="line"><span class="comment"> *      fs_cleanup    - Cleanup of filesystem.???</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * fs_get_root should increment the refcount of the inode returned.</span></span><br><span class="line"><span class="comment"> * It should not ever return NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If fs_unmount returns an error, the filesystem stays mounted, and</span></span><br><span class="line"><span class="comment"> * consequently the struct fs instance should remain valid. On success,</span></span><br><span class="line"><span class="comment"> * however, the filesystem object and all storage associated with the</span></span><br><span class="line"><span class="comment"> * filesystem should have been discarded/released.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    {</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> __<span class="title">sfs_info</span>;</span></span><br><span class="line">    } fs_info; <span class="comment">// filesystem-specific data</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">    {</span></span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    } fs_type;                                   <span class="comment">// filesystem type</span></span><br><span class="line">    <span class="type">int</span> (*fs_sync)(<span class="keyword">struct</span> fs *fs);               <span class="comment">// Flush all dirty buffers to disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">fs_get_root</span>)(<span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>);</span> <span class="comment">// Return root inode of filesystem.</span></span><br><span class="line">    <span class="type">int</span> (*fs_unmount)(<span class="keyword">struct</span> fs *fs);            <span class="comment">// Attempt unmount of filesystem.</span></span><br><span class="line">    <span class="type">void</span> (*fs_cleanup)(<span class="keyword">struct</span> fs *fs);           <span class="comment">// Cleanup of filesystem.???</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* filesystem for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>  <span class="comment">/* on-disk superblock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>      <span class="comment">/* device mounted on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>  <span class="comment">/* blocks in use are mared 0 */</span></span><br><span class="line">    <span class="type">bool</span> super_dirty;        <span class="comment">/* true if super/freemap modified */</span></span><br><span class="line">    <span class="type">void</span> *sfs_buffer;        <span class="comment">/* buffer for non-block aligned io */</span></span><br><span class="line">    <span class="type">semaphore_t</span> fs_sem;      <span class="comment">/* semaphore for fs */</span></span><br><span class="line">    <span class="type">semaphore_t</span> io_sem;      <span class="comment">/* semaphore for io */</span></span><br><span class="line">    <span class="type">semaphore_t</span> mutex_sem;   <span class="comment">/* semaphore for link/unlink and rename */</span></span><br><span class="line">    <span class="type">list_entry_t</span> inode_list; <span class="comment">/* inode linked-list */</span></span><br><span class="line">    <span class="type">list_entry_t</span> *hash_list; <span class="comment">/* inode hash linked-list */</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sfs_fs结构中包含了底层设备的超级块superblock、所挂载的设备dev、以及底层设备中用于表示空间分配情况的freemap等。fs结构是我们在上层函数调用中所直接操作的抽象文件系统，而sfs_fs则是在下层函数中所使用的。在原先sfs_fs上抽象出一层fs结构有助于忽略不同文件系统的差异。</p>
<details>
<summary>
<code>对应的接口为</code>(大致看一下就行)
</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sfs_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_sfs_fs</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_sfs_io</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock_sfs_fs</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock_sfs_io</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_rblock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">void</span> *buf, <span class="type">uint32_t</span> blkno, <span class="type">uint32_t</span> nblks)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_wblock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">void</span> *buf, <span class="type">uint32_t</span> blkno, <span class="type">uint32_t</span> nblks)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_rbuf</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">uint32_t</span> blkno, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_wbuf</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">uint32_t</span> blkno, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_sync_super</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_sync_freemap</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_clear_block</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">uint32_t</span> blkno, <span class="type">uint32_t</span> nblks)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sfs_load_inode</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="keyword">struct</span> inode **node_store, <span class="type">uint32_t</span> ino)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sfs_sync</span><span class="params">(<span class="keyword">struct</span> fs *fs)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode* <span class="title function_">sfs_get_root</span><span class="params">(<span class="keyword">struct</span> fs *fs)</span> ;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sfs_unmount</span><span class="params">(<span class="keyword">struct</span> fs *fs)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sfs_cleanup</span><span class="params">(<span class="keyword">struct</span> fs *fs)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fs_init_read</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">uint32_t</span> blkno, <span class="type">void</span> *blk_buffer)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fs_do_mount</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> fs **fs_store)</span>;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<p>文件系统通常保存在磁盘上。在本实验中，第三个磁盘（即disk0，前两个磁盘分别是
ucore.img 和 swap.img）用于存放一个SFS文件系统（Simple
Filesystem）。通常文件系统中，磁盘的使用是以扇区（Sector）为单位的，但是为了实现简便，SFS
中以 block （4K，与内存 page 大小相等）为基本单位。布局如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+------------+----------+---------+-------------------------------------+</span><br><span class="line">| superblock | root-dir | freemap | Inode / File Data / Dir Data blocks |</span><br><span class="line">+------------+----------+---------+-------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>第0个块（4K）是超级块（superblock），它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存。其定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On-disk superblock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 超级块结构中包含成员变量魔数magic，内核通过它来检查磁盘镜像是否是合法的 SFS img</span></span><br><span class="line">    <span class="type">uint32_t</span> magic;                                 <span class="comment">/* magic number, should be SFS_MAGIC */</span></span><br><span class="line">    <span class="type">uint32_t</span> blocks;                                <span class="comment">/* # of blocks in fs */</span></span><br><span class="line">    <span class="type">uint32_t</span> unused_blocks;                         <span class="comment">/* # of unused blocks in fs */</span></span><br><span class="line">    <span class="type">char</span> info[SFS_MAX_INFO_LEN + <span class="number">1</span>];                <span class="comment">/* infomation for sfs  */</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>第1个块放了一个root-dir的inode，用来记录根目录的相关信息。root-dir是SFS文件系统的根结点，通过这个root-dir的inode信息就可以定位并查找到根目录下的所有文件信息。</li>
<li>从第2个块开始，根据SFS中所有块的数量，用1个bit来表示一个块的占用和未被占用的情况。这个区域称为SFS的freemap区域，这将占用若干个块空间。为了更好地记录和管理freemap区域</li>
<li>最后在剩余的磁盘空间中，存放了所有其他目录和文件的inode信息和内容数据信息。需要注意的是虽然inode的大小小于一个块的大小（4096B），但为了实现简单，每个
inode 都占用一个完整的 block。</li>
</ul>
<div class="note info">
            <p><strong>索引结点</strong></p><p><strong>在sfs层面上，inode结构既可表示文件file、目录dir，也可表示设备device</strong>。而区分inode结构的操作有两种，一种是其in_info成员变量，另一种是该结构的成员指针in_ops。当uCore创建一个用于<strong>存储文件/目录的inode结构</strong>（即该inode结构的in_info成员变量为sfs_inode类型）时，程序会执行函数sfs_create_inode。该函数会将inode结构中的sfs_inode成员与磁盘对应结点sfs_disk_inode相关联，从而使得只凭inode即可操作该结点。</p><p>而sfs_disk_inode结构记录了<strong>文件或目录的内容存储的索引信息</strong>，该数据结构在硬盘里储存，需要时读入内存。type成员表明该结构是目录类型还是文件类型，又或者是链接link类型。如果inode表示的是文件，则成员变量direct[]直接指向了保存文件内容数据的数据块索引值。indirect指向的是间接数据块，此数据块实际存放的全部是数据块索引，这些数据块索引指向的数据块才被用来存放文件内容数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* file types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SFS_TYPE_INVAL 0 <span class="comment">/* Should not appear on disk */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SFS_TYPE_FILE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SFS_TYPE_DIR 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SFS_TYPE_LINK 3</span></span><br><span class="line"><span class="comment">/* inode (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 如果inode表示常规文件，则size是文件大小</span></span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="comment">// inode的文件类型</span></span><br><span class="line">    <span class="type">uint16_t</span> type;</span><br><span class="line">    <span class="comment">// 此inode的硬链接数</span></span><br><span class="line">    <span class="type">uint16_t</span> nlinks;</span><br><span class="line">    <span class="comment">// 此inode的数据块数的个数</span></span><br><span class="line">    <span class="type">uint32_t</span> blocks;</span><br><span class="line">    <span class="comment">// 此inode的直接数据块索引值（有SFS_NDIRECT个）</span></span><br><span class="line">    <span class="type">uint32_t</span> direct[SFS_NDIRECT];</span><br><span class="line">    <span class="comment">// 此inode的一级间接数据块索引值</span></span><br><span class="line">    <span class="type">uint32_t</span> indirect;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于普通文件，索引值指向的 block中保存的是文件中的数据。而对于目录，索引值指向的数据保存的是目录下所有的文件名以及对应的索引节点所在的索引块（磁盘块）所形成的数组。即</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* file entry (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">// 索引节点所占数据块索引值</span></span><br><span class="line">    <span class="type">uint32_t</span> ino;</span><br><span class="line">    <span class="comment">// 文件名</span></span><br><span class="line">    <span class="type">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有<strong>内存索引点</strong>，保存在内存中的索引结点</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* inode for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">/* on-disk inode */</span></span><br><span class="line">    <span class="type">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="type">bool</span> dirty;                                     <span class="comment">/* true if inode modified */</span></span><br><span class="line">    <span class="type">int</span> reclaim_count;                              <span class="comment">/* kill inode if it hits zero */</span></span><br><span class="line">    <span class="type">semaphore_t</span> sem;                                <span class="comment">/* semaphore for din */</span></span><br><span class="line">    <span class="type">list_entry_t</span> inode_link;                        <span class="comment">/* entry for linked-list in sfs_fs */</span></span><br><span class="line">    <span class="type">list_entry_t</span> hash_link;                         <span class="comment">/* entry for hash linked-list in sfs_fs */</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SFS中的内存sfs_inode除了包含SFS的硬盘sfs_disk_inode信息，而且还增加了其他一些信息。这些信息用于判断相关硬盘位置是否改写、互斥操作、回收和快速地定位等作用。</p><p>需要注意的是，<strong>一个内存sfs_inode是在打开一个文件后才创建的</strong>，如果关机则相关信息都会消失。而<strong>硬盘sfs_disk_inode的内容是保存在硬盘中的</strong>，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</p><p>还有<strong>文件结点</strong>,用于指向磁盘索引结点的结点，其结构如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* file entry (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="type">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">/* file name */</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件结点中的name表示当前文件的文件名，而其ino成员则指向了sfs_disk_inode磁盘索引结点。上一层的目录索引结点则会指向各个下层的文件结点。</p><p>同时，为了方便实现上面提到的多级数据的访问以及目录中 entry的操作，对于inode，SFS实现了一些辅助的函数，它们分别是</p><ul><li>sfs_bmap_load_nolock : 将对应sfs_inode的第 index 个索引指向的 block的索引值取出，并存到相应的指针指向的单元（ino_store）。如果index ==din-&gt;blocks, 则将会为inode增长一个 block。并标记 inode 为 dirty</li><li>sfs_bmap_truncate_nolock : 将多级数据索引表的最后一个 entry释放掉。该函数可以认为是sfs_bmap_load_nolock中，index ==inode-&gt;blocks的逆操作。</li><li>sfs_dirent_read_nolock : 将目录的第 slot 个 entry读取到指定的内存空间。</li><li>sfs_dirent_search_nolock :该函数是常用的查找函数，函数会在目录下查找name，并且返回相应的搜索结果（文件或文件夹）的 inode的编号（也是磁盘编号），和相应的 entry 在该目录的 index编号以及目录下的数据页是否有空闲的 entry。</li></ul><p><strong>需要注意的是，这些后缀为nolock的函数，只能在已经获得相应inode的semaphore才能调用。</strong></p>
          </div>
<h5 id="外设接口层io设备">外设接口层(I/O设备)</h5>
<p>在底层一点就是I/O设备的相关实现，这些部分直接基于驱动来实现。</p>
<h4 id="文件系统挂载流程">文件系统挂载流程</h4>
<p>一个文件系统在使用前，需要将其挂载至内核中。在uCore里，硬盘disk0的挂载流程如下：</p>
<ul>
<li>首先，在fs_init函数中执行init_device(disk0)，初始化对应device结构并将其连接至vdev_list链表中：</li>
<li>之后，在fs_init函数中执行sfs_init() -&gt; sfs_mount("disk0")</li>
<li>紧接着，sfs_mount会调用vfs_mount，在vfs的挂载接口中调用sfs自己的sfs_do_mount挂载函数。sfs_do_mount挂载函数会执行以下几个操作
<ul>
<li>从待挂载设备中读取超级块，并验证超级块中，魔数与总块数是否存在错误</li>
<li>初始化哈希链表</li>
<li>从待挂载设备中读入freemap并测试其正确性</li>
<li>设置fs结构的相关信息，并在函数最后将该信息设置为传入的device结构体中的fs成员变量</li>
</ul></li>
</ul>
<h3 id="x01-完成读文件操作的实现">0X01 完成读文件操作的实现</h3>
<p>我们还是先来看一下这张图：</p>
<img src="/2023/01/25/%E4%BB%8Eucore%E6%9D%A5%E6%80%BB%E7%BB%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8/pic2.png" class="">
<div class="note primary">
            <p><strong>打开文件流程</strong></p><p>首先假定用户进程需要打开的文件已经存在在硬盘上。当调用<code>open</code>函数打开一个文件时，首先进入通用<strong>文件访问接口层</strong>的处理流程，即进一步调用如下用户态函数：open-&gt;sys_open-&gt;syscall，从而引起系统调用进入到内核态。到了内核态后，<strong>通过中断处理例程</strong>，会调用到sys_open内核函数，并进一步调用sysfile_open内核函数。到了这里，需要把位于用户空间的字符串"sfs_filetest1"拷贝到内核空间中的字符串path中，<strong>并进入到文件系统抽象层</strong>的处理流程完成进一步的打开文件操作中。</p><p>在文件系统抽象层中，需要调用的是file_open函数，它要给这个即将打开的文件<strong>分配一个file数据结构</strong>的变量，这个变量其实是当前进程的打开文件数组current-&gt;fs_struct-&gt;filemap[]中的一个空闲元素（即还没用于一个打开的文件），而这个元素的索引值就是最终要返回到用户进程并赋值给变量fd1。到了这一步还仅仅是给当前用户进程分配了一个file数据结构的变量，还没有找到对应的文件索引节点。为此需要进一步调用vfs_open函数来找到path指出的<strong>文件所对应的基于inode数据结构的VFS索引节点node</strong>。vfs_open函数需要完成两件事情：通过vfs_lookup找到path对应文件的inode；调用vop_open函数打开文件：</p><ul><li>找到文件设备的根目录“/”的索引节点需要注意，这里的vfs_lookup函数是一个针对目录的操作函数，它会调用vop_lookup函数来找到SFS文件系统中的“/”目录下的“sfs_filetest1”文件。为此，vfs_lookup函数首先调用get_device函数，并进一步调用vfs_get_bootfs函数（其实调用了）来找到根目录“/”对应的inode。这个inode就是位于vfs.c中的inode变量bootfs_node。这个变量在init_main函数（位于kern/process/proc.c）执行时获得了赋值。</li><li>通过调用vop_lookup函数来查找到根目录“/”下对应文件sfs_filetest1的索引节点，，如果找到就返回此索引节点。</li><li>把file和node建立联系。完成第3步后，将返回到file_open函数中，通过执行语句“file-&gt;node=node;”，就把当前进程的current-&gt;fs_struct-&gt;filemap[fd]（即file所指变量）的成员变量node指针指向了代表sfs_filetest1文件的索引节点inode。这时返回fd。经过重重回退，通过系统调用返回，用户态的syscall-&gt;sys_open-&gt;open-&gt;safe_open等用户函数的层层函数返回，最终把把fd赋值给fd1。自此完成了打开文件操作。但这里我们还没有分析第2和第3步是如何进一步调用SFS文件系统提供的函数找位于SFS文件系统上的sfs_filetest1文件所对应的sfs磁盘inode的过程。</li></ul>
          </div>
<p>当线程打开文件后尝试读取文件，则<strong>先进入通用文件访问接口层的处理流程</strong>，即进一步调用如下用户态函数：read-&gt;sys_read-&gt;syscall，从而引起系统调用进入到内核态。到了内核态以后，通过中断处理例程，会调用到sys_read内核函数，并进一步调用sysfile_read内核函数，<strong>进入到文件系统抽象层处理流程</strong>完成进一步读文件的操作。</p>
<p>在文件系统抽象层中，会检查错误并调用kmalloc分配4096字节的buffer空间。当读取时，先检查剩余部分大小，保证除最后一次外其余都是按照4096字节读，这部分调用file_read来实现。由于在内核态读取，所以需要将其拷贝到用户内存空间中。</p>
<p>我们顺着file_read往下看，主要执行read的函数是vop_read(vop_read函数实际上是对sfs_read的包装)，sfs_read函数直接调用sfs_io函数，而该函数将进一步调用sfs_io_nolock。sfs_io_nolock正是我们需要实现的函数。</p>
<p>注释中已经提醒我们，sys_io_nolock是按块读取，但是一个文件开头部分未必是块对齐的，结尾部分也未必是块对齐的，所以我们要把这两部分单独处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_io_nolock - Rd/Wr a file contentfrom offset position to offset+ length  disk blocks&lt;--&gt;buffer (in memroy)</span></span><br><span class="line"><span class="comment"> * @sfs:      sfs file system</span></span><br><span class="line"><span class="comment"> * @sin:      sfs inode in memory</span></span><br><span class="line"><span class="comment"> * @buf:      the buffer Rd/Wr</span></span><br><span class="line"><span class="comment"> * @offset:   the offset of file</span></span><br><span class="line"><span class="comment"> * @alenp:    the length need to read (is a pointer). and will RETURN the really Rd/Wr lenght</span></span><br><span class="line"><span class="comment"> * @write:    BOOL, 0 read, 1 write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sfs_io_nolock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="keyword">struct</span> sfs_inode *<span class="built_in">sin</span>, <span class="type">void</span> *buf, <span class="type">off_t</span> offset, <span class="type">size_t</span> *alenp, <span class="type">bool</span> write)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(din-&gt;type != SFS_TYPE_DIR);</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> endpos = offset + *alenp, blkoff;</span><br><span class="line">    *alenp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// calculate the Rd/Wr end position</span></span><br><span class="line">    <span class="comment">// 计算缓冲区读取/写入的终止位置</span></span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果偏移与终止位置相同，即欲读取/写入0字节的数据则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (offset == endpos)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE)</span><br><span class="line">    {</span><br><span class="line">        endpos = SFS_MAX_FILE_SIZE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!write)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 如果是读取数据，且缓冲区中剩余的数据超出一个硬盘节点的数据大小就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= din-&gt;size)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (endpos &gt; din-&gt;size)</span><br><span class="line">        {</span><br><span class="line">            endpos = din-&gt;size;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*sfs_buf_op)(<span class="keyword">struct</span> sfs_fs * sfs, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">uint32_t</span> blkno, <span class="type">off_t</span> offset);</span><br><span class="line">    <span class="type">int</span> (*sfs_block_op)(<span class="keyword">struct</span> sfs_fs * sfs, <span class="type">void</span> *buf, <span class="type">uint32_t</span> blkno, <span class="type">uint32_t</span> nblks);</span><br><span class="line">    <span class="keyword">if</span> (write)</span><br><span class="line">    {</span><br><span class="line">        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> size, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> ino;</span><br><span class="line">    <span class="type">uint32_t</span> blkno = offset / SFS_BLKSIZE;         <span class="comment">// The NO. of Rd/Wr begin block</span></span><br><span class="line">    <span class="type">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno; <span class="comment">// The size of Rd/Wr blocks</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB8:EXERCISE1 YOUR CODE HINT: call sfs_bmap_load_nolock, sfs_rbuf, sfs_rblock,etc. read different kind of blocks in file</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * (1) If offset isn't aligned with the first block, Rd/Wr some content from offset to the end of the first block</span></span><br><span class="line"><span class="comment">     *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">     *               Rd/Wr size = (nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset)</span></span><br><span class="line"><span class="comment">     * (2) Rd/Wr aligned blocks</span></span><br><span class="line"><span class="comment">     *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_block_op</span></span><br><span class="line"><span class="comment">     * (3) If end position isn't aligned with the last block, Rd/Wr some content from begin to the (endpos % SFS_BLKSIZE) of the last block</span></span><br><span class="line"><span class="comment">     *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 对齐偏移。如果偏移没有对齐第一个基础块，则多读取/写入第一个基础块的末尾数据</span></span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="comment">// 获取第一个基础块所对应的block的编号ino</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过上一步取出的ino，读取/写入一部分第一个基础块的末尾数据</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        alen += size;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        buf += size, blkno++, nblks--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取/写入对齐好的数据</span></span><br><span class="line">    size = SFS_BLKSIZE;</span><br><span class="line">    <span class="keyword">while</span> (nblks != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 获取inode对应的基础块编号</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 单次读取/写入一基础块的数据</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        alen += size, buf += size, blkno++, nblks--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果末尾位置没有与最后一个基础块对齐，则多读取/写入一点末尾基础块的数据</span></span><br><span class="line">    <span class="keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        alen += size;</span><br><span class="line">    }</span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="x02-基于文件系统的执行程序机制的实现">0X02
基于文件系统的执行程序机制的实现</h3>
<p>我们先回忆一下之前是怎么加载程序的：</p>
<ul>
<li>首先把用户程序随内核编译，放在img的最后</li>
<li>内核启动后，会把用户程序加载到内存中</li>
<li>内核线程调用execve函数来加载<strong>位于内存中的用户线程</strong>，切换上下文然后执行。</li>
</ul>
<p>之前没有文件系统，故不能从磁盘上加载程序；而有了文件系统以后，可以使用文件系统来把程序加载到内存里，然后像之前一样执行即可。</p>
<p>但是由于多了文件系统，proc结构体啥的都发生了变化，我们需要做一些修正：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct * <span class="title function_">alloc_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Lab7内容</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// LAB8:EXERCISE2 YOUR CODE HINT:need add some code to init fs in proc_struct, ...</span></span><br><span class="line">        <span class="comment">//  LAB8 添加一个filesp指针的初始化</span></span><br><span class="line">        proc-&gt;filesp = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多了file_struct结构的复制操作与执行失败时的重置操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_fork</span><span class="params">(<span class="type">uint32_t</span> clone_flags, <span class="type">uintptr_t</span> <span class="built_in">stack</span>, <span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    }</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    }</span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    assert(current-&gt;wait_state == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// LAB8:EXERCISE2 YOUR CODE  HINT:how to copy the fs in parent's proc_struct?</span></span><br><span class="line">    <span class="comment">//  LAB8 将当前进程的fs复制到fork出的进程中</span></span><br><span class="line">    <span class="keyword">if</span> (copy_files(clone_flags, proc) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">    }</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    {</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        set_links(proc);</span><br><span class="line">    }</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line"></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">// LAB8 如果复制失败，则需要重置原先的操作</span></span><br><span class="line">bad_fork_cleanup_fs: <span class="comment">// for LAB8</span></span><br><span class="line">    put_files(proc);</span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们来正式实现execve和相关函数。通过前面lab我们知道load_icode函数完成了整个execve过程复杂的工作，所以我们在此也要继续修正该函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// load_icode -  called by sys_exec--&gt;do_execve</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> argc, <span class="type">char</span> **kargv)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* LAB8:EXERCISE2 YOUR CODE  HINT:how to load the file with handler fd  in to process's memory? how to setup argc/argv?</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *  mm_create        - create a mm</span></span><br><span class="line"><span class="comment">     *  setup_pgdir      - setup pgdir in mm</span></span><br><span class="line"><span class="comment">     *  load_icode_read  - read raw data content of program file</span></span><br><span class="line"><span class="comment">     *  mm_map           - build new vma</span></span><br><span class="line"><span class="comment">     *  pgdir_alloc_page - allocate new memory for  TEXT/DATA/BSS/stack parts</span></span><br><span class="line"><span class="comment">     *  lcr3             - update Page Directory Addr Register -- CR3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* (1) create a new mm for current process</span></span><br><span class="line"><span class="comment">     * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line"><span class="comment">     * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span></span><br><span class="line"><span class="comment">     *    (3.1) read raw data content in file and resolve elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.3) call mm_map to build vma related to TEXT/DATA</span></span><br><span class="line"><span class="comment">     *    (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span></span><br><span class="line"><span class="comment">     *          and copy them into the new allocated pages</span></span><br><span class="line"><span class="comment">     *    (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span></span><br><span class="line"><span class="comment">     * (4) call mm_map to setup user stack, and put parameters into user stack</span></span><br><span class="line"><span class="comment">     * (5) setup current process's mm, cr3, reset pgidr (using lcr3 MARCO)</span></span><br><span class="line"><span class="comment">     * (6) setup uargc and uargv in user stacks</span></span><br><span class="line"><span class="comment">     * (7) setup trapframe for user environment</span></span><br><span class="line"><span class="comment">     * (8) if up steps failed, you should cleanup the env.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    assert(argc &gt;= <span class="number">0</span> &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        panic(<span class="string">"load_icode: current-&gt;mm must be empty.\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">// 创建proc的内存管理结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">// LAB8 这里要从文件中读取ELF header，而不是Lab7中的内存了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> __<span class="title">elf</span>, *<span class="title">elf</span> =</span> &amp;__elf;</span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elfhdr), <span class="number">0</span>)) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断读取入的elf header是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">    {</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 根据每一段的大小和基地址来分配不同的内存空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> __<span class="title">ph</span>, *<span class="title">ph</span> =</span> &amp;__ph;</span><br><span class="line">    <span class="type">uint32_t</span> vm_flags, perm, phnum;</span><br><span class="line">    <span class="keyword">for</span> (phnum = <span class="number">0</span>; phnum &lt; elf-&gt;e_phnum; phnum++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// LAB8 从文件特定偏移处读取每个段的详细信息（包括大小、基地址等等）</span></span><br><span class="line">        <span class="type">off_t</span> phoff = elf-&gt;e_phoff + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> proghdr) * phnum;</span><br><span class="line">        <span class="keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> proghdr), phoff)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz)</span><br><span class="line">        {</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X)</span><br><span class="line">            vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W)</span><br><span class="line">            vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R)</span><br><span class="line">            vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE)</span><br><span class="line">            perm |= PTE_W;</span><br><span class="line">        <span class="comment">// 为当前段分配内存空间</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">off_t</span> offset = ph-&gt;p_offset;</span><br><span class="line">        <span class="type">size_t</span> off, size;</span><br><span class="line">        <span class="type">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 设置该内存所对应的页表项</span></span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            }</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la)</span><br><span class="line">            {</span><br><span class="line">                size -= la - end;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// LAB8 读取elf对应段内的数据并写入至该内存中</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            }</span><br><span class="line">            start += size, offset += size;</span><br><span class="line">        }</span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="comment">// 对于段中当前页中剩余的空间（复制elf数据后剩下的空间），将其置为0</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; la)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span></span><br><span class="line">            <span class="keyword">if</span> (start == end)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la)</span><br><span class="line">            {</span><br><span class="line">                size -= la - end;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 对于段中剩余页中的空间（复制elf数据后的多余页面），将其置为0</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            }</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la)</span><br><span class="line">            {</span><br><span class="line">                size -= la - end;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 关闭读取的ELF</span></span><br><span class="line">    sysfile_close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置栈内存</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    }</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP - PGSIZE, PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP - <span class="number">2</span> * PGSIZE, PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP - <span class="number">3</span> * PGSIZE, PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP - <span class="number">4</span> * PGSIZE, PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    <span class="comment">// 设置CR3页表相关寄存器</span></span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup argc, argv</span></span><br><span class="line">    <span class="comment">//  LAB8 设置execve所启动的程序参数</span></span><br><span class="line">    <span class="type">uint32_t</span> argv_size = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    {</span><br><span class="line">        argv_size += strnlen(kargv[i], EXEC_MAX_ARG_LEN + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">uintptr_t</span> stacktop = USTACKTOP - (argv_size / <span class="keyword">sizeof</span>(<span class="type">long</span>) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">    <span class="comment">// 直接将传入的参数压入至新栈的底部</span></span><br><span class="line">    <span class="type">char</span> **uargv = (<span class="type">char</span> **)(stacktop - argc * <span class="keyword">sizeof</span>(<span class="type">char</span> *));</span><br><span class="line"></span><br><span class="line">    argv_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    {</span><br><span class="line">        uargv[i] = <span class="built_in">strcpy</span>((<span class="type">char</span> *)(stacktop + argv_size), kargv[i]);</span><br><span class="line">        argv_size += strnlen(kargv[i], EXEC_MAX_ARG_LEN + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stacktop = (<span class="type">uintptr_t</span>)uargv - <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    *(<span class="type">int</span> *)stacktop = argc;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="x03-总结">0X03 总结</h3>
<p>说实话，文件系统本身就很复杂，这里还掺杂了虚拟文件系统的概念，难度挺大，主要就是认识一下。我自己是基于现有的驱动(其实是伪驱动，不基于ucore)，额外实现了一个不带虚拟文件系统的简易文件系统，这样的话理解似乎会更深一点。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>ucore操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>levelDB源码剖析(14)--数据库功能部分</title>
    <url>/2022/10/24/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-14/</url>
    <content><![CDATA[<h2 id="数据库功能部分">数据库功能部分</h2>
<span id="more"></span>
<p>前面已经对levelDB中的各个组件进行了详细的源码剖析，下面我们就开始把这些左键全部串起来，在数据库的层面对其进行理解。</p>
<p>我们人为将LevelDB分为了数据库层和存储引擎层，在前面部分介绍了存储引擎相关的组件，包括：</p>
<ul>
<li>SSTable存储结构实现，提供了在一个磁盘文件里读取一个键的功能，并且可以迭代一个SSTable的所有键</li>
<li>MemTable内存结构的实现，提供了读取一个键和写入一个键的功能，迭代MemTable里所有的键，以及可以将一个MemTable转换为一个SSTable</li>
<li>Log将写入持久化到磁盘上面，将随机写入转换为顺序写入</li>
<li>迭代器对各种存储组件迭代，以及定位某一个键</li>
</ul>
<p>利用这些组件提供的功能，就可以实现数据库层。可以将数据库层的功能分为两个部分：</p>
<ul>
<li>Get、Put和Delete接口实现，这里是LevelDB对外提供的操作接口，分别实现键值对的查找、插入和删除</li>
<li>版本管理和Compaction，随着数据的写入，不断的有MemTable转换为SSTable，当有些键不断的更新删除，有些Level的文件太多时，影响了读性能，需要进行Compaction，将低Level的SSTable
Compaction到高Level的SSTable里去，提高读的效率。而Compaction是通过版本来管理的，当一次Compaction完成时，就会生成一个新版本</li>
</ul>
<p>本文主要针对数据库的接口部分进行阐述。</p>
<h2 id="接口管理">接口管理</h2>
<div class="note primary">
            <p>源码位置与说明</p><p>include/leveldb/db.h db/db_impl.h db/db_impl.cc:实现了GET/PUT/DELETE<br>db/version_set.h db/version_set.cc:实现从一个version的SSTable里读取一个键<br>db/memtable.h db/memtable.cc: 实现从MemTable读取一个键<br>inlclude/leveldb/table.h db/table_cache.h db/table_cache.cc db/table.cc:定义从一个SSTable读取一个键<br>include/leveldb/write_batch.h db/write_batch.cc：writebatch相关函数<br>db/write_batch_internal.h ： WriteBatchInternal类</p>
          </div>
<p>我们先来看一下数据库的接口部分，很明显，作为一个库，增删查是必不可少的，这也是数据库的核心功能。</p>
<h3 id="db接口和接口相关的类">DB接口和接口相关的类</h3>
<h4 id="db类">DB类</h4>
<p>首先先来看一下DB类的头文件，这个DB类也是一个纯虚基类，是负责定义数据库的接口的。一个DB类(及其派生类)就可以看成是永久有序的kv存储的数据库，且其需要保证线程安全。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// A DB is a persistent ordered map from keys to values.</span></span><br><span class="line"><span class="comment">// A DB is safe for concurrent access from multiple threads without</span></span><br><span class="line"><span class="comment">// any external synchronization.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> DB</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 打开一个数据库，把其保存在一个堆分配的指针上，并返回状态</span></span><br><span class="line">    <span class="comment">// 这个指针需要用户手动管理</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Status <span class="title">Open</span><span class="params">(<span class="type">const</span> Options &amp;options, <span class="type">const</span> std::string &amp;name,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DB **dbptr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造析构函数等</span></span><br><span class="line">    <span class="built_in">DB</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">DB</span>(<span class="type">const</span> DB &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    DB &amp;<span class="keyword">operator</span>=(<span class="type">const</span> DB &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DB</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一条数据，这个options中会定义是否同步(即每次都是否写入磁盘)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Status <span class="title">Put</span><span class="params">(<span class="type">const</span> WriteOptions &amp;options, <span class="type">const</span> Slice &amp;key,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> Slice &amp;value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一条数据，如果key不存在不会报错</span></span><br><span class="line">    <span class="comment">// 因为删除其实也是'插入'</span></span><br><span class="line">    <span class="comment">// 同样可以定义是否同步到磁盘中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Status <span class="title">Delete</span><span class="params">(<span class="type">const</span> WriteOptions &amp;options, <span class="type">const</span> Slice &amp;key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正的写入函数，会被插入删除调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Status <span class="title">Write</span><span class="params">(<span class="type">const</span> WriteOptions &amp;options, WriteBatch *updates)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中获取一个key</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Status <span class="title">Get</span><span class="params">(<span class="type">const</span> ReadOptions &amp;options, <span class="type">const</span> Slice &amp;key,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::string *value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个堆分配的迭代器，用于迭代整个数据库</span></span><br><span class="line">    <span class="comment">// 同样需要用户手动管理内存</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Iterator *<span class="title">NewIterator</span><span class="params">(<span class="type">const</span> ReadOptions &amp;options)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前数据库状态的句柄</span></span><br><span class="line">    <span class="comment">// 使用此句柄创建的迭代器都将观察当前数据库状态的稳定快照</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> Snapshot *<span class="title">GetSnapshot</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放快照</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ReleaseSnapshot</span><span class="params">(<span class="type">const</span> Snapshot *snapshot)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DB implementations can export properties about their state</span></span><br><span class="line">    <span class="comment">// via this method.  If "property" is a valid property understood by this</span></span><br><span class="line">    <span class="comment">// DB implementation, fills "*value" with its current value and returns</span></span><br><span class="line">    <span class="comment">// true.  Otherwise returns false.</span></span><br><span class="line">    <span class="comment">// 通过这个函数，数据库能向外传递他们自身的状态信息</span></span><br><span class="line">    <span class="comment">// 前提是给定的属性(propertiy)是合法的</span></span><br><span class="line">    <span class="comment">// 有以下合法的property</span></span><br><span class="line">    <span class="comment">//  "leveldb.num-files-at-level&lt;N&gt;" - return the number of files at level &lt;N&gt;,</span></span><br><span class="line">    <span class="comment">//     where &lt;N&gt; is an ASCII representation of a level number (e.g. "0").</span></span><br><span class="line">    <span class="comment">//  "leveldb.stats" - returns a multi-line string that describes statistics</span></span><br><span class="line">    <span class="comment">//     about the internal operation of the DB.</span></span><br><span class="line">    <span class="comment">//  "leveldb.sstables" - returns a multi-line string that describes all</span></span><br><span class="line">    <span class="comment">//     of the sstables that make up the db contents.</span></span><br><span class="line">    <span class="comment">//  "leveldb.approximate-memory-usage" - returns the approximate number of</span></span><br><span class="line">    <span class="comment">//     bytes of memory in use by the DB.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">GetProperty</span><span class="params">(<span class="type">const</span> Slice &amp;property, std::string *value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小估计，其中range是key的范围</span></span><br><span class="line">    <span class="comment">// 即获取某个范围内的key-value占用系统的空间</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetApproximateSizes</span><span class="params">(<span class="type">const</span> Range *range, <span class="type">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">uint64_t</span> *sizes)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compact the underlying storage for the key range [*begin,*end].</span></span><br><span class="line">    <span class="comment">// In particular, deleted and overwritten versions are discarded,</span></span><br><span class="line">    <span class="comment">// and the data is rearranged to reduce the cost of operations</span></span><br><span class="line">    <span class="comment">// needed to access the data.  This operation should typically only</span></span><br><span class="line">    <span class="comment">// be invoked by users who understand the underlying implementation.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// begin==nullptr is treated as a key before all keys in the database.</span></span><br><span class="line">    <span class="comment">// end==nullptr is treated as a key after all keys in the database.</span></span><br><span class="line">    <span class="comment">// Therefore the following call will compact the entire database:</span></span><br><span class="line">    <span class="comment">//    db-&gt;CompactRange(nullptr, nullptr);</span></span><br><span class="line">    <span class="comment">// 将某个范围内的数据压缩，如果不是很清楚底层是怎么实现的，就不要管它</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CompactRange</span><span class="params">(<span class="type">const</span> Slice *begin, <span class="type">const</span> Slice *end)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy the contents of the specified database.</span></span><br><span class="line"><span class="comment">// Be very careful using this method.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note: For backwards compatibility, if DestroyDB is unable to list the</span></span><br><span class="line"><span class="comment">// database files, Status::OK() will still be returned masking this failure.</span></span><br><span class="line"><span class="comment">// 删除一个db</span></span><br><span class="line"><span class="function">LEVELDB_EXPORT Status <span class="title">DestroyDB</span><span class="params">(<span class="type">const</span> std::string &amp;name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> Options &amp;options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If a DB cannot be opened, you may attempt to call this method to</span></span><br><span class="line"><span class="comment">// resurrect as much of the contents of the database as possible.</span></span><br><span class="line"><span class="comment">// Some data may be lost, so be careful when calling this function</span></span><br><span class="line"><span class="comment">// on a database that contains important information.</span></span><br><span class="line"><span class="comment">// 尝试修复一个db，有些数据可能会丢失</span></span><br><span class="line"><span class="function">LEVELDB_EXPORT Status <span class="title">RepairDB</span><span class="params">(<span class="type">const</span> std::string &amp;dbname,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Options &amp;options)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看，DB基类除了提供了基本的数据接口外，还提供了一些跟底层结构相关的接口。在DB类中，插入和删除其实都是"插入"，需要通过插入数据的标志来区分。此外，我们还能创建快照，即将数据库"锁定"在某个时刻，当然不是真正的锁定，锁定之后所有的操作均不会对查询产生影响，(这个也是比较好理解的，因为levelDB中没有删除的概念，所以只需要过滤掉所有在快照之后的操作即可)</p>
<p>实际上，DB这个类中，有几个函数是有定义的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DB::Put</span><span class="params">(<span class="type">const</span> WriteOptions &amp;opt, <span class="type">const</span> Slice &amp;key, <span class="type">const</span> Slice &amp;value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    WriteBatch batch;</span><br><span class="line">    batch.<span class="built_in">Put</span>(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Write</span>(opt, &amp;batch);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DB::Delete</span><span class="params">(<span class="type">const</span> WriteOptions &amp;opt, <span class="type">const</span> Slice &amp;key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    WriteBatch batch;</span><br><span class="line">    batch.<span class="built_in">Delete</span>(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Write</span>(opt, &amp;batch);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">DB::~<span class="built_in">DB</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DB::Open</span><span class="params">(<span class="type">const</span> Options &amp;options, <span class="type">const</span> std::string &amp;dbname, DB **dbptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    *dbptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DBImpl是真正的数据库类，继承自DB</span></span><br><span class="line">    DBImpl *impl = <span class="keyword">new</span> <span class="built_in">DBImpl</span>(options, dbname);</span><br><span class="line">    <span class="comment">// 先获取锁</span></span><br><span class="line">    impl-&gt;mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    VersionEdit edit;</span><br><span class="line">    <span class="comment">// Recover handles create_if_missing, error_if_exists</span></span><br><span class="line">    <span class="type">bool</span> save_manifest = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 调用DBImpl::Recover完成MANIFEST的加载和故障恢复</span></span><br><span class="line">    Status s = impl-&gt;<span class="built_in">Recover</span>(&amp;edit, &amp;save_manifest);</span><br><span class="line">    <span class="comment">// 创建日志和相应的MemTable</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; impl-&gt;mem_ == <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Create new log and a corresponding memtable.</span></span><br><span class="line">        <span class="type">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">        WritableFile *lfile;</span><br><span class="line">        s = options.env-&gt;<span class="built_in">NewWritableFile</span>(<span class="built_in">LogFileName</span>(dbname, new_log_number),</span><br><span class="line">                                         &amp;lfile);</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            edit.<span class="built_in">SetLogNumber</span>(new_log_number);</span><br><span class="line">            impl-&gt;logfile_ = lfile;</span><br><span class="line">            impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">            impl-&gt;log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(lfile);</span><br><span class="line">            impl-&gt;mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(impl-&gt;internal_comparator_);</span><br><span class="line">            impl-&gt;mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果需要重写MANIFEST文件，那么做一个版本变更，这里面会创建一个新的MANIFEST</span></span><br><span class="line">    <span class="comment">// 将当前的版本信息写入，然后将edit的内容写入。</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; save_manifest)</span><br><span class="line">    {</span><br><span class="line">        edit.<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>); <span class="comment">// No older logs needed after recovery.</span></span><br><span class="line">        edit.<span class="built_in">SetLogNumber</span>(impl-&gt;logfile_number_);</span><br><span class="line">        s = impl-&gt;versions_-&gt;<span class="built_in">LogAndApply</span>(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        impl-&gt;<span class="built_in">RemoveObsoleteFiles</span>();</span><br><span class="line">        impl-&gt;<span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    impl-&gt;mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">assert</span>(impl-&gt;mem_ != <span class="literal">nullptr</span>);</span><br><span class="line">        *dbptr = impl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">delete</span> impl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyDB</span><span class="params">(<span class="type">const</span> std::string &amp;dbname, <span class="type">const</span> Options &amp;options)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Env *env = options.env;</span><br><span class="line">    std::vector&lt;std::string&gt; filenames;</span><br><span class="line">    Status result = env-&gt;<span class="built_in">GetChildren</span>(dbname, &amp;filenames);</span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Ignore error in case directory does not exist</span></span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    FileLock *lock;</span><br><span class="line">    <span class="type">const</span> std::string lockname = <span class="built_in">LockFileName</span>(dbname);</span><br><span class="line">    result = env-&gt;<span class="built_in">LockFile</span>(lockname, &amp;lock);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="type">uint64_t</span> number;</span><br><span class="line">        FileType type;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; filenames.<span class="built_in">size</span>(); i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ParseFileName</span>(filenames[i], &amp;number, &amp;type) &amp;&amp;</span><br><span class="line">                type != kDBLockFile)</span><br><span class="line">            { <span class="comment">// Lock file will be deleted at end</span></span><br><span class="line">                Status del = env-&gt;<span class="built_in">RemoveFile</span>(dbname + <span class="string">"/"</span> + filenames[i]);</span><br><span class="line">                <span class="keyword">if</span> (result.<span class="built_in">ok</span>() &amp;&amp; !del.<span class="built_in">ok</span>())</span><br><span class="line">                {</span><br><span class="line">                    result = del;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        env-&gt;<span class="built_in">UnlockFile</span>(lock); <span class="comment">// Ignore error since state is already gone</span></span><br><span class="line">        env-&gt;<span class="built_in">RemoveFile</span>(lockname);</span><br><span class="line">        env-&gt;<span class="built_in">RemoveDir</span>(dbname); <span class="comment">// Ignore error in case dir contains other files</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们通过这几个函数可以看到，在打开数据库时，调用DBImpl::Recover来完成主要的工作，如果调用成功，则创建MemTable和WAL相关的数据结构，重写MANIFEST文件。关于打开数据库的操作，由于涉及到了版本管理之类的东西，具体内容留到后面再讲。而插入和删除的时候都是先定义了一个WriteBatch，然后调用Write函数来把这个WriteBatch写入。</p>
<h4 id="writebatch类头文件">WriteBatch类头文件</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> WriteBatch</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 一个handler</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> Handler</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Handler</span>();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">const</span> Slice &amp;value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> Slice &amp;key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造析构函数</span></span><br><span class="line">    <span class="built_in">WriteBatch</span>();</span><br><span class="line">    ~<span class="built_in">WriteBatch</span>();</span><br><span class="line">    <span class="built_in">WriteBatch</span>(<span class="type">const</span> WriteBatch &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    WriteBatch &amp;<span class="keyword">operator</span>=(<span class="type">const</span> WriteBatch &amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入kv</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">const</span> Slice &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除kv</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> Slice &amp;key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空缓存</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 估计大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">ApproximateSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copies the operations in "source" to this batch.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This runs in O(source size) time. However, the constant factor is better</span></span><br><span class="line">    <span class="comment">// than calling Iterate() over the source batch with a Handler that replicates</span></span><br><span class="line">    <span class="comment">// the operations into this batch.</span></span><br><span class="line">    <span class="comment">// 把另一个WriteBatch添加到自身中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> WriteBatch &amp;source)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Support for iterating over the contents of a batch.</span></span><br><span class="line">    <span class="comment">// 对每个元素进行解码然后执行对应的删除与插入操作</span></span><br><span class="line">    <span class="comment">// 这个是用于批量执行时的接口</span></span><br><span class="line">    <span class="function">Status <span class="title">Iterate</span><span class="params">(Handler *handler)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WriteBatchInternal</span>; <span class="comment">// 友元类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的记录都会存储在这里</span></span><br><span class="line">    std::string rep_; <span class="comment">// See comment in write_batch.cc for the format of rep_</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>WriteBatch只是一个辅助结构，可以将多个Kv的写入按顺序累积起来，然后一次性写入提高效率(<strong>单次删除和插入调用delete/put，但是并没有真正执行，而是存储起来；而将一批数据完成相关操作时调用Iterate</strong>)。其所有的kv都会被存储在其中的字符串中，这个字符串的格式是这样的。</p>
<img src="/2022/10/24/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-14/pic1.jpg" class="">
<p>开头是12字节的头部，由fixed64的序列号和fixed32的总数组成。然后下面是变长的record，每个record由类型和前缀码编码的字符串组成(即一个变长的长度在数据之前)</p>
<p>其中sequence序列号是整个WriteBatch写入时当前的SequenceNumber，按顺序逐个赋予record，比如第一个record的SequenceNumber是sequence，第二个是sequence
+ 1，以此类推。</p>
<p>实际上，WriteBatch类本身也有两个辅助类，分别是WriteBatchInternal和MemTableInserter。其中</p>
<ul>
<li>WriteBatchInternal：定义了一些静态方法，主要用于操作WriteBatch中的那个字符串，涉及到序列号和数目，因为这两个东西被编码在一个字符串中。同时其中的InsertInto函数也负责调用WriteBatch的Iterate把当前batch的更新记录插入到memtable中。</li>
<li>MemTableInserter：这个辅助类继承自WriteBatch::Handler(内部只有put和delete方法)，负责通过WriteBatchInternal生成序列号并在操作时管理序列号，并保存memtable的指针用于插入。</li>
</ul>
<p>我们来看一下这两个辅助类</p>
<h4 id="writebatchinternal和memtableinserter类">WriteBatchInternal和MemTableInserter类</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// WriteBatchInternal类只定义了静态函数</span></span><br><span class="line"><span class="comment">// 主要用于操作序列号相关</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriteBatchInternal</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回count数目</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Count</span><span class="params">(<span class="type">const</span> WriteBatch *batch)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置count</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetCount</span><span class="params">(WriteBatch *batch, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回WriteBatch中序列号</span></span><br><span class="line">    <span class="function"><span class="type">static</span> SequenceNumber <span class="title">Sequence</span><span class="params">(<span class="type">const</span> WriteBatch *batch)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置WriteBatch的序列号</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetSequence</span><span class="params">(WriteBatch *batch, SequenceNumber seq)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回编码后的字符串</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Slice <span class="title">Contents</span><span class="params">(<span class="type">const</span> WriteBatch *batch)</span> </span>{ <span class="keyword">return</span> <span class="built_in">Slice</span>(batch-&gt;rep_); }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回编码后字符串的大小</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">ByteSize</span><span class="params">(<span class="type">const</span> WriteBatch *batch)</span> </span>{ <span class="keyword">return</span> batch-&gt;rep_.<span class="built_in">size</span>(); }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置字符串为指定的值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetContents</span><span class="params">(WriteBatch *batch, <span class="type">const</span> Slice &amp;contents)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用batch的Iterate，从而把所有的record插入到memtable中</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Status <span class="title">InsertInto</span><span class="params">(<span class="type">const</span> WriteBatch *batch, MemTable *memtable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把一个添加到另一个</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Append</span><span class="params">(WriteBatch *dst, <span class="type">const</span> WriteBatch *src)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// 又是匿名空间</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 继承自WriteBatch::Handler，重写它的put和delete方法</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MemTableInserter</span> : <span class="keyword">public</span> WriteBatch::Handler</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SequenceNumber sequence_; <span class="comment">// 管理序列号</span></span><br><span class="line">        MemTable *mem_;           <span class="comment">// memtable指针</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">const</span> Slice &amp;value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            mem_-&gt;<span class="built_in">Add</span>(sequence_, kTypeValue, key, value);</span><br><span class="line">            sequence_++;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> Slice &amp;key)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            mem_-&gt;<span class="built_in">Add</span>(sequence_, kTypeDeletion, key, <span class="built_in">Slice</span>());</span><br><span class="line">            sequence_++;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">} <span class="comment">// namespace</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两个辅助类还是很简单的，WriteBatchInternal是WriteBatch和其内部的rep_这个编码字符串的桥梁(其实感觉有点怪，明明rep_已经在其内部了，还额外需要一个外部的类来管理...)，MemTableInserter是memtable与WriteBatch的桥梁</p>
<p>理解了这两个类，我们就能愉快地看一下WriteBatch的实现了。</p>
<h4 id="writebatch的实现">WriteBatch的实现</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// writebatch的头部，由8字节序列号和4字节的计数组成</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kHeader = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些构造析构函数</span></span><br><span class="line">WriteBatch::<span class="built_in">WriteBatch</span>() { <span class="built_in">Clear</span>(); }</span><br><span class="line">WriteBatch::~<span class="built_in">WriteBatch</span>() = <span class="keyword">default</span>;</span><br><span class="line">WriteBatch::Handler::~<span class="built_in">Handler</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatch::Clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    rep_.<span class="built_in">clear</span>();</span><br><span class="line">    rep_.<span class="built_in">resize</span>(kHeader);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 估计大小的函数</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">WriteBatch::ApproximateSize</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> rep_.<span class="built_in">size</span>(); }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把编码后的条目中一个一个，并通过handler的put/delete(这个handler是MemTableInserter)</span></span><br><span class="line"><span class="comment">// 来把存储再条目中的项一个一个真正地插入到memtable中</span></span><br><span class="line"><span class="function">Status <span class="title">WriteBatch::Iterate</span><span class="params">(Handler *handler)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Slice <span class="title">input</span><span class="params">(rep_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="built_in">size</span>() &lt; kHeader)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 至少都需要12字节</span></span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"malformed WriteBatch (too small)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把头部去掉</span></span><br><span class="line">    input.<span class="built_in">remove_prefix</span>(kHeader);</span><br><span class="line">    Slice key, value;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!input.<span class="built_in">empty</span>())</span><br><span class="line">    {</span><br><span class="line">        found++;</span><br><span class="line">        <span class="type">char</span> tag = input[<span class="number">0</span>];</span><br><span class="line">        input.<span class="built_in">remove_prefix</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">switch</span> (tag)</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> kTypeValue:</span><br><span class="line">            <span class="comment">// put方法</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key) &amp;&amp;</span><br><span class="line">                <span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;value))</span><br><span class="line">            {</span><br><span class="line">                handler-&gt;<span class="built_in">Put</span>(key, value);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"bad WriteBatch Put"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">            <span class="comment">// delete方法</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key))</span><br><span class="line">            {</span><br><span class="line">                handler-&gt;<span class="built_in">Delete</span>(key);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"bad WriteBatch Delete"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"unknown WriteBatch tag"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 插入到memtable中的条目数目是否跟记录的条目数目相同</span></span><br><span class="line">    <span class="keyword">if</span> (found != WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"WriteBatch has wrong count"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// put函数，把kv编码成前缀码再插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatch::Put</span><span class="params">(<span class="type">const</span> Slice &amp;key, <span class="type">const</span> Slice &amp;value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">    rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeValue));</span><br><span class="line">    <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);</span><br><span class="line">    <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete函数，类似put，只是插入的类型不一样</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatch::Delete</span><span class="params">(<span class="type">const</span> Slice &amp;key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">    rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeDeletion));</span><br><span class="line">    <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把另一个writebatch弄到这个batch里来</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatch::Append</span><span class="params">(<span class="type">const</span> WriteBatch &amp;source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    WriteBatchInternal::<span class="built_in">Append</span>(<span class="keyword">this</span>, &amp;source);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>WriteBatch可能比较令人困惑的点就是其中的Handler类和Iterate方法了，弄懂Iterate方法中的参数就是MemTableInserter其实就不难理解了。</p>
<p>注意这里面涉及了很多的put、delete函数，我们来好好捋一捋。</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">什么类的put/delete(或指定函数)</th>
<th style="text-align: center;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">DB及其派生类</td>
<td style="text-align: center;">将一个kv插入到writebatch中，并返回writebatch</td>
</tr>
<tr class="even">
<td style="text-align: center;">writebatch</td>
<td style="text-align: center;">将一个kv编码成前缀码作为一条record插入到其条目中储存起来</td>
</tr>
<tr class="odd">
<td style="text-align: center;">MemTableInserter(继承自WriteBatch::Handler)</td>
<td style="text-align: center;">把一kv插入到memtable中(同时负责管理序列号相关)</td>
</tr>
<tr class="even">
<td style="text-align: center;">MemTableInserter::InsertInto</td>
<td style="text-align: center;">把一个writebatch中所有数据插入到memtable中</td>
</tr>
<tr class="odd">
<td style="text-align: center;">writebatch::Iterate</td>
<td style="text-align: center;">调用WriteBatch::Handler的put/delete来把writebatch的条目中的所有数据插入到WriteBatch中</td>
</tr>
</tbody>
</table>
<p><strong>到现在，我们弄清楚了怎么把一个WriteBatch插入到MemTable中，但是如何通过DB类构建出一个WriteBatch，以及，多线程之间是怎么插入的、如何调度管理WriteBatch，我们还没有弄清</strong></p>
<p>其实，这些与另外一个类有密切关系，这个类也是非常重量级的一个类，代码足足有上千行，这个类就是DBImpl，继承自DB，是数据库的真正实现。</p>
<h3 id="dbimpl类">DBImpl类</h3>
<p>这个类继承自DB类，所以可以通过DB指针来操作DBImpl类，它实现了数据库的所有功能，我们真正使用数据库时实际上也是通过这个类来实现的。它的内容非常多，主要可以分为这几类：</p>
<ul>
<li>接口管理，如PUT、DELETE等等用于提供数据库接口</li>
<li>多线程写入转换成单线程写入</li>
<li>对多个sstable进行压缩操作</li>
<li>从之前的旧版本中进行数据恢复</li>
<li>测试功能，包括对数据库进行测试的函数，一般我们不管他</li>
</ul>
<p>其中接口部分相对比较简单，但是将用于写入的数据持久化这部分的代码涉及到多线程写入，为了效能提升，需要将多线程写入转换成单线程写入。</p>
<p>我们来看一下其头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBImpl</span> : <span class="keyword">public</span> DB</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造析构函数相关</span></span><br><span class="line">    <span class="built_in">DBImpl</span>(<span class="type">const</span> Options &amp;options, <span class="type">const</span> std::string &amp;dbname);</span><br><span class="line">    <span class="built_in">DBImpl</span>(<span class="type">const</span> DBImpl &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    DBImpl &amp;<span class="keyword">operator</span>=(<span class="type">const</span> DBImpl &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">DBImpl</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DB类的接口</span></span><br><span class="line">    <span class="function">Status <span class="title">Put</span><span class="params">(<span class="type">const</span> WriteOptions &amp;, <span class="type">const</span> Slice &amp;key,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> Slice &amp;value)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">Status <span class="title">Delete</span><span class="params">(<span class="type">const</span> WriteOptions &amp;, <span class="type">const</span> Slice &amp;key)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">Status <span class="title">Write</span><span class="params">(<span class="type">const</span> WriteOptions &amp;options, WriteBatch *updates)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">Status <span class="title">Get</span><span class="params">(<span class="type">const</span> ReadOptions &amp;options, <span class="type">const</span> Slice &amp;key,</span></span></span><br><span class="line"><span class="params"><span class="function">               std::string *value)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">Iterator *<span class="title">NewIterator</span><span class="params">(<span class="type">const</span> ReadOptions &amp;)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> Snapshot *<span class="title">GetSnapshot</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReleaseSnapshot</span><span class="params">(<span class="type">const</span> Snapshot *snapshot)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetProperty</span><span class="params">(<span class="type">const</span> Slice &amp;property, std::string *value)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetApproximateSizes</span><span class="params">(<span class="type">const</span> Range *range, <span class="type">int</span> n, <span class="type">uint64_t</span> *sizes)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CompactRange</span><span class="params">(<span class="type">const</span> Slice *begin, <span class="type">const</span> Slice *end)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他的功能，用于测试，我们就不管这些了</span></span><br><span class="line">    <span class="comment">// Compact any files in the named level that overlap [*begin,*end]</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TEST_CompactRange</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> Slice *begin, <span class="type">const</span> Slice *end)</span></span>;</span><br><span class="line">    <span class="comment">// Force current memtable contents to be compacted.</span></span><br><span class="line">    <span class="function">Status <span class="title">TEST_CompactMemTable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Return an internal iterator over the current state of the database.</span></span><br><span class="line">    <span class="comment">// The keys of this iterator are internal keys (see format.h).</span></span><br><span class="line">    <span class="comment">// The returned iterator should be deleted when no longer needed.</span></span><br><span class="line">    <span class="function">Iterator *<span class="title">TEST_NewInternalIterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Return the maximum overlapping data (in bytes) at next level for any</span></span><br><span class="line">    <span class="comment">// file at a level &gt;= 1.</span></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">TEST_MaxNextLevelOverlappingBytes</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Record a sample of bytes read at the specified internal key.</span></span><br><span class="line">    <span class="comment">// Samples are taken approximately once every config::kReadBytesPeriod</span></span><br><span class="line">    <span class="comment">// bytes.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RecordReadSample</span><span class="params">(Slice key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">DB</span>;        <span class="comment">// 有点怪，继承自DB，但是把DB作为友元</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CompactionState</span>; <span class="comment">// 压缩状态</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Writer</span>;          <span class="comment">// Writer结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供手动压缩时的信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ManualCompaction</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> level;</span><br><span class="line">        <span class="type">bool</span> done;</span><br><span class="line">        <span class="type">const</span> InternalKey *begin; <span class="comment">// null means beginning of key range</span></span><br><span class="line">        <span class="type">const</span> InternalKey *end;   <span class="comment">// null means end of key range</span></span><br><span class="line">        InternalKey tmp_storage;  <span class="comment">// Used to keep track of compaction progress</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per level compaction stats.  stats_[level] stores the stats for</span></span><br><span class="line">    <span class="comment">// compactions that produced data for the specified "level".</span></span><br><span class="line">    <span class="comment">// 每一层的压缩状态，stats_[level]存储对应层的压缩信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CompactionStats</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">CompactionStats</span>() : <span class="built_in">micros</span>(<span class="number">0</span>), <span class="built_in">bytes_read</span>(<span class="number">0</span>), <span class="built_in">bytes_written</span>(<span class="number">0</span>) {}</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> CompactionStats &amp;c)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">this</span>-&gt;micros += c.micros;</span><br><span class="line">            <span class="keyword">this</span>-&gt;bytes_read += c.bytes_read;</span><br><span class="line">            <span class="keyword">this</span>-&gt;bytes_written += c.bytes_written;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int64_t</span> micros;</span><br><span class="line">        <span class="type">int64_t</span> bytes_read;</span><br><span class="line">        <span class="type">int64_t</span> bytes_written;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建InternalIterator，是一个Merger Iteator</span></span><br><span class="line">    <span class="comment">// 包含mem一个迭代器、imm一个迭代器</span></span><br><span class="line">    <span class="comment">// 同时返回了快照序列号</span></span><br><span class="line">    <span class="comment">// 是完整的db迭代器的一部分</span></span><br><span class="line">    <span class="comment">// 被this-&gt;NewIterator调用</span></span><br><span class="line">    <span class="function">Iterator *<span class="title">NewInternalIterator</span><span class="params">(<span class="type">const</span> ReadOptions &amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  SequenceNumber *latest_snapshot,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> *seed)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新DB对象</span></span><br><span class="line">    <span class="comment">// 由于这个方法是私有方法，也不是静态方法，它的作用是被this-&gt;Recover调用</span></span><br><span class="line">    <span class="comment">// 调用的条件是需要恢复的数据库不存在(所以创建一个新的)</span></span><br><span class="line">    <span class="function">Status <span class="title">NewDB</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recover the descriptor from persistent storage.  May do a significant</span></span><br><span class="line">    <span class="comment">// amount of work to recover recently logged updates.  Any changes to</span></span><br><span class="line">    <span class="comment">// be made to the descriptor are added to *edit.</span></span><br><span class="line">    <span class="comment">// 恢复一个数据库，会尝试各种方式</span></span><br><span class="line">    <span class="comment">// 实际上这个函数被DB::Open调用</span></span><br><span class="line">    <span class="function">Status <span class="title">Recover</span><span class="params">(VersionEdit *edit, <span class="type">bool</span> *save_manifest)</span></span></span><br><span class="line"><span class="function">        <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据options中的设置来是否忽略掉一部分错误</span></span><br><span class="line">    <span class="comment">// 即s中的错误如果在options中被忽略就把它设置为ok</span></span><br><span class="line">    <span class="comment">// 被this-&gt;RecoverLogFile调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MaybeIgnoreError</span><span class="params">(Status *s)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除不再需要的文件</span></span><br><span class="line">    <span class="comment">// 被DB::Open调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveObsoleteFiles</span><span class="params">()</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compact the in-memory write buffer to disk.  Switches to a new</span></span><br><span class="line">    <span class="comment">// log-file/memtable and writes a new descriptor iff successful.</span></span><br><span class="line">    <span class="comment">// Errors are recorded in bg_error_.</span></span><br><span class="line">    <span class="comment">// 合并内存中的memtable并持久化到磁盘中，同时创建一个新的memtable</span></span><br><span class="line">    <span class="comment">// 被this-&gt;DoCompactionWork和this-&gt;BackgroundCompaction调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CompactMemTable</span><span class="params">()</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从log中恢复数据</span></span><br><span class="line">    <span class="comment">// 被this-&gt;Recover调用</span></span><br><span class="line">    <span class="function">Status <span class="title">RecoverLogFile</span><span class="params">(<span class="type">uint64_t</span> log_number, <span class="type">bool</span> last_log, <span class="type">bool</span> *save_manifest,</span></span></span><br><span class="line"><span class="params"><span class="function">                          VersionEdit *edit, SequenceNumber *max_sequence)</span></span></span><br><span class="line"><span class="function">        <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把imm持久化到第0层</span></span><br><span class="line">    <span class="comment">// 被this-&gt;CompactMemTable和this-&gt;RecoverLogFile调用</span></span><br><span class="line">    <span class="function">Status <span class="title">WriteLevel0Table</span><span class="params">(MemTable *mem, VersionEdit *edit, Version *base)</span></span></span><br><span class="line"><span class="function">        <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保mem_有空间可以写入(memtable默认4mb就要被持久化了)</span></span><br><span class="line">    <span class="comment">// 被this-&gt;Write调用，保证在写入之前有足够的空间</span></span><br><span class="line">    <span class="function">Status <span class="title">MakeRoomForWrite</span><span class="params">(<span class="type">bool</span> force <span class="comment">/* compact even if there is room? */</span>)</span></span></span><br><span class="line"><span class="function">        <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="comment">// 这个函数目的是将多个线程写入转化成单个线程写入时用到的(后面具体讲)</span></span><br><span class="line">    <span class="comment">// 会将多个writebatch拼接成一个writebatch</span></span><br><span class="line">    <span class="comment">// 被this-&gt;Write调用</span></span><br><span class="line">    <span class="function">WriteBatch *<span class="title">BuildBatchGroup</span><span class="params">(Writer **last_writer)</span></span></span><br><span class="line"><span class="function">        <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有的线程报错</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RecordBackgroundError</span><span class="params">(<span class="type">const</span> Status &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它会进行一些检测，在有background compaction正在进行的过程中，</span></span><br><span class="line">    <span class="comment">// db已经关闭时以及immutable MemTable不存在，</span></span><br><span class="line">    <span class="comment">// 没有manual触发compaction和当前不需要compaction的情况下不会触发compaction，</span></span><br><span class="line">    <span class="comment">// 在不满足上述条件时触发compaction。</span></span><br><span class="line">    <span class="comment">// 其中当前是否需要compaction的判断条件是compaction score是否大于1以及有没有需要被compact的SSTable</span></span><br><span class="line">    <span class="comment">// 与compaction过程有关，读写时都会触发要不要compaction</span></span><br><span class="line">    <span class="comment">// 这几个函数都是压缩相关的，并且都是逐级调用的。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MaybeScheduleCompaction</span><span class="params">()</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BGWork</span><span class="params">(<span class="type">void</span> *db)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BackgroundCall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BackgroundCompaction</span><span class="params">()</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CleanupCompaction</span><span class="params">(CompactionState *compact)</span></span></span><br><span class="line"><span class="function">        <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="function">Status <span class="title">DoCompactionWork</span><span class="params">(CompactionState *compact)</span></span></span><br><span class="line"><span class="function">        <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是压缩相关的，涉及到打开压缩文件、完成压缩过程、应用压缩到versionEdit</span></span><br><span class="line">    <span class="function">Status <span class="title">OpenCompactionOutputFile</span><span class="params">(CompactionState *compact)</span></span>;</span><br><span class="line">    <span class="function">Status <span class="title">FinishCompactionOutputFile</span><span class="params">(CompactionState *compact, Iterator *input)</span></span>;</span><br><span class="line">    <span class="function">Status <span class="title">InstallCompactionResults</span><span class="params">(CompactionState *compact)</span></span></span><br><span class="line"><span class="function">        <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个internal比较器</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Comparator *<span class="title">user_comparator</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> internal_comparator_.<span class="built_in">user_comparator</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constant after construction</span></span><br><span class="line">    <span class="comment">// 私有成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环境配置对象</span></span><br><span class="line">    Env *<span class="type">const</span> env_;</span><br><span class="line">    <span class="comment">// InternalKey比较器和过滤策略</span></span><br><span class="line">    <span class="type">const</span> InternalKeyComparator internal_comparator_;</span><br><span class="line">    <span class="type">const</span> InternalFilterPolicy internal_filter_policy_;</span><br><span class="line">    <span class="type">const</span> Options options_; <span class="comment">// options_.comparator == &amp;internal_comparator_</span></span><br><span class="line">    <span class="comment">// 两个标志位，从options_中初始化，用于析构时是否需要释放某些内存</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> owns_info_log_;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> owns_cache_;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    <span class="type">const</span> std::string dbname_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TableCache</span></span><br><span class="line">    TableCache *<span class="type">const</span> table_cache_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁</span></span><br><span class="line">    FileLock *db_lock_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用mutex_保护的状态信息</span></span><br><span class="line">    <span class="comment">// 包含memtable、immtable、log和相关的状态信息</span></span><br><span class="line">    port::Mutex mutex_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; shutting_down_;</span><br><span class="line">    <span class="function">port::CondVar background_work_finished_signal_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    MemTable *mem_;</span><br><span class="line">    <span class="function">MemTable *imm_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>; <span class="comment">// Memtable being compacted</span></span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; has_imm_;        <span class="comment">// So bg thread can detect non-null imm_</span></span><br><span class="line">    WritableFile *logfile_;</span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> logfile_number_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    log::Writer *log_;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> seed_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>; <span class="comment">// For sampling.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入队列，这个涉及到写入相关</span></span><br><span class="line">    <span class="comment">// 会将多线程写入转换成单线程写入(后面细锁)</span></span><br><span class="line">    <span class="function">std::deque&lt;Writer *&gt; writers_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="function">WriteBatch *tmp_batch_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快照列表</span></span><br><span class="line">    <span class="function">SnapshotList snapshots_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待compact的文件列表，保护以防误删</span></span><br><span class="line">    <span class="function">std::set&lt;<span class="type">uint64_t</span>&gt; pending_outputs_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后台压缩是否正在被调度或者运行的一个标志位</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> background_compaction_scheduled_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动压缩结构体</span></span><br><span class="line">    <span class="comment">// 这个结构体也是位于本类private中</span></span><br><span class="line">    <span class="function">ManualCompaction *manual_compaction_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本集合，是一个双向链表，用于版本管理</span></span><br><span class="line">    <span class="function">VersionSet *<span class="type">const</span> versions_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否后台出错</span></span><br><span class="line">    <span class="function">Status bg_error_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩信息，这个结构体也是位于本类的private中</span></span><br><span class="line">    <span class="comment">// 每一层的压缩状态，stats_[level]存储对应层的压缩信息</span></span><br><span class="line">    CompactionStats stats_[config::kNumLevels] <span class="built_in">GUARDED_BY</span>(mutex_);</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>头文件可以说是相当的长，不过从头文件中我们也能看出一个数据库的大致功能了。能够给我们使用的一些接口其实并不算多，主要就是数据的写入和删除，其他的东西levelDB会自动帮我们管理。剩下一些接口主要是迭代、快照、压缩管理之类一些比较高级的操作。</p>
<p>我们先来关注一下写入部分</p>
<h3 id="db_impl的写入">DB_Impl的写入</h3>
<p>向数据的写入在levelDB中包含两个部分，涉及到插入一个kv的写入和删除一个kv的写入。通过查看Put和Delete的源码可知，DB_Impl调用的是DB的Put和Delete函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DB::Put</span><span class="params">(<span class="type">const</span> WriteOptions &amp;opt, <span class="type">const</span> Slice &amp;key, <span class="type">const</span> Slice &amp;value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    WriteBatch batch;</span><br><span class="line">    batch.<span class="built_in">Put</span>(key, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Write</span>(opt, &amp;batch);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DB::Delete</span><span class="params">(<span class="type">const</span> WriteOptions &amp;opt, <span class="type">const</span> Slice &amp;key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    WriteBatch batch;</span><br><span class="line">    batch.<span class="built_in">Delete</span>(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Write</span>(opt, &amp;batch);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>都是先生成一个WriteBatch，然后再调用this-&gt;Write函数，并且这个Write函数也是一个公有接口，所以我们主要来关注一下这个Write函数。</p>
<p>我们回想一下之前讲述的写入过程：先写入wal，然后写入memtable。并且写入过程中，如果MemTable太大会触发MemTable写入到SSTable，当然还涉及到一些具体的实现细节，我们看完源码后再说。</p>
<p>Write函数也是按照这个步骤来实现的。不过，由于levelDB是多线程的，为了实现线程安全，每个线程在写入时，都需要获取锁，但是这样会阻塞其它的线程，降低并发度。针对这个问题LevelDB做了一个优化，写入时当获取锁后，会将WriteBatch放入到一个<code>std::deque&lt;Writer\*&gt; DBImpl::writers_</code>里，然后会检查writers_里的第一个元素是不是自己，如果不是的话，就会释放锁。当一个线程检查到writers_头元素是自己时，会再次获取锁，然后将writers_里的数据尽可能多的写入。一次写入会涉及到写日志，占时间比较长，一个线程的数据可能被其它线程批量写入进去了，减少了等待。</p>
<p>总结来说，一个线程的写入有两种情况：一种是恰好自己是头结点，自己写入，另外一种是别的线程帮助自己写入了，自己会检查到写入，然后就可以返回了。</p>
<p>我们来详细看一下Write函数的实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 用来封装一个WriteBatch，用来标识状态</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DBImpl</span>::Writer</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(port::Mutex *mu)</span></span></span><br><span class="line"><span class="function">        : batch(nullptr), sync(false), done(false), cv(mu) {</span>}</span><br><span class="line"></span><br><span class="line">    Status status;</span><br><span class="line">    WriteBatch *batch;</span><br><span class="line">    <span class="type">bool</span> sync;</span><br><span class="line">    <span class="type">bool</span> done;</span><br><span class="line">    port::CondVar cv;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="type">const</span> WriteOptions &amp;options, WriteBatch *updates)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 构造一个writer结构体，插入到wrtiers_里，注意插入前需要先获取锁</span></span><br><span class="line">    <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    w.batch = updates;</span><br><span class="line">    w.sync = options.sync;</span><br><span class="line">    w.done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    writers_.<span class="built_in">push_back</span>(&amp;w);</span><br><span class="line">    <span class="comment">// 检查done判断是否完成，或者自己是否是writers_队列里的第一个成员。</span></span><br><span class="line">    <span class="comment">// 有可能其它线程写入时把自己的内容也写入了，</span></span><br><span class="line">    <span class="comment">// 这样自己就是done，或者当自己是头元素了，表示轮到自己写入了</span></span><br><span class="line">    <span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.<span class="built_in">front</span>())</span><br><span class="line">    {</span><br><span class="line">        w.cv.<span class="built_in">Wait</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (w.done)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> w.status;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果是非头结点，则至此，其内容已经被头结点写入了</span></span><br><span class="line">    <span class="comment">// 下面的所有函数都是针对头结点而言的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// May temporarily unlock and wait.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查一下memtable中是否有足够的空间</span></span><br><span class="line">    <span class="comment">// 同时获取到最新的序列号</span></span><br><span class="line">    <span class="comment">// 注意MakeRoomForWrite函数中如果发现写入太快，会进行休眠限流</span></span><br><span class="line">    Status status = <span class="built_in">MakeRoomForWrite</span>(updates == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">uint64_t</span> last_sequence = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">    Writer *last_writer = &amp;w;</span><br><span class="line">    <span class="comment">// 已经完成写入的准备工作</span></span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; updates != <span class="literal">nullptr</span>)</span><br><span class="line">    { <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">        <span class="comment">// 调用这个函数来将队列中的多个batch组合成一个batch</span></span><br><span class="line">        <span class="comment">// 并为这个batch设置好序列号</span></span><br><span class="line">        WriteBatch *write_batch = <span class="built_in">BuildBatchGroup</span>(&amp;last_writer);</span><br><span class="line">        WriteBatchInternal::<span class="built_in">SetSequence</span>(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">        last_sequence += WriteBatchInternal::<span class="built_in">Count</span>(write_batch);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面是正式的写入，会写入log和memtable</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 注意这一步解锁，很关键，因为接下来的写入可能是一个费时的过程</span></span><br><span class="line">            <span class="comment">// 解锁后，其它线程可以Get，其它线程也可以继续将writer</span></span><br><span class="line">            <span class="comment">// 插入到writers_里面，但是插入后，因为不是头元素，会等待，所以不会冲突</span></span><br><span class="line">            mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">            status = log_-&gt;<span class="built_in">AddRecord</span>(WriteBatchInternal::<span class="built_in">Contents</span>(write_batch));</span><br><span class="line">            <span class="type">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; options.sync)</span><br><span class="line">            {</span><br><span class="line">                status = logfile_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">                <span class="keyword">if</span> (!status.<span class="built_in">ok</span>())</span><br><span class="line">                {</span><br><span class="line">                    sync_error = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 然后写入到memtable中</span></span><br><span class="line">            <span class="keyword">if</span> (status.<span class="built_in">ok</span>())</span><br><span class="line">            {</span><br><span class="line">                status = WriteBatchInternal::<span class="built_in">InsertInto</span>(write_batch, mem_);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁需要修改全局的SequenceNumber以及writers_</span></span><br><span class="line">            mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (sync_error)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// The state of the log file is indeterminate: the log record we</span></span><br><span class="line">                <span class="comment">// just added may or may not show up when the DB is re-opened.</span></span><br><span class="line">                <span class="comment">// So we force the DB into a mode where all future writes fail.</span></span><br><span class="line">                <span class="comment">// RecordBackgroundError会将错误记录到 bg_error_ 字段中</span></span><br><span class="line">                <span class="comment">// 并唤醒 background_work_finished_signal_ 用于向后台任务周知此错误</span></span><br><span class="line">                <span class="comment">// 想说明的是：刚才写入到log中的数据在下一次db重新打开时可能不会出现</span></span><br><span class="line">                <span class="comment">// 所以让数据库所有的后续写入都失败</span></span><br><span class="line">                <span class="built_in">RecordBackgroundError</span>(status);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 正常情况下tmp_batch_就是write_batch</span></span><br><span class="line">        <span class="comment">// 因为BuildBatchGroup中tmp_batch_被设置成result，同时返回值也是result(这是指针)</span></span><br><span class="line">        <span class="keyword">if</span> (write_batch == tmp_batch_)</span><br><span class="line">            tmp_batch_-&gt;<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新序列号</span></span><br><span class="line">        versions_-&gt;<span class="built_in">SetLastSequence</span>(last_sequence);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从writers_队列从头开始，将写入完成的writer标识成done，并且弹出，通知这些writer</span></span><br><span class="line">    <span class="comment">// 这样这些writer的线程会被唤醒，发现自己的写入已经完成了，就会返回</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        Writer *ready = writers_.<span class="built_in">front</span>();</span><br><span class="line">        writers_.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (ready != &amp;w)</span><br><span class="line">        {</span><br><span class="line">            ready-&gt;status = status;</span><br><span class="line">            ready-&gt;done = <span class="literal">true</span>;</span><br><span class="line">            ready-&gt;cv.<span class="built_in">Signal</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ready == last_writer)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果writers_里还有元素，就通知头元素，让它可以进来开始写入</span></span><br><span class="line">    <span class="keyword">if</span> (!writers_.<span class="built_in">empty</span>())</span><br><span class="line">    {</span><br><span class="line">        writers_.<span class="built_in">front</span>()-&gt;cv.<span class="built_in">Signal</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Write函数的过程为：先获取锁，同时把batch插入到write_中，检测头结点是不是自己以及队列中的batch是否插入完成了，如果都没有则进入等待中并释放锁。反之，则先将若干个batch打包成一个大的batch，然后按照先写入wal再写入memtable的顺序完成写入。在写入期间锁会被解开，其他线程可以往write_中插入batch。写入完成后重新上锁，更新序列号并从write_中删除写入的部分。随后唤醒新的write_中的头线程(如果有的话)。同样的来看一下这个函数的流程图。</p>
<img src="/2022/10/24/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-14/pic2.jpg" class="">
<p>多个线程想要写入的时候，先把需要写入的batch加入到队列中，但是这些线程之间会相互竞争<strong>需要注意的是，仅有某个线程正在写入或没有线程获取锁的时候，才能有线程插入到write_中</strong>。</p>
<p>假设线程是t1-t5，然后write_队列中的竞争结果为t2、t1、t3，那么此时只有t2线程会执行，剩余的线程会被锁住，t2线程会把t2、t1、t3这几个batch一起打包成一个大的batch，然后插入到log和memtable中，在持久化过程中，t4、t5又会把对应的batch插入到write_中，那么此时的write_为t2、t1、t3、t4、t5，等到t2持久化完成后，会把t2、t1、t3标记为已插入并从队列中移除，随后通知t4进行插入。这样就利用了磁盘写的长IO耗时，有效地增加了效率。过程如图。</p>
<img src="/2022/10/24/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-14/pic3.png" class="">
<h4 id="写入过程中的限流策略">写入过程中的限流策略</h4>
<p>我们上述对write的描述其实忽略了一部分细节。比如：memtable达到了最大的空间限制怎么办？immemtable仍然存在的时候memtable写满了怎么办？level0层块太多怎么办？</p>
<p>这部分问题在Write函数中具体的体现其实就是MakeRoomForWrite和BuildBatchGroup这两个函数。我们来看一下这两个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// REQUIRES: mutex_ is held</span></span><br><span class="line"><span class="comment">// REQUIRES: this thread is currently at the front of the writer queue</span></span><br><span class="line"><span class="comment">// 需要保证锁住，且此函数需要被write_中第一个结点对用的线程调用</span></span><br><span class="line"><span class="comment">// 作用是为写入提供准备，包括限流等策略</span></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::MakeRoomForWrite</span><span class="params">(<span class="type">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">    <span class="built_in">assert</span>(!writers_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="type">bool</span> allow_delay = !force;</span><br><span class="line">    Status s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Yield previous error</span></span><br><span class="line">            s = bg_error_;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;<span class="built_in">NumLevelFiles</span>(<span class="number">0</span>) &gt;=</span><br><span class="line">                                    config::kL0_SlowdownWritesTrigger)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// We are getting close to hitting a hard limit on the number of</span></span><br><span class="line">            <span class="comment">// L0 files.  Rather than delaying a single write by several</span></span><br><span class="line">            <span class="comment">// seconds when we hit the hard limit, start delaying each</span></span><br><span class="line">            <span class="comment">// individual write by 1ms to reduce latency variance.  Also,</span></span><br><span class="line">            <span class="comment">// this delay hands over some CPU to the compaction thread in</span></span><br><span class="line">            <span class="comment">// case it is sharing the same core as the writer.</span></span><br><span class="line">            <span class="comment">// 如果第0层数目超过限制(默认8)，就会sleep 1ms，并在此期间解开锁</span></span><br><span class="line">            <span class="comment">// 这有助于压缩线程工作</span></span><br><span class="line">            <span class="comment">// 并且此限流策略只会执行一次</span></span><br><span class="line">            mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">            env_-&gt;<span class="built_in">SleepForMicroseconds</span>(<span class="number">1000</span>);</span><br><span class="line">            allow_delay = <span class="literal">false</span>; <span class="comment">// Do not delay a single write more than once</span></span><br><span class="line">            mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!force &amp;&amp;</span><br><span class="line">                 (mem_-&gt;<span class="built_in">ApproximateMemoryUsage</span>() &lt;= options_.write_buffer_size))</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// There is room in current memtable</span></span><br><span class="line">            <span class="comment">// 如果memtable有空间，就直接返回，此时保证了memtable有空间可以写入</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// We have filled up the current memtable, but the previous</span></span><br><span class="line">            <span class="comment">// one is still being compacted, so we wait.</span></span><br><span class="line">            <span class="comment">// 如果memtable没有空间，且immemtable存在</span></span><br><span class="line">            <span class="comment">// 即之前转换的immemtable存在，就一直等，直到上一次的immemtable被持久化</span></span><br><span class="line">            <span class="built_in">Log</span>(options_.info_log, <span class="string">"Current memtable full; waiting...\n"</span>);</span><br><span class="line">            background_work_finished_signal_.<span class="built_in">Wait</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (versions_-&gt;<span class="built_in">NumLevelFiles</span>(<span class="number">0</span>) &gt;= config::kL0_StopWritesTrigger)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// There are too many level-0 files.</span></span><br><span class="line">            <span class="comment">// 如果第0层数目太多(默认12)，就一直等待，直到满足条件</span></span><br><span class="line">            <span class="built_in">Log</span>(options_.info_log, <span class="string">"Too many L0 files; waiting...\n"</span>);</span><br><span class="line">            background_work_finished_signal_.<span class="built_in">Wait</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 否则就尝试将一个memtable转换成immemtable来写入</span></span><br><span class="line">            <span class="comment">// 同时还需要创建一个新的memtable</span></span><br><span class="line">            <span class="comment">// 还要触发压缩线程</span></span><br><span class="line">            <span class="comment">// Attempt to switch to a new memtable and trigger compaction of old</span></span><br><span class="line">            <span class="built_in">assert</span>(versions_-&gt;<span class="built_in">PrevLogNumber</span>() == <span class="number">0</span>);</span><br><span class="line">            <span class="type">uint64_t</span> new_log_number = versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">            WritableFile *lfile = <span class="literal">nullptr</span>;</span><br><span class="line">            s = env_-&gt;<span class="built_in">NewWritableFile</span>(<span class="built_in">LogFileName</span>(dbname_, new_log_number), &amp;lfile);</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">ok</span>())</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// Avoid chewing through file number space in a tight loop.</span></span><br><span class="line">                versions_-&gt;<span class="built_in">ReuseFileNumber</span>(new_log_number);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">delete</span> log_;</span><br><span class="line">            <span class="keyword">delete</span> logfile_;</span><br><span class="line">            logfile_ = lfile;</span><br><span class="line">            logfile_number_ = new_log_number;</span><br><span class="line">            log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(lfile);</span><br><span class="line">            imm_ = mem_;</span><br><span class="line">            has_imm_.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">            mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_);</span><br><span class="line">            mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">            force = <span class="literal">false</span>; <span class="comment">// Do not force another compaction if have room</span></span><br><span class="line">            <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// REQUIRES: Writer list must be non-empty</span></span><br><span class="line"><span class="comment">// REQUIRES: First writer must have a non-null batch</span></span><br><span class="line"><span class="comment">// 需要保证write_队列非空，且队列中第一个batch也是非空的</span></span><br><span class="line"><span class="function">WriteBatch *<span class="title">DBImpl::BuildBatchGroup</span><span class="params">(Writer **last_writer)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">    <span class="built_in">assert</span>(!writers_.<span class="built_in">empty</span>());</span><br><span class="line">    Writer *first = writers_.<span class="built_in">front</span>();</span><br><span class="line">    WriteBatch *result = first-&gt;batch;</span><br><span class="line">    <span class="built_in">assert</span>(result != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先计算出一个max_size，表示构造的WriterBatch的最大尺寸</span></span><br><span class="line">    <span class="type">size_t</span> size = WriteBatchInternal::<span class="built_in">ByteSize</span>(first-&gt;batch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow the group to grow up to a maximum size, but if the</span></span><br><span class="line">    <span class="comment">// original write is small, limit the growth so we do not slow</span></span><br><span class="line">    <span class="comment">// down the small write too much.</span></span><br><span class="line">    <span class="type">size_t</span> max_size = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= (<span class="number">128</span> &lt;&lt; <span class="number">10</span>))</span><br><span class="line">    {</span><br><span class="line">        max_size = size + (<span class="number">128</span> &lt;&lt; <span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后开始扫描writers_数组，直到满足WriterBatch超过max_size</span></span><br><span class="line">    <span class="comment">// 或者碰到一个与当前batch的sync不匹配的就结束</span></span><br><span class="line">    *last_writer = first;</span><br><span class="line">    std::deque&lt;Writer *&gt;::iterator iter = writers_.<span class="built_in">begin</span>();</span><br><span class="line">    ++iter; <span class="comment">// Advance past "first"</span></span><br><span class="line">    <span class="keyword">for</span> (; iter != writers_.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    {</span><br><span class="line">        Writer *w = *iter;</span><br><span class="line">        <span class="keyword">if</span> (w-&gt;sync &amp;&amp; !first-&gt;sync)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Do not include a sync write into a batch handled by a non-sync write.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (w-&gt;batch != <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            size += WriteBatchInternal::<span class="built_in">ByteSize</span>(w-&gt;batch);</span><br><span class="line">            <span class="keyword">if</span> (size &gt; max_size)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// Do not make batch too big</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Append to *result</span></span><br><span class="line">            <span class="keyword">if</span> (result == first-&gt;batch)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// Switch to temporary batch instead of disturbing caller's batch</span></span><br><span class="line">                result = tmp_batch_;</span><br><span class="line">                <span class="built_in">assert</span>(WriteBatchInternal::<span class="built_in">Count</span>(result) == <span class="number">0</span>);</span><br><span class="line">                WriteBatchInternal::<span class="built_in">Append</span>(result, first-&gt;batch);</span><br><span class="line">            }</span><br><span class="line">            WriteBatchInternal::<span class="built_in">Append</span>(result, w-&gt;batch);</span><br><span class="line">        }</span><br><span class="line">        *last_writer = w;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先说MakeRoomForWrite，它主要是限流和触发后台线程等工作：</p>
<ul>
<li>首先判断Level 0的文件是否&gt;=8，是的话就sleep
1ms，这里是限流的作用，Level
0的文件太多，说明写入太快，Compaction跟不上写入的速度，而在读取的时候Level
0的文件之间可能有重叠，所以太多的话，影响读取的效率，这算是比较轻微的限流，最多sleep一次</li>
<li>接下来判断MemTable里是否有空间，有空间的话就可以返回了，写入就可以继续</li>
<li>如果MemTable没有空间，判断Immutable
MemTable是否存在，存在的话，说明上一次写满的MemTable还没有完成写入到SSTable中，说明写入太快了，需要等待Immutable
MemTable写入完成</li>
<li>再判断Level
0的文件数是否&gt;=12，如果太大，说明写入太快了，需要等待Compaction的完成</li>
<li>到这一步说明可以写入，但是MemTable已经写满了，需要将MemTable变成Immutable
MemTable，生成一个新的MemTable，触发后台线程写入到SSTable中</li>
</ul>
<img src="/2022/10/24/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-14/pic4.jpg" class="">
<p>然后来说一下BuildBatchGroup，这个函数的作用是将多个位于write_队列中的batch合并成一个更大的batch用于写入，它会从writers_头部开始扫描，将尽可能多的writer生成一个新的WriterBatch，将这些writer的内容批量写入。步骤如下：</p>
<ul>
<li>首先计算出一个max_size，表示构造的WriterBatch的最大尺寸；</li>
<li>然后开始扫描writers_数组，直到满足WriterBatch超过max_size</li>
<li>另外，<strong>第一个writer的sync决定了这整个write是不是sync的</strong>，如果第一个writer不是sync的，碰到一个sync的writer，表面这个writer无法加入到这个批量写入中，所以扫描就结束了</li>
</ul>
<h3 id="db_impl的读取">DB_Impl的读取</h3>
<p>了解写入后，再来说读取，LSM
Tree里面，读取往往比写入更复杂，写入往往只涉及一次磁盘IO，但是读取可能涉及多次磁盘IO。</p>
<p>LevelDB的数据可能存在三个地方:</p>
<ul>
<li>最新的写入在MemTable里</li>
<li>如果上一次MemTable写满后，转换为Immutable
MemTable，如果还没有完成写入到SSTable里，那么就有可能存在于Immutable
MemTable里</li>
<li>存在于SSTable里，SSTable里的数据从Level
0开始从新变旧，Level越低，数据越新。Level
0里的SSTable比较特殊，因为是MemTable转换过来的，虽然每个SSTable都是有序的，但是每个SSTable的键的范围可能有重叠，也就是一个键可能存在于多个SSTable里，文件名下标越大的SSTable里的键越新。而非level
0的SSTable，都是后台生成的，保证了SSTable之间的数据无重叠，一个键只有可能存在于一个SSTable里</li>
</ul>
<p>所以读取一个键时：</p>
<ul>
<li>先读取MemTable，存在就读到数据了；</li>
<li>不存在的话，看看Immutable
MemTable是否存在，存在的话，读取数据；</li>
<li>否则，从SSTable的Level 0开始读取，如果Level 0还没有找到话，读Level
1，以此类推，直到读到最高层。</li>
</ul>
<p><strong>另外，别忘了，levelDB是有缓存的，在读取的时候还要查找缓存。写入的话可以把memtable理解成缓存</strong></p>
<h4 id="dbimplget">DBImpl::Get</h4>
<p>先来看一下DBImpl中的Get实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::Get</span><span class="params">(<span class="type">const</span> ReadOptions &amp;options, <span class="type">const</span> Slice &amp;key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::string *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Status s;</span><br><span class="line">    <span class="comment">// 加锁，读取元数据，增加引用</span></span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定snapshot，其实就是一个SequenceNumber，这是实现Snapshot的关键，设置成选项中的snapshot，或者</span></span><br><span class="line">    <span class="comment">// 当前最近的SequenceNumber</span></span><br><span class="line">    SequenceNumber snapshot;</span><br><span class="line">    <span class="keyword">if</span> (options.snapshot != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        snapshot =</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> SnapshotImpl *&gt;(options.snapshot)-&gt;<span class="built_in">sequence_number</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        snapshot = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mem是MemTable，imm是Immutable MemTable，</span></span><br><span class="line">    <span class="comment">// SSTable则由当前的version代表，一个version包含了当前版本的SSTable的集合</span></span><br><span class="line">    MemTable *mem = mem_;</span><br><span class="line">    MemTable *imm = imm_;</span><br><span class="line">    Version *current = versions_-&gt;<span class="built_in">current</span>();</span><br><span class="line">    <span class="comment">// 这里都调用了Ref，LevelDB里大量使用了这种引用计数的方式管理对象，这里表示读取需要引用这些对象，假设在读取过程</span></span><br><span class="line">    <span class="comment">// 中其他线程发生了MemTable写满了，或者Immutable MemTable写入完成了需要删除了，或者做了一次Compaction，生</span></span><br><span class="line">    <span class="comment">// 成了新的Version，所引用的SSTable不再有效了，这些都需要对这些对象做一些改变，比如删除等，但是当前线程还引用着</span></span><br><span class="line">    <span class="comment">// 这些对象，所以这些对象还不能被删除。采用引用计数，其它线程删除对象时只是简单的Unref，因为当前线程还引用着这些</span></span><br><span class="line">    <span class="comment">// 对象，所以计数&gt;=1，这些对象不会被删除，而当读取结束，调用Unref时，如果对象的计数是0，那么对象会被删除。</span></span><br><span class="line">    mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>)</span><br><span class="line">        imm-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    current-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">    Version::GetStats stats;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际读取时解锁</span></span><br><span class="line">    {</span><br><span class="line">        mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">        <span class="comment">// 构造一个Lookup Key搜索MemTable</span></span><br><span class="line">        <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (mem-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s))</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 找到了</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 然后查找imm中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s))</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 找到</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 然后需要从当前的sstable集合中查找</span></span><br><span class="line">            s = current-&gt;<span class="built_in">Get</span>(options, lkey, value, &amp;stats);</span><br><span class="line">            have_stat_update = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;<span class="built_in">UpdateStats</span>(stats))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 表示由于某个文件seek次数过多需要合并</span></span><br><span class="line">        <span class="comment">// 合并条件是在sstable中找到了key，但是不止在一个sstable中找到(后面细锁)</span></span><br><span class="line">        <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">    }</span><br><span class="line">    mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">    <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>)</span><br><span class="line">        imm-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">    current-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DBImpl中Get其实就是简单地从memtable、immemtable和所有sstable的集合中查找key，由于memtable、immemtable均为跳表，所以需要用lookupkey来查找。另外，由于levelDB把所有sstable看作是一个版本(这个后面重点会讲，版本管理也是非常多的代码)，所以<code>current-&gt;Get</code>这个本质上也是从sstable中查找，这时候要用到internalkey。</p>
<p>还有一个比较值得注意的地方就是调用MaybeScheduleCompaction函数，可能会令人困惑。它的目的是对sstable进行压缩清理，此处不展开。</p>
<p><del>由于levelDB本质上没有delete
key的说法，所以多次对于一个key的修改啥的都会保留，只是通过序列号来判断哪个是最新的。而key在多个sstable中被查到，说明此key存在多次修改，不如将他合并成一个sstable，这样会带来性能上的提升(合并的话就删除掉一些sstable，然后生成一个大的sstable)
<strong>此处有错误</strong></del></p>
<p>启用压缩的条件是：存在一个sstable多次未命中数据。这样做可以把这个sstable压缩至更高层，以减少该sstable的读取次数。</p>
<p><strong>但实际上，读写操作都会调用MaybeScheduleCompaction函数，这个函数可能会启动压缩。其中读在Get中调用，写则是在MakeRoomForWrite中调用</strong></p>
<p>由于memtable的查找本质上就是跳表的查找，比较简单，就不赘述了。</p>
<h4 id="versionget">Version::Get</h4>
<p>我们来看看SSTable的读取，version保存了SSTable，是一个分层的SSTable的集合，这其实就是LevelDB名字的由来。</p>
<p>version里SSTable的集合有以下特点：</p>
<ul>
<li>数据从Level
0开始由新变旧，所以最新的数据在最低层，也就是如果一个键有多个值的话，新的肯定在低层，旧的在高层</li>
<li>因为 Level 0里的SSTable是MemTable 写入的，Level
0里的每个SSTable的键之间可能有重叠，所以一个键可能存在于多个SSTable里</li>
<li>而其它Level，SSTable都是Compaction产生的，键没有重叠，一个键只有可能存在于一个SSTable里</li>
<li>对于Level 0的SSTable，文件编号越大的，里面的键越新</li>
</ul>
<img src="/2022/10/24/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-14/pic5.jpg" class="">
<p>如图，红色是需要读取的SSTable，当读取时，Level
0可能有多个SSTable需要读取，而其它Level最多只有一个SSTable需要读取。</p>
<p>关于Version我们后面具体讲这个重量级的东西。先简单看一下，一个SSTable在内存里使用FileMetaData来表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// db/version_edit.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FileMetaData</span> {</span><br><span class="line">  <span class="built_in">FileMetaData</span>() : <span class="built_in">refs</span>(<span class="number">0</span>), <span class="built_in">allowed_seeks</span>(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="built_in">file_size</span>(<span class="number">0</span>) {}</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> refs;</span><br><span class="line">  <span class="type">int</span> allowed_seeks;     <span class="comment">// 判断什么时候可以Compaction</span></span><br><span class="line">  <span class="type">uint64_t</span> number;       <span class="comment">// 文件编号</span></span><br><span class="line">  <span class="type">uint64_t</span> file_size;    <span class="comment">// 文件大小bytes</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// 这个SSTable里最小的Internal Key</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// 这个SSTable里最大的Internal Key</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::vector&lt;FileMetaData*&gt; Version::files_[config::kNumLevels];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到每个FileMetaData都有一个键的范围，所以在读取时可以快速判断键是否可能在这个SSTable里，这样就可以选出相应的键。</p>
<p>而一个Version里的SSTable保存在一个vector数组里，每一个Level对应一个vector，每个vector保存了FileMetaData，对于非Level
0，这些FileMetaData是有序的，也就是第n个SSTable的最大键小于第n +
1个SSTable的最小键，所以可以通过二分搜索找到某个键位于哪个SSTable，但是level
0层的sstable是memtable的副本，所以key上会有重叠。</p>
<p>我们来看一下其查找的源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Version::Get</span><span class="params">(<span class="type">const</span> ReadOptions &amp;options, <span class="type">const</span> LookupKey &amp;k,</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::string *value, GetStats *stats)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stats-&gt;seek_file = <span class="literal">nullptr</span>;</span><br><span class="line">    stats-&gt;seek_file_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述查询状态的结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">State</span></span><br><span class="line">    {</span><br><span class="line">        Saver saver;</span><br><span class="line">        GetStats *stats;</span><br><span class="line">        <span class="type">const</span> ReadOptions *options;</span><br><span class="line">        Slice ikey;</span><br><span class="line">        FileMetaData *last_file_read;</span><br><span class="line">        <span class="type">int</span> last_file_read_level;</span><br><span class="line"></span><br><span class="line">        VersionSet *vset;</span><br><span class="line">        Status s;</span><br><span class="line">        <span class="type">bool</span> found;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个函数的作用是在第level层的f中查找key</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Match</span><span class="params">(<span class="type">void</span> *arg, <span class="type">int</span> level, FileMetaData *f)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            State *state = <span class="built_in">reinterpret_cast</span>&lt;State *&gt;(arg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">                state-&gt;last_file_read != <span class="literal">nullptr</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">                state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">                state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            state-&gt;last_file_read = f;</span><br><span class="line">            state-&gt;last_file_read_level = level;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从缓存中获取sstable</span></span><br><span class="line">            state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;<span class="built_in">Get</span>(*state-&gt;options, f-&gt;number,</span><br><span class="line">                                                      f-&gt;file_size, state-&gt;ikey,</span><br><span class="line">                                                      &amp;state-&gt;saver, SaveValue);</span><br><span class="line">            <span class="comment">// 从sstable中查找</span></span><br><span class="line">            <span class="keyword">if</span> (!state-&gt;s.<span class="built_in">ok</span>())</span><br><span class="line">            {</span><br><span class="line">                state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">switch</span> (state-&gt;saver.state)</span><br><span class="line">            {</span><br><span class="line">            <span class="keyword">case</span> kNotFound:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// Keep searching in other files</span></span><br><span class="line">            <span class="keyword">case</span> kFound:</span><br><span class="line">                state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> kDeleted:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> kCorrupt:</span><br><span class="line">                state-&gt;s =</span><br><span class="line">                    Status::<span class="built_in">Corruption</span>(<span class="string">"corrupted key for "</span>, state-&gt;saver.user_key);</span><br><span class="line">                state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Not reached. Added to avoid false compilation warnings of</span></span><br><span class="line">            <span class="comment">// "control reaches end of non-void function".</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    State state;</span><br><span class="line">    state.found = <span class="literal">false</span>;</span><br><span class="line">    state.stats = stats;</span><br><span class="line">    state.last_file_read = <span class="literal">nullptr</span>;</span><br><span class="line">    state.last_file_read_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    state.options = &amp;options;</span><br><span class="line">    state.ikey = k.<span class="built_in">internal_key</span>();</span><br><span class="line">    state.vset = vset_;</span><br><span class="line"></span><br><span class="line">    state.saver.state = kNotFound;</span><br><span class="line">    state.saver.ucmp = vset_-&gt;icmp_.<span class="built_in">user_comparator</span>();</span><br><span class="line">    state.saver.user_key = k.<span class="built_in">user_key</span>();</span><br><span class="line">    state.saver.value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试找到对应的key</span></span><br><span class="line">    <span class="built_in">ForEachOverlapping</span>(state.saver.user_key, state.ikey, &amp;state, &amp;State::Match);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> state.found ? state.s : Status::<span class="built_in">NotFound</span>(<span class="built_in">Slice</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从所有sstable中逐层查找，直到找到</span></span><br><span class="line"><span class="comment">// 其中arg是state结构体</span></span><br><span class="line"><span class="comment">// func是在state中查找sstable的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Version::ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key, <span class="type">void</span> *arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">bool</span> (*func)(<span class="type">void</span> *, <span class="type">int</span>, FileMetaData *))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> Comparator *ucmp = vset_-&gt;icmp_.<span class="built_in">user_comparator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第0层的key存在重叠，所以每个都要查找</span></span><br><span class="line">    std::vector&lt;FileMetaData *&gt; tmp;</span><br><span class="line">    <span class="comment">// 这里是直接对数组扩容，因为我们已经知道大小了，就不要让他自动扩容了</span></span><br><span class="line">    tmp.<span class="built_in">reserve</span>(files_[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历查找所有可能符合的key范围的sstable</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 遍历第0层所有files</span></span><br><span class="line">        FileMetaData *f = files_[<span class="number">0</span>][i];</span><br><span class="line">        <span class="comment">// 如果查找的key就在某一个sstable的范围内，就把这个sstable放入tmp中</span></span><br><span class="line">        <span class="keyword">if</span> (ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;smallest.<span class="built_in">user_key</span>()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;largest.<span class="built_in">user_key</span>()) &lt;= <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(f);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tmp.<span class="built_in">empty</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 由新到旧排序，NewestFirst是一个根据序列号的比较器</span></span><br><span class="line">        std::<span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), NewestFirst);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 找到了的话就直接返回</span></span><br><span class="line">            <span class="comment">// func返回true说明是没找到</span></span><br><span class="line">            <span class="keyword">if</span> (!(*func)(arg, <span class="number">0</span>, tmp[i]))</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第0层找不到就继续向下查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">1</span>; level &lt; config::kNumLevels; level++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">size_t</span> num_files = files_[level].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (num_files == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于除了第0层外，剩余层的key范围不重叠，所以每层至多一个sstable包含key</span></span><br><span class="line">        <span class="comment">// 此处就是把可能含有key的那个sstable找出来</span></span><br><span class="line">        <span class="comment">// 查找返回的结果是比要查找的key大的最小的一个sstable</span></span><br><span class="line">        <span class="comment">// 二分法</span></span><br><span class="line">        <span class="type">uint32_t</span> index = <span class="built_in">FindFile</span>(vset_-&gt;icmp_, files_[level], internal_key);</span><br><span class="line">        <span class="keyword">if</span> (index &lt; num_files)</span><br><span class="line">        {</span><br><span class="line">            FileMetaData *f = files_[level][index];</span><br><span class="line">            <span class="keyword">if</span> (ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;smallest.<span class="built_in">user_key</span>()) &lt; <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 这一层内唯一个的一个可能含有key的sstable的范围也不包含key</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (!(*func)(arg, level, f))</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">// 找到就返回</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到，在Version::Get中，定义了一个结构体，可以理解成这个结构体就是全部sstable的集合，主要是为了对一些数据进行封装，方便编码。这个结构体有一个Match函数，这个函数的作用是在第level层的f中查找key(<em><u>这三个都是传入的参数，其中f可以理解成sstable的索引</u></em>)。在Version::Get中，真正开始遍历查询各个层的sstable的函数其实是ForEachOverlapping，<strong>当然这里的sstable也指的是索引，只记录了key的范围和其他一些信息，下面这两段也是通过sstable索引查找</strong>。</p>
<p>在这个函数中，它会从第0层开始，逐层查找每层中<strong>可能</strong>含有key的sstable，并使用结构体中的Match函数判断是否<strong>真的存在</strong>，这个Match函数是通过函数指针传递进去的。另外，由于第0层可能有多个sstable含有key，而其他层则只会最多一个sstable含有key，所以这部分逻辑还是稍有区别的，具体体现在：第0层是遍历；其他层是二分查找。</p>
<p>最后来再看一下这个Match函数，这个函数就是利用sstable的索引来从sstable缓存中拿到真正的那个sstable，并从中查找key，并通过key的类型(删除还是插入还是key损坏)来返回结果。</p>
<h4 id="tablecacheget">TableCache::Get</h4>
<p>虽然之前在缓存中已经阐述过了TableCache::Get方法，但是为了连贯性，此处还是把这一点点代码单独拿出来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 从缓存中获取key-value</span></span><br><span class="line"><span class="function">Status <span class="title">TableCache::Get</span><span class="params">(<span class="type">const</span> ReadOptions &amp;options, <span class="type">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">uint64_t</span> file_size, <span class="type">const</span> Slice &amp;k, <span class="type">void</span> *arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">void</span> (*handle_result)(<span class="type">void</span> *, <span class="type">const</span> Slice &amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> Slice &amp;))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Cache::Handle *handle = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 先从缓存中查找对应的table的缓存项</span></span><br><span class="line">    <span class="comment">// 如果缓存中没有这个table，就会从文件中打开并插入到缓存中</span></span><br><span class="line">    <span class="comment">// 但是TableCache缓存的实际是sstable的索引项</span></span><br><span class="line">    Status s = <span class="built_in">FindTable</span>(file_number, file_size, &amp;handle);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        Table *t = <span class="built_in">reinterpret_cast</span>&lt;TableAndFile *&gt;(cache_-&gt;<span class="built_in">Value</span>(handle))-&gt;table;</span><br><span class="line">        <span class="comment">// 然后从sstable中把这个值给拿出来，这个值会被handle_result这个回调函数处理</span></span><br><span class="line">        s = t-&gt;<span class="built_in">InternalGet</span>(options, k, arg, handle_result);</span><br><span class="line">        cache_-&gt;<span class="built_in">Release</span>(handle);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从TableCache中查找Table缓存的函数</span></span><br><span class="line"><span class="function">Status <span class="title">TableCache::FindTable</span><span class="params">(<span class="type">uint64_t</span> file_number, <span class="type">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Cache::Handle **handle)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Status s;</span><br><span class="line">    <span class="type">char</span> buf[<span class="built_in">sizeof</span>(file_number)];</span><br><span class="line">    <span class="built_in">EncodeFixed64</span>(buf, file_number);</span><br><span class="line">    <span class="function">Slice <span class="title">key</span><span class="params">(buf, <span class="keyword">sizeof</span>(buf))</span></span>; <span class="comment">// 查找时的key为filenumber的编码</span></span><br><span class="line">    *handle = cache_-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (*handle == <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        std::string fname = <span class="built_in">TableFileName</span>(dbname_, file_number);</span><br><span class="line">        RandomAccessFile *file = <span class="literal">nullptr</span>;</span><br><span class="line">        Table *table = <span class="literal">nullptr</span>;</span><br><span class="line">        s = env_-&gt;<span class="built_in">NewRandomAccessFile</span>(fname, &amp;file);</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            std::string old_fname = <span class="built_in">SSTTableFileName</span>(dbname_, file_number);</span><br><span class="line">            <span class="keyword">if</span> (env_-&gt;<span class="built_in">NewRandomAccessFile</span>(old_fname, &amp;file).<span class="built_in">ok</span>())</span><br><span class="line">            {</span><br><span class="line">                s = Status::<span class="built_in">OK</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            s = Table::<span class="built_in">Open</span>(options_, file, file_size, &amp;table);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">ok</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">assert</span>(table == <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">delete</span> file;</span><br><span class="line">            <span class="comment">// We do not cache error results so that if the error is transient,</span></span><br><span class="line">            <span class="comment">// or somebody repairs the file, we recover automatically.</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 找不到就新打开它</span></span><br><span class="line">            TableAndFile *tf = <span class="keyword">new</span> TableAndFile;</span><br><span class="line">            tf-&gt;file = file;</span><br><span class="line">            tf-&gt;table = table;</span><br><span class="line">            *handle = cache_-&gt;<span class="built_in">Insert</span>(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们之前也提到过，TableCache中存储的是sstable的索引项，所以我们能通过这些索引来快速一个key是否<strong>真正</strong>位于此sstable中(布隆过滤器)，以及它会在哪里出现(block的索引)。TableCache::Get就是先调用FindTable来查找一下这个sstable的<strong>索引</strong>，然后调用InternalGet来通过索引获取这个值。其中FindTable作用也很简单，就是先在已有的table索引缓存项中查找，如果找到了就返回这个索引；找不到，就从文件中打开这个sstable，并把缓存插入到索引中。</p>
<p>至于InternalGet这个函数，它就是正经从sstable的block中获取值了。</p>
<h4 id="tableinternalget">Table::InternalGet</h4>
<p>我们来看一下这个函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 从sstable的block中获取值</span></span><br><span class="line"><span class="function">Status <span class="title">Table::InternalGet</span><span class="params">(<span class="type">const</span> ReadOptions &amp;options, <span class="type">const</span> Slice &amp;k, <span class="type">void</span> *arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">void</span> (*handle_result)(<span class="type">void</span> *, <span class="type">const</span> Slice &amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">const</span> Slice &amp;))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Status s;</span><br><span class="line">    <span class="comment">// 搜索索引</span></span><br><span class="line">    Iterator *iiter = rep_-&gt;index_block-&gt;<span class="built_in">NewIterator</span>(rep_-&gt;options.comparator);</span><br><span class="line">    iiter-&gt;<span class="built_in">Seek</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (iiter-&gt;<span class="built_in">Valid</span>())</span><br><span class="line">    {</span><br><span class="line">        Slice handle_value = iiter-&gt;<span class="built_in">value</span>();</span><br><span class="line">        <span class="comment">// 如果使用了布隆过滤器，则先查找布隆过滤器，如果没有发现，就直接返回了</span></span><br><span class="line">        FilterBlockReader *filter = rep_-&gt;filter;</span><br><span class="line">        BlockHandle handle;</span><br><span class="line">        <span class="keyword">if</span> (filter != <span class="literal">nullptr</span> &amp;&amp; handle.<span class="built_in">DecodeFrom</span>(&amp;handle_value).<span class="built_in">ok</span>() &amp;&amp;</span><br><span class="line">            !filter-&gt;<span class="built_in">KeyMayMatch</span>(handle.<span class="built_in">offset</span>(), k))</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Not found</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 读取一个Data Block</span></span><br><span class="line">            Iterator *block_iter = <span class="built_in">BlockReader</span>(<span class="keyword">this</span>, options, iiter-&gt;<span class="built_in">value</span>());</span><br><span class="line">            block_iter-&gt;<span class="built_in">Seek</span>(k);</span><br><span class="line">            <span class="keyword">if</span> (block_iter-&gt;<span class="built_in">Valid</span>())</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 找到对应的键，调用回调函数</span></span><br><span class="line">                (*handle_result)(arg, block_iter-&gt;<span class="built_in">key</span>(), block_iter-&gt;<span class="built_in">value</span>());</span><br><span class="line">            }</span><br><span class="line">            s = block_iter-&gt;<span class="built_in">status</span>();</span><br><span class="line">            <span class="keyword">delete</span> block_iter;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        s = iiter-&gt;<span class="built_in">status</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">delete</span> iiter;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取一个Block，BlockCache就在这里哦</span></span><br><span class="line"><span class="function">Iterator *<span class="title">Table::BlockReader</span><span class="params">(<span class="type">void</span> *arg, <span class="type">const</span> ReadOptions &amp;options,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> Slice &amp;index_value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Table *table = <span class="built_in">reinterpret_cast</span>&lt;Table *&gt;(arg);</span><br><span class="line">    Cache *block_cache = table-&gt;rep_-&gt;options.block_cache;</span><br><span class="line">    Block *block = <span class="literal">nullptr</span>;</span><br><span class="line">    Cache::Handle *cache_handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    BlockHandle handle;</span><br><span class="line">    Slice input = index_value;</span><br><span class="line">    Status s = handle.<span class="built_in">DecodeFrom</span>(&amp;input);</span><br><span class="line">    <span class="comment">// We intentionally allow extra stuff in index_value so that we</span></span><br><span class="line">    <span class="comment">// can add more features in the future.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">    {</span><br><span class="line">        BlockContents contents;</span><br><span class="line">        <span class="comment">// BlockCache在这里</span></span><br><span class="line">        <span class="comment">// 根据block handle，首先尝试从blockcache中直接取出block，不在blockcache中则</span></span><br><span class="line">        <span class="comment">// 调用ReadBlock从文件读取，读取成功后，根据option尝试将block加入到blockcache中。</span></span><br><span class="line">        <span class="comment">// 并在Insert的时候注册了释放函数DeleteCachedBlock。</span></span><br><span class="line">        <span class="keyword">if</span> (block_cache != <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">char</span> cache_key_buffer[<span class="number">16</span>];</span><br><span class="line">            <span class="built_in">EncodeFixed64</span>(cache_key_buffer, table-&gt;rep_-&gt;cache_id);</span><br><span class="line">            <span class="built_in">EncodeFixed64</span>(cache_key_buffer + <span class="number">8</span>, handle.<span class="built_in">offset</span>());</span><br><span class="line">            <span class="function">Slice <span class="title">key</span><span class="params">(cache_key_buffer, <span class="keyword">sizeof</span>(cache_key_buffer))</span></span>;</span><br><span class="line">            <span class="comment">// 先查一下缓存，key是由cache_id和handler的偏移值共同组成</span></span><br><span class="line">            cache_handle = block_cache-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (cache_handle != <span class="literal">nullptr</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 查找到就优先从缓存中返回</span></span><br><span class="line">                block = <span class="built_in">reinterpret_cast</span>&lt;Block *&gt;(block_cache-&gt;<span class="built_in">Value</span>(cache_handle));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 否则就添加到缓存</span></span><br><span class="line">                s = <span class="built_in">ReadBlock</span>(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">                {</span><br><span class="line">                    block = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line">                    <span class="keyword">if</span> (contents.cachable &amp;&amp; options.fill_cache)</span><br><span class="line">                    {</span><br><span class="line">                        cache_handle = block_cache-&gt;<span class="built_in">Insert</span>(key, block, block-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                                           &amp;DeleteCachedBlock);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            s = <span class="built_in">ReadBlock</span>(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">ok</span>())</span><br><span class="line">            {</span><br><span class="line">                block = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回block的迭代器</span></span><br><span class="line">    Iterator *iter;</span><br><span class="line">    <span class="keyword">if</span> (block != <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">        iter = block-&gt;<span class="built_in">NewIterator</span>(table-&gt;rep_-&gt;options.comparator);</span><br><span class="line">        <span class="keyword">if</span> (cache_handle == <span class="literal">nullptr</span>)</span><br><span class="line">        {</span><br><span class="line">            iter-&gt;<span class="built_in">RegisterCleanup</span>(&amp;DeleteBlock, block, <span class="literal">nullptr</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            iter-&gt;<span class="built_in">RegisterCleanup</span>(&amp;ReleaseBlock, block_cache, cache_handle);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        iter = <span class="built_in">NewErrorIterator</span>(s);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而对于Table::InternalGet，基于前面介绍的SSTable的内存结构是比较好理解的：</p>
<ul>
<li>先搜索索引块，找到对应的索引，根据索引找到对应的Data Block</li>
<li>查找Data Block。</li>
</ul>
<p>其中还需要注意在读一个DataBlock的时候是使用到BlockCache的，只不过缓存这个东西有点感觉不到。</p>
<p>因为SSTable里保存的是Internal Key，但是搜索的是User Key，而Iterator
Seek的是第一个大于等于待搜索的键的数据项，如果某个User
Key不存在，是会定位到下一个User Key上面的，所以找到Internal
Key后，还需要比较里的User Key是否相同，这就是回调函数的作用了。</p>
<h3 id="读写的总结">读写的总结</h3>
<h4 id="读取">读取</h4>
<p>对于读取，如果键刚好在MemTable里，那么就是内存访问会非常快。否则就和需要读取的SSTable数量有关。前面说过SSTable里索引等数据是读入内存的，所以每次读取SSTable时，最多只需要一次磁盘IO，读取一个Data
Block。一般Level
0的文件最多为4个，而Level最高为7层，这样就需要10次IO。对于一个不存在的键或者一个很早就写入的键，但是键在多个SSTable的范围内，往往需要花费最大的磁盘IO。然而这是最坏的情景，实际上有优化来减少了磁盘IO：</p>
<ul>
<li>Data Block的缓存，如果在缓存里发现了要读取的Data
Block，那么不需要磁盘IO；</li>
<li>布隆过滤器，对于不存在的键有很好的优化，默认情况下99%的正确率，可以宣告一个键不在这个SSTable里，那么也无需缓存，典型的空间换时间。</li>
</ul>
<p>所以很多读只需要一次磁盘IO，或者不需要磁盘IO。</p>
<ul>
<li>需要从DB中读取一个key的时候，首先调用DBImpl::Get函数，这个函数首先查找memtable、immemtable这些位于内存中的跳表，调用跳表的get方法来查找，这中间能够查找到的一定是最新的数据，可以直接返回</li>
<li>如果上述查找不到，则会调用Version::Get从所有sstable的集合中查找。并且如果一个sstable多次查不到数据，还会尝试将冷数据堆到更高层上去。</li>
<li>在Version::Get中，会调用Version::ForEachOverlapping来对每一层的sstable记录进行查找，找到范围包括key的sstable。其中要区别第0层和其他层的sstable的不同之处(即第0层key会有重叠，其他层不会)</li>
<li>Version::ForEachOverlapping就是简单的遍历一下各个sstable的范围，调用Version::State::Match来对每个可能含有key的sstable进行具体查找。</li>
<li>Version::State::Match则首先调用TableCache::Get来从TableCache中获取key对应的值，然后根据值的类型(插入、删除)来调用回调函数处理。</li>
<li>TableCache::Get会调用TableCache::FindTable找出sstable的索引，如果索引在缓存不命中，就会打开这个sstable的索引并插入到缓存中。</li>
<li>TableCache::Get在拿到sstable的索引后会调用Table::InternalGet来根据索引和BlockCache来正式获取值。</li>
<li>由于user_key和internal_key不同，还需要回调函数来比较一下查找到的key是不是我们要的key，如果是的话，就返回。</li>
</ul>
<h4 id="写入">写入</h4>
<p>对于写入，如果不用sync的方式写入，其实基本就是写内存，而对于sync的方式，每次write都需要做一次磁盘IO，但是磁盘IO是写文件，是顺序IO，所以也是相当快的。而且在写入时，后面来的写请求，都会堆积起来，在后一个写入中批量写入，这样的一次磁盘IO其实是被平摊了。这就是为什么LSM
Tree写入快的原因了。</p>
<ul>
<li>调用DBImpl::Put或DBImpl::Delete进行写入，会生成一个WriteBatch，然后调用DBImpl::Write去处理这个WriteBatch。</li>
<li>Write函数的过程为：先获取锁，同时把batch插入到write_中，检测头结点是不是自己以及队列中的batch是否插入完成了，如果都没有则进入等待中并释放锁。反之，则先将若干个batch打包成一个大的batch，然后按照先写入wal再写入memtable的顺序完成写入。在写入期间锁会被解开，其他线程可以往write_中插入batch。写入完成后重新上锁，更新序列号并从write_中删除写入的部分。</li>
<li>当然，在真正写入之前，会调用DBImpl::MakeRoomForWrite，这个函数会做一些限流策略。</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>使用队列来将线程异步写转化成单线程同步写</li>
<li>设计的时候需要多多分层，按照层级来设置缓存和接口，接口要尽可能简单，但是背后的逻辑可能会有点复杂</li>
</ul>
]]></content>
      <categories>
        <category>levelDB源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>levelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>客户端通过SSH执行可视化程序并转发输出到服务端</title>
    <url>/2023/07/27/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E8%BF%87SSH%E6%89%A7%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A8%8B%E5%BA%8F%E5%B9%B6%E8%BD%AC%E5%8F%91%E8%BE%93%E5%87%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
    <content><![CDATA[<p>客户端使用SSH与服务端相连，通过SSH执行可视化程序时，将显示输出显示在服务端的显示器，而非客户端。</p>
<span id="more"></span>
<h2 id="x0-前言----这是什么需求">0x0 前言----这是什么需求？</h2>
<p>听起来，这个需求似乎是这样的？</p>
<img src="/2023/07/27/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E8%BF%87SSH%E6%89%A7%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A8%8B%E5%BA%8F%E5%B9%B6%E8%BD%AC%E5%8F%91%E8%BE%93%E5%87%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF/pic1.png" class="">
<p><strong>可能有人会说：那干嘛不直接在服务端执行程序呢？</strong></p>
<p>仅仅针对这个需求而言，真的好有道理...</p>
<p>但是事实是：服务端是一台SLAM小车上的嵌入式设备，客户端是我的电脑，我需要修改小车中的代码，并观察算法效果。</p>
<p>我是通过vsc来和服务端相连，直接在vsc的terminal里执行程序。但是遇到需要输出图像的程序时，会出现<code>This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.</code>这样的错误。</p>
<p>很显然，SSH并不是一个带有可视化显示的终端，但是我又不想把输出转发回客户端，而是希望直接显示在服务端的HDMI显示器上。</p>
<h2 id="x1-解决过程">0x1 解决过程</h2>
<ol type="1">
<li>找来一个屏幕接在SLAM小车上。</li>
<li>开启图像化界面<code>sudo init 5</code></li>
<li>配置好图形界面的用户为当前登录的SSH用户(<strong>这点很重要，只有相同的用户才能显示输出</strong>)</li>
<li>SSH配置输出，在vsc的terminal中执行<code>export DISPLAY=:0.0</code></li>
<li>完成！</li>
</ol>
<h2 id="x2-效果展示">0x2 效果展示</h2>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="pic3.jpg" width="450" alt="前"></div><div class="group-picture-column" style="width: 50%;"><img src="pic2.jpg" width="450" alt="后"></div></div></div></div>
<p>当在SSH中执行需要输出图像的程序时，会直接在服务端的HDMI屏幕中输出。可以把<code>export DISPLAY=:0.0</code>写入环境变量中，从而自动配置。</p>
]]></content>
      <categories>
        <category>工具杂谈</category>
      </categories>
      <tags>
        <tag>开发板使用</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
</search>
